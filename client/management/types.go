// This file was auto-generated by Fern from our API Definition.

package management

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type Account struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
	Id        AccountId `json:"id,omitempty"`
	// Human friendly display name for this account.
	Fullname string `json:"fullname"`
	// Organization that manages this Account.
	OrganizationId OrganizationId `json:"organization_id,omitempty"`
}

// Unique identifier for this Account
type AccountId = Id

type CreateAccountResponseResult struct {
	Account *Account `json:"account,omitempty"`
}

type Audit struct {
	Environment string `json:"environment"`
	// Time when the API request occurred.
	CreatedAt     time.Time      `json:"created_at"`
	RemoteAddr    string         `json:"remote_addr"`
	UserAgent     string         `json:"user_agent"`
	Method        HttpMethod     `json:"method,omitempty"`
	Path          string         `json:"path"`
	Code          string         `json:"code"`
	Body          interface{}    `json:"body,omitempty"`
	Response      *string        `json:"response,omitempty"`
	Status        *string        `json:"status,omitempty"`
	MemberId      *MemberId      `json:"member_id,omitempty"`
	AccountId     *AccountId     `json:"account_id,omitempty"`
	IntegrationId *IntegrationId `json:"integration_id,omitempty"`
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodDelete HttpMethod = "DELETE"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "DELETE":
		return HttpMethodDelete, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type CapabilitiesProviderConfig = map[string]interface{}

// Provides details on an available Integration.
type Category struct {
	Category CategoryId `json:"category,omitempty"`
	// Description of what this Integration does.
	Description string `json:"description"`
	// List of Providers that implement this Integration.
	Providers []ProviderId `json:"providers,omitempty"`
	// URL of the icon representing this type of Integration.
	Picture *string `json:"picture,omitempty"`
}

// Id of the Integrations category
type CategoryId string

const (
	CategoryIdAssets          CategoryId = "assets"
	CategoryIdHooks           CategoryId = "hooks"
	CategoryIdIdentity        CategoryId = "identity"
	CategoryIdNotifications   CategoryId = "notifications"
	CategoryIdSiem            CategoryId = "siem"
	CategoryIdSink            CategoryId = "sink"
	CategoryIdStorage         CategoryId = "storage"
	CategoryIdTicketing       CategoryId = "ticketing"
	CategoryIdVulnerabilities CategoryId = "vulnerabilities"
)

func NewCategoryIdFromString(s string) (CategoryId, error) {
	switch s {
	case "assets":
		return CategoryIdAssets, nil
	case "hooks":
		return CategoryIdHooks, nil
	case "identity":
		return CategoryIdIdentity, nil
	case "notifications":
		return CategoryIdNotifications, nil
	case "siem":
		return CategoryIdSiem, nil
	case "sink":
		return CategoryIdSink, nil
	case "storage":
		return CategoryIdStorage, nil
	case "ticketing":
		return CategoryIdTicketing, nil
	case "vulnerabilities":
		return CategoryIdVulnerabilities, nil
	}
	var t CategoryId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryId) Ptr() *CategoryId {
	return &c
}

type Provider struct {
	Id ProviderId `json:"id"`
	// Name of the Provider.
	Name string `json:"name"`
	// Description of what this Provider does.
	Description string `json:"description"`
	// Categories that this Provider implements.
	Categories []CategoryId `json:"categories,omitempty"`
	// URL of the icon representing this type of Provider.
	Picture *string `json:"picture,omitempty"`
	// Operations that this Provider implements.
	SupportedOperations interface{} `json:"supported_operations,omitempty"`
	// List of credential types that this Provider supports.
	Credentials []ProviderCredentialConfig `json:"credentials,omitempty"`
	// Details on the specific configuration options for this Provider.
	ProviderConfig map[string]CapabilitiesProviderConfig `json:"provider_config,omitempty"`
}

type ProviderCredentialConfig = map[string]interface{}

type ProviderId = string

type Base struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
}

type ErrorBody struct {
	Status     int           `json:"status"`
	Message    *string       `json:"message,omitempty"`
	Errors     []string      `json:"errors,omitempty"`
	Parameters []*ErrorParam `json:"parameters,omitempty"`
}

type ErrorParam struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type Id = string

// AWS access key to authenticate with AWS. Access keys are long-term credentials for an IAM user and consist of an ID and secret. Follow [this guide to generate access and secret keys](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys). You may optionally provide a session token if you are using temporary credentials.
type AwsCredential struct {
	// ID portion of the AWS access key pair.
	AccessKeyId string `json:"access_key_id"`
	// Secret portion of the AWS access key pair.
	SecretAccessKey string `json:"secret_access_key"`
	// A temporary session token. Session tokens are optional and are only necessary if you are using temporary credentials.
	Session *string `json:"session,omitempty"`
}

// Username and secret used to authenticate with an external service.
type BasicCredential struct {
	// Username value for authentication
	Username string `json:"username"`
	// Secret value for authentication
	Secret string `json:"secret"`
}

// Credential to access an integration. Each credential is owned by an Account.
type Credential struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at"`
	Id        CredentialId `json:"id,omitempty"`
	// Account that manages this credential.
	AccountId AccountId `json:"account_id,omitempty"`
	// Human friendly display name for this Organization
	Fullname string `json:"fullname"`
	// Credential configuration
	Config *CredentialConfig `json:"config,omitempty"`
}

type CredentialConfig struct {
	Type   string
	Aws    *AwsCredential
	Token  *TokenCredential
	Basic  *BasicCredential
	Secret *SecretCredential
}

func NewCredentialConfigFromAws(value *AwsCredential) *CredentialConfig {
	return &CredentialConfig{Type: "aws", Aws: value}
}

func NewCredentialConfigFromToken(value *TokenCredential) *CredentialConfig {
	return &CredentialConfig{Type: "token", Token: value}
}

func NewCredentialConfigFromBasic(value *BasicCredential) *CredentialConfig {
	return &CredentialConfig{Type: "basic", Basic: value}
}

func NewCredentialConfigFromSecret(value *SecretCredential) *CredentialConfig {
	return &CredentialConfig{Type: "secret", Secret: value}
}

func (c *CredentialConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Aws = value
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Token = value
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Basic = value
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Secret = value
	}
	return nil
}

func (c CredentialConfig) MarshalJSON() ([]byte, error) {
	switch c.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "aws":
		var marshaler = struct {
			Type string `json:"type"`
			*AwsCredential
		}{
			Type:          c.Type,
			AwsCredential: c.Aws,
		}
		return json.Marshal(marshaler)
	case "token":
		var marshaler = struct {
			Type string `json:"type"`
			*TokenCredential
		}{
			Type:            c.Type,
			TokenCredential: c.Token,
		}
		return json.Marshal(marshaler)
	case "basic":
		var marshaler = struct {
			Type string `json:"type"`
			*BasicCredential
		}{
			Type:            c.Type,
			BasicCredential: c.Basic,
		}
		return json.Marshal(marshaler)
	case "secret":
		var marshaler = struct {
			Type string `json:"type"`
			*SecretCredential
		}{
			Type:             c.Type,
			SecretCredential: c.Secret,
		}
		return json.Marshal(marshaler)
	}
}

type CredentialConfigVisitor interface {
	VisitAws(*AwsCredential) error
	VisitToken(*TokenCredential) error
	VisitBasic(*BasicCredential) error
	VisitSecret(*SecretCredential) error
}

func (c *CredentialConfig) Accept(visitor CredentialConfigVisitor) error {
	switch c.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", c.Type, c)
	case "aws":
		return visitor.VisitAws(c.Aws)
	case "token":
		return visitor.VisitToken(c.Token)
	case "basic":
		return visitor.VisitBasic(c.Basic)
	case "secret":
		return visitor.VisitSecret(c.Secret)
	}
}

type CredentialConfigNoSecret struct {
	Type string `json:"type"`
}

// Response object for a Credential
type CredentialResponse struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at"`
	Id        CredentialId `json:"id,omitempty"`
	// Account that manages this credential.
	AccountId AccountId `json:"account_id,omitempty"`
	// Human friendly display name for this Organization.
	Fullname string                    `json:"fullname"`
	Config   *CredentialConfigNoSecret `json:"config,omitempty"`
}

type CredentialType string

const (
	CredentialTypeAws    CredentialType = "aws"
	CredentialTypeToken  CredentialType = "token"
	CredentialTypeBasic  CredentialType = "basic"
	CredentialTypeSecret CredentialType = "secret"
)

func NewCredentialTypeFromString(s string) (CredentialType, error) {
	switch s {
	case "aws":
		return CredentialTypeAws, nil
	case "token":
		return CredentialTypeToken, nil
	case "basic":
		return CredentialTypeBasic, nil
	case "secret":
		return CredentialTypeSecret, nil
	}
	var t CredentialType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialType) Ptr() *CredentialType {
	return &c
}

// Secret value such as password or webhook url
type SecretCredential struct {
	// Secret value
	Secret string `json:"secret"`
}

// Token used to authenticate with an external service.
type TokenCredential struct {
	// Secret value of the token.
	Secret string `json:"secret"`
}

// Configuration for an Assets Provider
type AssetsConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// URL used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider
	Url *string `json:"url,omitempty"`
}

// Configuration specific to AWS type Event Providers
type AwsConfig struct {
	// Override the default AWS region for this integration. If not present, the region will be infered from the URL.
	Region *string `json:"region,omitempty"`
}

// Configuration specific to Azure Monitor Logs
type AzureMonitorLogsConfig struct {
	// Azure Client (Application) ID.
	ClientId string `json:"client_id"`
	// Azure Directory (tenant) ID.
	TenantId string `json:"tenant_id"`
	// Data Collection Rule immutable ID.
	RuleId string `json:"rule_id"`
	// Name of the Data Collection Rule stream.
	StreamName string `json:"stream_name"`
}

type CreateIntegrationResponseResult struct {
	Integration *Integration `json:"integration,omitempty"`
	Token       *TokenPair   `json:"token,omitempty"`
}

type ElasticsearchConfig struct {
	// Elasticsearch index to send events to.
	Index string `json:"index"`
}

// Configuration for Microsoft Entra ID tenants
type EntraIdConfig struct {
	// Azure Client (Application) ID.
	ClientId string `json:"client_id"`
	// Azure Directory (tenant) ID.
	TenantId string `json:"tenant_id"`
	// Any custom scopes. Defaults to the primary microsoft graph API default scope.
	Scopes []string `json:"scopes,omitempty"`
}

// Configuration for a Webhook Provider
type HooksConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// Endpoint used for connecting to the external service.
	Endpoint *string `json:"endpoint,omitempty"`
	// Optional webhook filter specification
	Filter *string `json:"filter,omitempty"`
	// Events to hook or empty list for all events
	SourceEvents []string `json:"source_events,omitempty"`
	// Webhook verification secret
	SourceSecret *CredentialId `json:"source_secret,omitempty"`
	// Add optional webhook secure hash for verification
	TargetSecret *CredentialId `json:"target_secret,omitempty"`
	// Optional list of transformations used to modify the webhook responses.
	Transforms []TransformId `json:"transforms,omitempty"`
}

// Configuration for an Identity Provider
type IdentityConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// URL used for connecting to the identity provider.
	Url    *string                     `json:"url,omitempty"`
	Config *IdentityProviderTypeConfig `json:"config,omitempty"`
}

type IdentityProviderTypeConfig struct {
	Type    string
	EntraId *EntraIdConfig
	Pingone *PingOneConfig
}

func NewIdentityProviderTypeConfigFromEntraId(value *EntraIdConfig) *IdentityProviderTypeConfig {
	return &IdentityProviderTypeConfig{Type: "entra_id", EntraId: value}
}

func NewIdentityProviderTypeConfigFromPingone(value *PingOneConfig) *IdentityProviderTypeConfig {
	return &IdentityProviderTypeConfig{Type: "pingone", Pingone: value}
}

func (i *IdentityProviderTypeConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "entra_id":
		value := new(EntraIdConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.EntraId = value
	case "pingone":
		value := new(PingOneConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Pingone = value
	}
	return nil
}

func (i IdentityProviderTypeConfig) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "entra_id":
		var marshaler = struct {
			Type string `json:"type"`
			*EntraIdConfig
		}{
			Type:          i.Type,
			EntraIdConfig: i.EntraId,
		}
		return json.Marshal(marshaler)
	case "pingone":
		var marshaler = struct {
			Type string `json:"type"`
			*PingOneConfig
		}{
			Type:          i.Type,
			PingOneConfig: i.Pingone,
		}
		return json.Marshal(marshaler)
	}
}

type IdentityProviderTypeConfigVisitor interface {
	VisitEntraId(*EntraIdConfig) error
	VisitPingone(*PingOneConfig) error
}

func (i *IdentityProviderTypeConfig) Accept(visitor IdentityProviderTypeConfigVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "entra_id":
		return visitor.VisitEntraId(i.EntraId)
	case "pingone":
		return visitor.VisitPingone(i.Pingone)
	}
}

// Connects an Account to an external service
type Integration struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time     `json:"updated_at"`
	Id        IntegrationId `json:"id,omitempty"`
	// Human friendly display name for this integration.
	Fullname string `json:"fullname"`
	// Integration refresh token id
	RefreshTokenId TokenId `json:"refresh_token_id,omitempty"`
	// Account that manages this Integration.
	AccountId AccountId `json:"account_id,omitempty"`
	// Id of the categorical type for this Integration.
	Category CategoryId `json:"category,omitempty"`
	// Provider implementation to use for this Integration.
	ProviderType ProviderId `json:"provider_type"`
	// Custom configuration for the Provider.
	ProviderConfig *ProviderConfig `json:"provider_config,omitempty"`
}

// Unique identifier for this Integration
type IntegrationId = Id

// Configuration for a Notification Provider
type NotificationConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty"`
	// Channel specification
	Channel *string `json:"channel,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty"`
}

// Configuration for the PingOne identity platform
type PingOneConfig struct {
	// The client ID for the application set up as a worker.
	ClientId string `json:"client_id"`
	// The organization ID that the client app is a part of.
	OrganizationId string `json:"organization_id"`
	// The URL base for making authentication requests to PingOne.
	AuthUrl string `json:"auth_url"`
}

type ProviderConfig struct {
	Type            string
	Assets          *AssetsConfig
	Hooks           *HooksConfig
	Identity        *IdentityConfig
	Notifications   *NotificationConfig
	Siem            *SiemConfig
	Sink            *SinkConfig
	Storage         *StorageConfig
	Ticketing       *TicketingConfig
	Vulnerabilities *VulnerabilityConfig
}

func NewProviderConfigFromAssets(value *AssetsConfig) *ProviderConfig {
	return &ProviderConfig{Type: "assets", Assets: value}
}

func NewProviderConfigFromHooks(value *HooksConfig) *ProviderConfig {
	return &ProviderConfig{Type: "hooks", Hooks: value}
}

func NewProviderConfigFromIdentity(value *IdentityConfig) *ProviderConfig {
	return &ProviderConfig{Type: "identity", Identity: value}
}

func NewProviderConfigFromNotifications(value *NotificationConfig) *ProviderConfig {
	return &ProviderConfig{Type: "notifications", Notifications: value}
}

func NewProviderConfigFromSiem(value *SiemConfig) *ProviderConfig {
	return &ProviderConfig{Type: "siem", Siem: value}
}

func NewProviderConfigFromSink(value *SinkConfig) *ProviderConfig {
	return &ProviderConfig{Type: "sink", Sink: value}
}

func NewProviderConfigFromStorage(value *StorageConfig) *ProviderConfig {
	return &ProviderConfig{Type: "storage", Storage: value}
}

func NewProviderConfigFromTicketing(value *TicketingConfig) *ProviderConfig {
	return &ProviderConfig{Type: "ticketing", Ticketing: value}
}

func NewProviderConfigFromVulnerabilities(value *VulnerabilityConfig) *ProviderConfig {
	return &ProviderConfig{Type: "vulnerabilities", Vulnerabilities: value}
}

func (p *ProviderConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "assets":
		value := new(AssetsConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Assets = value
	case "hooks":
		value := new(HooksConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Hooks = value
	case "identity":
		value := new(IdentityConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Identity = value
	case "notifications":
		value := new(NotificationConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Notifications = value
	case "siem":
		value := new(SiemConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Siem = value
	case "sink":
		value := new(SinkConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Sink = value
	case "storage":
		value := new(StorageConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Storage = value
	case "ticketing":
		value := new(TicketingConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Ticketing = value
	case "vulnerabilities":
		value := new(VulnerabilityConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Vulnerabilities = value
	}
	return nil
}

func (p ProviderConfig) MarshalJSON() ([]byte, error) {
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "assets":
		var marshaler = struct {
			Type string `json:"type"`
			*AssetsConfig
		}{
			Type:         p.Type,
			AssetsConfig: p.Assets,
		}
		return json.Marshal(marshaler)
	case "hooks":
		var marshaler = struct {
			Type string `json:"type"`
			*HooksConfig
		}{
			Type:        p.Type,
			HooksConfig: p.Hooks,
		}
		return json.Marshal(marshaler)
	case "identity":
		var marshaler = struct {
			Type string `json:"type"`
			*IdentityConfig
		}{
			Type:           p.Type,
			IdentityConfig: p.Identity,
		}
		return json.Marshal(marshaler)
	case "notifications":
		var marshaler = struct {
			Type string `json:"type"`
			*NotificationConfig
		}{
			Type:               p.Type,
			NotificationConfig: p.Notifications,
		}
		return json.Marshal(marshaler)
	case "siem":
		var marshaler = struct {
			Type string `json:"type"`
			*SiemConfig
		}{
			Type:       p.Type,
			SiemConfig: p.Siem,
		}
		return json.Marshal(marshaler)
	case "sink":
		var marshaler = struct {
			Type string `json:"type"`
			*SinkConfig
		}{
			Type:       p.Type,
			SinkConfig: p.Sink,
		}
		return json.Marshal(marshaler)
	case "storage":
		var marshaler = struct {
			Type string `json:"type"`
			*StorageConfig
		}{
			Type:          p.Type,
			StorageConfig: p.Storage,
		}
		return json.Marshal(marshaler)
	case "ticketing":
		var marshaler = struct {
			Type string `json:"type"`
			*TicketingConfig
		}{
			Type:            p.Type,
			TicketingConfig: p.Ticketing,
		}
		return json.Marshal(marshaler)
	case "vulnerabilities":
		var marshaler = struct {
			Type string `json:"type"`
			*VulnerabilityConfig
		}{
			Type:                p.Type,
			VulnerabilityConfig: p.Vulnerabilities,
		}
		return json.Marshal(marshaler)
	}
}

type ProviderConfigVisitor interface {
	VisitAssets(*AssetsConfig) error
	VisitHooks(*HooksConfig) error
	VisitIdentity(*IdentityConfig) error
	VisitNotifications(*NotificationConfig) error
	VisitSiem(*SiemConfig) error
	VisitSink(*SinkConfig) error
	VisitStorage(*StorageConfig) error
	VisitTicketing(*TicketingConfig) error
	VisitVulnerabilities(*VulnerabilityConfig) error
}

func (p *ProviderConfig) Accept(visitor ProviderConfigVisitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "assets":
		return visitor.VisitAssets(p.Assets)
	case "hooks":
		return visitor.VisitHooks(p.Hooks)
	case "identity":
		return visitor.VisitIdentity(p.Identity)
	case "notifications":
		return visitor.VisitNotifications(p.Notifications)
	case "siem":
		return visitor.VisitSiem(p.Siem)
	case "sink":
		return visitor.VisitSink(p.Sink)
	case "storage":
		return visitor.VisitStorage(p.Storage)
	case "ticketing":
		return visitor.VisitTicketing(p.Ticketing)
	case "vulnerabilities":
		return visitor.VisitVulnerabilities(p.Vulnerabilities)
	}
}

// Configuration for a SIEM Provider
type SiemConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// URL used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider
	Url *string `json:"url,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId           `json:"transforms,omitempty"`
	Config     *SiemProviderTypeConfig `json:"config,omitempty"`
}

type SiemProviderTypeConfig struct {
	Type          string
	Splunk        *SplunkConfig
	Elasticsearch *ElasticsearchConfig
}

func NewSiemProviderTypeConfigFromSplunk(value *SplunkConfig) *SiemProviderTypeConfig {
	return &SiemProviderTypeConfig{Type: "splunk", Splunk: value}
}

func NewSiemProviderTypeConfigFromElasticsearch(value *ElasticsearchConfig) *SiemProviderTypeConfig {
	return &SiemProviderTypeConfig{Type: "elasticsearch", Elasticsearch: value}
}

func (s *SiemProviderTypeConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "splunk":
		value := new(SplunkConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Splunk = value
	case "elasticsearch":
		value := new(ElasticsearchConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Elasticsearch = value
	}
	return nil
}

func (s SiemProviderTypeConfig) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "splunk":
		var marshaler = struct {
			Type string `json:"type"`
			*SplunkConfig
		}{
			Type:         s.Type,
			SplunkConfig: s.Splunk,
		}
		return json.Marshal(marshaler)
	case "elasticsearch":
		var marshaler = struct {
			Type string `json:"type"`
			*ElasticsearchConfig
		}{
			Type:                s.Type,
			ElasticsearchConfig: s.Elasticsearch,
		}
		return json.Marshal(marshaler)
	}
}

type SiemProviderTypeConfigVisitor interface {
	VisitSplunk(*SplunkConfig) error
	VisitElasticsearch(*ElasticsearchConfig) error
}

func (s *SiemProviderTypeConfig) Accept(visitor SiemProviderTypeConfigVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "splunk":
		return visitor.VisitSplunk(s.Splunk)
	case "elasticsearch":
		return visitor.VisitElasticsearch(s.Elasticsearch)
	}
}

// Configuration for a Sink Provider
type SinkConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// URL used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider
	Url *string `json:"url,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId           `json:"transforms,omitempty"`
	Config     *SinkProviderTypeConfig `json:"config,omitempty"`
}

type SinkProviderTypeConfig struct {
	Type             string
	AzureMonitorLogs *AzureMonitorLogsConfig
	Aws              *AwsConfig
}

func NewSinkProviderTypeConfigFromAzureMonitorLogs(value *AzureMonitorLogsConfig) *SinkProviderTypeConfig {
	return &SinkProviderTypeConfig{Type: "azure_monitor_logs", AzureMonitorLogs: value}
}

func NewSinkProviderTypeConfigFromAws(value *AwsConfig) *SinkProviderTypeConfig {
	return &SinkProviderTypeConfig{Type: "aws", Aws: value}
}

func (s *SinkProviderTypeConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "azure_monitor_logs":
		value := new(AzureMonitorLogsConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.AzureMonitorLogs = value
	case "aws":
		value := new(AwsConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Aws = value
	}
	return nil
}

func (s SinkProviderTypeConfig) MarshalJSON() ([]byte, error) {
	switch s.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "azure_monitor_logs":
		var marshaler = struct {
			Type string `json:"type"`
			*AzureMonitorLogsConfig
		}{
			Type:                   s.Type,
			AzureMonitorLogsConfig: s.AzureMonitorLogs,
		}
		return json.Marshal(marshaler)
	case "aws":
		var marshaler = struct {
			Type string `json:"type"`
			*AwsConfig
		}{
			Type:      s.Type,
			AwsConfig: s.Aws,
		}
		return json.Marshal(marshaler)
	}
}

type SinkProviderTypeConfigVisitor interface {
	VisitAzureMonitorLogs(*AzureMonitorLogsConfig) error
	VisitAws(*AwsConfig) error
}

func (s *SinkProviderTypeConfig) Accept(visitor SinkProviderTypeConfigVisitor) error {
	switch s.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", s.Type, s)
	case "azure_monitor_logs":
		return visitor.VisitAzureMonitorLogs(s.AzureMonitorLogs)
	case "aws":
		return visitor.VisitAws(s.Aws)
	}
}

// Configuration specific to the Splunk Event Provider
type SplunkConfig struct {
	// If true, skips verification of the Splunk server's TLS certificate. Defaults to false.
	SkipTlsVerify bool `json:"skip_tls_verify"`
	// Splunk index to send events to. If not provided, will use the default index for the Splunk collector.
	Index *string `json:"index,omitempty"`
	// Splunk source to send events to. If not provided, will use the default source for the Splunk collector.
	Source *string `json:"source,omitempty"`
	// Splunk source type to send events to. If not provided, will use the default source type for the Splunk collector.
	SourceType *string `json:"source_type,omitempty"`
	// Optional URL used for connecting to the Splunk search service. If not provided, querying is disabled.
	SearchServiceUrl *string `json:"search_service_url,omitempty"`
	// Optional id of a credential used for connecting to the Splunk search service. If not provided, querying is disabled.
	SearchServiceCredentialId *CredentialId `json:"search_service_credential_id,omitempty"`
}

// Configuration for a Storage Provider
type StorageConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	Bucket       string       `json:"bucket"`
	Region       string       `json:"region"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty"`
}

// Configuration for a Ticketing Provider
type TicketingConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty"`
}

// Configuration for a Vulnerability Provider
type VulnerabilityConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty"`
}

type CreateMemberResponseResult struct {
	Member *Member `json:"member,omitempty"`
}

type Member struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
	Id        MemberId  `json:"id,omitempty"`
	State     State     `json:"state,omitempty"`
	// Last logon time
	LastLogon time.Time `json:"last_logon"`
	// User's full display name
	Fullname string `json:"fullname"`
	// User's nickname
	Nickname string `json:"nickname"`
	// Url of user's picture
	Picture    string    `json:"picture"`
	Ttl        string    `json:"ttl"`
	TokenTtl   string    `json:"token_ttl"`
	Expires    time.Time `json:"expires"`
	PinExpires time.Time `json:"pin_expires"`
	// Roles granted to this member. Tokens inherit this access.
	Roles []*Role `json:"roles,omitempty"`
}

type MemberOptions struct {
	// Optional member time-to-live duration. After a member expires, system requires a change password to re-enable member. Minimum 1 day, Maximum 1 year, Default 180 days.
	Ttl string `json:"ttl"`
	// Options: "expired" will force change password on first logon.
	Options []Options `json:"options,omitempty"`
	// Optional token time-to-live duration. Tokens are created for this member with this duration as their TTL. Minimum 10 miniutes, Maximum 1 week, Defaults 1 hour.
	TokenTtl string `json:"token_ttl"`
}

type Options string

const (
	OptionsDisabled  Options = "disabled"
	OptionsExpired   Options = "expired"
	OptionsForgotten Options = "forgotten"
	OptionsInvited   Options = "invited"
	OptionsLocked    Options = "locked"
)

func NewOptionsFromString(s string) (Options, error) {
	switch s {
	case "disabled":
		return OptionsDisabled, nil
	case "expired":
		return OptionsExpired, nil
	case "forgotten":
		return OptionsForgotten, nil
	case "invited":
		return OptionsInvited, nil
	case "locked":
		return OptionsLocked, nil
	}
	var t Options
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Options) Ptr() *Options {
	return &o
}

type State string

const (
	StateDisabled  State = "disabled"
	StateEnabled   State = "enabled"
	StateForgotten State = "forgotten"
	StateInvited   State = "invited"
	StateLocked    State = "locked"
)

func NewStateFromString(s string) (State, error) {
	switch s {
	case "disabled":
		return StateDisabled, nil
	case "enabled":
		return StateEnabled, nil
	case "forgotten":
		return StateForgotten, nil
	case "invited":
		return StateInvited, nil
	case "locked":
		return StateLocked, nil
	}
	var t State
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s State) Ptr() *State {
	return &s
}

type Organization struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time      `json:"updated_at"`
	Id        OrganizationId `json:"id,omitempty"`
	// Organization refresh token id
	RefreshTokenId TokenId `json:"refresh_token_id,omitempty"`
	// Human friendly display name for this Organization
	Fullname string `json:"fullname"`
	// Organization email address
	Contact string `json:"contact"`
	// Reply-to email address, used for SMTP emails. Defaults to no-reply@synqly.com
	ReplyTo string `json:"reply_to"`
	// URL of the organization
	Picture string `json:"picture"`
	// Organization options
	Options *OrganizationOptions `json:"options,omitempty"`
}

// Unique identifier for this Organization
type OrganizationId = Id

type OrganizationOptions struct {
	// Duration new member invitations will be valid. Default: 168h (7 days), minimum 24h, maximum 168h (7 days).
	InviteDuration *string `json:"invite_duration,omitempty"`
	// Duration forgotten password invitations will be valid. Default: 24h, minimum 24h, maximum 168h (7 days).
	ForgotDuration *string `json:"forgot_duration,omitempty"`
	// Duration before member password expires, part of required password rotation. Default: 4320h (180 days), minimum: 24h, maximum: 8760h (365 days).
	PasswordDuration *string `json:"password_duration,omitempty"`
	// Minimum password length. Default: 8, minimum 8, maximum 72.
	MinimumPasswordLength *int `json:"minimum_password_length,omitempty"`
}

// Type of action granted access by an API operation: "create", "read", "update", "delete", or "*".
type Action = string

// APIs allowed access to by prefix endpoint match. Can be used to allow access to select APIs like /v1/accounts, /v1/credentials, and /v1/transforms.
type AllowedApi = string

// APIs disallowed access to by prefix endpoint match. Can be used to block access to select APIs like /v1/users, /v1/tokens, and /v1/credentials.
type BlockedApi = string

type Constraint struct {
	// Contained object constraint granted access or "*".
	Object string `json:"object"`
	// Object type (ie: "category", "tag")
	Type string `json:"type"`
}

// Contained objects granted access to by Id or "*".
type Object = Id

type Permission struct {
	// List of access roles. Authorization tries each role sequentially until one access role passes or they all fail
	Roles []*Role `json:"roles,omitempty"`
	// ID of the resource that this permission grants access to.
	ResourceId Id `json:"resource_id"`
	// Type of the resource that this permission grants access to. Must be one of the following: "organization, "integration"
	ResourceType string `json:"resource_type"`
	// Token parentId
	ParentId Id `json:"parent_id"`
	// Token Id
	Id Id `json:"id"`
	// Token organizationId
	OrganizationId Id `json:"organization_id"`
	// Token memberId
	MemberId Id `json:"member_id"`
}

type Role struct {
	// List of actions that this permission grants access to: "create", "read", "update", "delete" and "*". Use "*" to give all action permissions.
	Actions []Action `json:"actions,omitempty"`
	// List of contained account ids that this permission grants access to. Use "*" to grant access to all contained objects.
	Objects []Object `json:"objects,omitempty"`
	// Optional list of constraints that this permission grants access to. Use "*" to grant access to all constrained objects.
	Constraints []*Constraint `json:"constraints,omitempty"`
	// Optional list of APIs that this role allows access to. Can be used to allow access to select APIs like /v1/accounts, v1/credentials and /v1/transforms
	AllowedApis []AllowedApi `json:"allowed_apis,omitempty"`
	// Optional list of APIs that this role blocks access to. Can be used to block access to select APIs like /v1/user, v1/tokens and /v1/credentials
	BlockedApis []BlockedApi `json:"blocked_apis,omitempty"`
}

type GetIntegrationTimeseriesResult = *GetStatusTimeseriesResult

// Status timeseries object
type GetStatusTimeseriesResult struct {
	// start time
	StartTime time.Time `json:"start_time"`
	// end time
	EndTime time.Time `json:"end_time"`
	// interval duration
	Interval string              `json:"interval"`
	Series   []*TimeseriesResult `json:"series,omitempty"`
}

// Status object
type Status struct {
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
	// Account owner
	AccountId AccountId `json:"account_id,omitempty"`
	// Integration object
	IntegrationId IntegrationId `json:"integration_id,omitempty"`
	// The current status of the notification.
	Status string `json:"status"`
	// Request count
	Requests int64 `json:"requests"`
	// Failed count
	Failed int64 `json:"failed"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time"`
	// Database operations count
	DbOps int64 `json:"db_ops"`
	// API operations count
	ApiOps int64 `json:"api_ops"`
	// API input byte count
	InBytes int64 `json:"in_bytes"`
}

// Status event object
type StatusEvent struct {
	// Account owner
	AccountId AccountId `json:"account_id,omitempty"`
	// Integration object
	IntegrationId IntegrationId `json:"integration_id,omitempty"`
	// Time created
	CreatedAt time.Time `json:"created_at"`
	// Error message
	Error *string `json:"error,omitempty"`
	// Request number
	Request int64 `json:"request"`
}

// Status timeseries object
type TimeseriesResult struct {
	// Interval time
	CreatedAt time.Time `json:"created_at"`
	// Succeeded count
	Succeeded int64 `json:"succeeded"`
	// Failed count
	Failed int64 `json:"failed"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time"`
	// API input byte count
	InBytes int64 `json:"in_bytes"`
}

type Token struct {
	// Secret value for the token; used for authentication when making requests.
	Secret string `json:"secret"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires"`
	// Permissions granted to this token.
	Permissions *Permission `json:"permissions,omitempty"`
}

type TokenPair struct {
	// Access token contains the bearer secret
	Access *Token `json:"access,omitempty"`
	// Refresh token used for RefreshToken API
	Refresh *Token `json:"refresh,omitempty"`
}

type RefreshToken struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
	Id        TokenId   `json:"id,omitempty"`
	// Member Id
	MemberId *Id `json:"member_id,omitempty"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires"`
	// Token time-to-live
	TokenTtl string `json:"token_ttl"`
	// Primary running access and refresh tokens
	Primary *TokenPair `json:"primary,omitempty"`
	// Temporary secondary TokenPair created after a RefreshToken operation
	Secondary *TokenPair `json:"secondary,omitempty"`
}

// Transforms data collected before it is sent to the target Integration.
type Transform struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time   `json:"updated_at"`
	Id        TransformId `json:"id,omitempty"`
	// Account that manages this Transform.
	AccountId AccountId `json:"account_id,omitempty"`
	// Human friendly display name for this Organization.
	Fullname string `json:"fullname"`
	// JSON Patch transform to apply (rfc6902).
	Patch []byte `json:"patch"`
}

type Usage struct {
	IntegrationId     Id      `json:"integration_id"`
	RequestsCount     float64 `json:"requests_count"`
	CpuTimeSeconds    float64 `json:"cpu_time_seconds"`
	DbOperationsCount float64 `json:"db_operations_count"`
	IntOpsCount       float64 `json:"int_ops_count"`
}
