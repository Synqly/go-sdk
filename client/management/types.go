// This file was auto-generated by Fern from our API Definition.

package management

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type Account struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
	Id        AccountId `json:"id,omitempty"`
}

// Unique identifier for this Account
type AccountId = Id

type CreateAccountResponseResult struct {
	Account *Account `json:"account,omitempty"`
}

type Audit struct {
	Environment string `json:"environment"`
	// Time when the API request occurred.
	CreatedAt     time.Time   `json:"created_at"`
	Method        HttpMethod  `json:"method,omitempty"`
	Path          string      `json:"path"`
	Code          string      `json:"code"`
	Status        string      `json:"status"`
	Body          interface{} `json:"body,omitempty"`
	IntegrationId *Id         `json:"integration_id,omitempty"`
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodDelete HttpMethod = "DELETE"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "DELETE":
		return HttpMethodDelete, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

// Provides details on an available Integration.
type Category struct {
	Category CategoryId `json:"category"`
	// Description of what this Integration does.
	Description string `json:"description"`
	// List of Providers that implement this Integration.
	Providers []ProviderId `json:"providers,omitempty"`
	// URL of the icon representing this type of Integration.
	ImageRef *string `json:"image_ref,omitempty"`
}

// Id of the Integrations category
type CategoryId = string

type Provider struct {
	Id ProviderId `json:"id"`
	// Name of the Provider.
	Name string `json:"name"`
	// Description of what this Provider does.
	Description string `json:"description"`
	// Categories that this Provider implements.
	Categories []CategoryId `json:"categories,omitempty"`
	// URL of the icon representing this type of Provider.
	ImageRef *string `json:"image_ref,omitempty"`
	// Operations that this Provider implements.
	SupportedOperations interface{} `json:"supported_operations,omitempty"`
}

type ProviderId = string

type Base struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
}

type ErrorBody struct {
	Status     int           `json:"status"`
	Message    *string       `json:"message,omitempty"`
	Errors     []string      `json:"errors,omitempty"`
	Parameters []*ErrorParam `json:"parameters,omitempty"`
}

type ErrorParam struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type Id = string

type AwsCredential struct {
	AccessKeyId     string  `json:"access_key_id"`
	SecretAccessKey string  `json:"secret_access_key"`
	Session         *string `json:"session,omitempty"`
}

type BasicCredential struct {
	// Username value for authentication
	Username string `json:"username"`
	// Secret value for authentication
	Secret string `json:"secret"`
}

// Credential to access an integration. Each credential is managed by an Account.
type Credential struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at"`
	Id        CredentialId `json:"id,omitempty"`
	// Account that manages this credential.
	AccountId AccountId        `json:"account_id,omitempty"`
	Type      CredentialType   `json:"type,omitempty"`
	Aws       *AwsCredential   `json:"aws,omitempty"`
	Token     *TokenCredential `json:"token,omitempty"`
	Basic     *BasicCredential `json:"basic,omitempty"`
}

type CredentialType string

const (
	CredentialTypeAws   CredentialType = "aws"
	CredentialTypeToken CredentialType = "token"
	CredentialTypeBasic CredentialType = "basic"
)

func NewCredentialTypeFromString(s string) (CredentialType, error) {
	switch s {
	case "aws":
		return CredentialTypeAws, nil
	case "token":
		return CredentialTypeToken, nil
	case "basic":
		return CredentialTypeBasic, nil
	}
	var t CredentialType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialType) Ptr() *CredentialType {
	return &c
}

type TokenCredential struct {
	// Secret Token value used for authentication with an external service.
	Secret string `json:"secret"`
}

type AwsConfig struct {
	// Override the default AWS region for this integration. If not present, the region will be infered from the URL.
	Region *string `json:"region,omitempty"`
}

type AzureConfig struct {
	// Azure Client (Application) ID.
	ClientId string `json:"client_id"`
	// Azure Directory (tenant) ID.
	TenantId string `json:"tenant_id"`
	// Data Collection Rule immutable ID.
	RuleId string `json:"rule_id"`
	// Name of the Data Collection Rule stream.
	StreamName string `json:"stream_name"`
}

type CreateIntegrationResponseResult struct {
	Integration    *Integration `json:"integration,omitempty"`
	RefreshTokenId TokenId      `json:"refresh_token_id,omitempty"`
	Token          *TokenPair   `json:"token,omitempty"`
}

type EventConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// URL used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider
	Url *string `json:"url,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId            `json:"transforms,omitempty"`
	Config     *EventProviderTypeConfig `json:"config,omitempty"`
}

type EventProviderTypeConfig struct {
	Type             string
	AzureMonitorLogs *AzureConfig
	Aws              *AwsConfig
	Splunk           *SplunkConfig
}

func NewEventProviderTypeConfigFromAzureMonitorLogs(value *AzureConfig) *EventProviderTypeConfig {
	return &EventProviderTypeConfig{Type: "azure_monitor_logs", AzureMonitorLogs: value}
}

func NewEventProviderTypeConfigFromAws(value *AwsConfig) *EventProviderTypeConfig {
	return &EventProviderTypeConfig{Type: "aws", Aws: value}
}

func NewEventProviderTypeConfigFromSplunk(value *SplunkConfig) *EventProviderTypeConfig {
	return &EventProviderTypeConfig{Type: "splunk", Splunk: value}
}

func (e *EventProviderTypeConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "azure_monitor_logs":
		value := new(AzureConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AzureMonitorLogs = value
	case "aws":
		value := new(AwsConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Aws = value
	case "splunk":
		value := new(SplunkConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Splunk = value
	}
	return nil
}

func (e EventProviderTypeConfig) MarshalJSON() ([]byte, error) {
	switch e.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "azure_monitor_logs":
		var marshaler = struct {
			Type string `json:"type"`
			*AzureConfig
		}{
			Type:        e.Type,
			AzureConfig: e.AzureMonitorLogs,
		}
		return json.Marshal(marshaler)
	case "aws":
		var marshaler = struct {
			Type string `json:"type"`
			*AwsConfig
		}{
			Type:      e.Type,
			AwsConfig: e.Aws,
		}
		return json.Marshal(marshaler)
	case "splunk":
		var marshaler = struct {
			Type string `json:"type"`
			*SplunkConfig
		}{
			Type:         e.Type,
			SplunkConfig: e.Splunk,
		}
		return json.Marshal(marshaler)
	}
}

type EventProviderTypeConfigVisitor interface {
	VisitAzureMonitorLogs(*AzureConfig) error
	VisitAws(*AwsConfig) error
	VisitSplunk(*SplunkConfig) error
}

func (e *EventProviderTypeConfig) Accept(visitor EventProviderTypeConfigVisitor) error {
	switch e.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", e.Type, e)
	case "azure_monitor_logs":
		return visitor.VisitAzureMonitorLogs(e.AzureMonitorLogs)
	case "aws":
		return visitor.VisitAws(e.Aws)
	case "splunk":
		return visitor.VisitSplunk(e.Splunk)
	}
}

type HooksConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// Endpoint used for connecting to the external service.
	Endpoint *string `json:"endpoint,omitempty"`
	// Optional webhook filter specification
	Filter *string `json:"filter,omitempty"`
	// Events to hook or empty list for all events
	SourceEvents []string `json:"source_events,omitempty"`
	// Webhook verification secret
	SourceSecret *CredentialId `json:"source_secret,omitempty"`
	// Add optional webhook secure hash for verification
	TargetSecret *CredentialId `json:"target_secret,omitempty"`
	// Optional list of transformations used to modify the webhook responses.
	Transforms []TransformId `json:"transforms,omitempty"`
}

// Connects an Account to an external service
type Integration struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time     `json:"updated_at"`
	Id        IntegrationId `json:"id,omitempty"`
	// Account that manages this Integration.
	AccountId AccountId `json:"account_id,omitempty"`
	// Id of the categorical type for this Integration.
	Category CategoryId `json:"category"`
	// Token used to interact with this Integration.
	TokenId TokenId `json:"token_id,omitempty"`
	// Provider implementation to use for this Integration.
	ProviderType ProviderId `json:"provider_type"`
	// Custom configuration for the Provider.
	ProviderConfig *ProviderConfig `json:"provider_config,omitempty"`
}

type NotificationConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty"`
	// Channel specification
	Channel *string `json:"channel,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty"`
}

type ProviderConfig struct {
	Type            string
	Events          *EventConfig
	Hooks           *HooksConfig
	Notifications   *NotificationConfig
	Storage         *StorageConfig
	Tickets         *TicketConfig
	Vulnerabilities *VulnerabilityConfig
}

func NewProviderConfigFromEvents(value *EventConfig) *ProviderConfig {
	return &ProviderConfig{Type: "events", Events: value}
}

func NewProviderConfigFromHooks(value *HooksConfig) *ProviderConfig {
	return &ProviderConfig{Type: "hooks", Hooks: value}
}

func NewProviderConfigFromNotifications(value *NotificationConfig) *ProviderConfig {
	return &ProviderConfig{Type: "notifications", Notifications: value}
}

func NewProviderConfigFromStorage(value *StorageConfig) *ProviderConfig {
	return &ProviderConfig{Type: "storage", Storage: value}
}

func NewProviderConfigFromTickets(value *TicketConfig) *ProviderConfig {
	return &ProviderConfig{Type: "tickets", Tickets: value}
}

func NewProviderConfigFromVulnerabilities(value *VulnerabilityConfig) *ProviderConfig {
	return &ProviderConfig{Type: "vulnerabilities", Vulnerabilities: value}
}

func (p *ProviderConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "events":
		value := new(EventConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Events = value
	case "hooks":
		value := new(HooksConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Hooks = value
	case "notifications":
		value := new(NotificationConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Notifications = value
	case "storage":
		value := new(StorageConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Storage = value
	case "tickets":
		value := new(TicketConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Tickets = value
	case "vulnerabilities":
		value := new(VulnerabilityConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Vulnerabilities = value
	}
	return nil
}

func (p ProviderConfig) MarshalJSON() ([]byte, error) {
	switch p.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "events":
		var marshaler = struct {
			Type string `json:"type"`
			*EventConfig
		}{
			Type:        p.Type,
			EventConfig: p.Events,
		}
		return json.Marshal(marshaler)
	case "hooks":
		var marshaler = struct {
			Type string `json:"type"`
			*HooksConfig
		}{
			Type:        p.Type,
			HooksConfig: p.Hooks,
		}
		return json.Marshal(marshaler)
	case "notifications":
		var marshaler = struct {
			Type string `json:"type"`
			*NotificationConfig
		}{
			Type:               p.Type,
			NotificationConfig: p.Notifications,
		}
		return json.Marshal(marshaler)
	case "storage":
		var marshaler = struct {
			Type string `json:"type"`
			*StorageConfig
		}{
			Type:          p.Type,
			StorageConfig: p.Storage,
		}
		return json.Marshal(marshaler)
	case "tickets":
		var marshaler = struct {
			Type string `json:"type"`
			*TicketConfig
		}{
			Type:         p.Type,
			TicketConfig: p.Tickets,
		}
		return json.Marshal(marshaler)
	case "vulnerabilities":
		var marshaler = struct {
			Type string `json:"type"`
			*VulnerabilityConfig
		}{
			Type:                p.Type,
			VulnerabilityConfig: p.Vulnerabilities,
		}
		return json.Marshal(marshaler)
	}
}

type ProviderConfigVisitor interface {
	VisitEvents(*EventConfig) error
	VisitHooks(*HooksConfig) error
	VisitNotifications(*NotificationConfig) error
	VisitStorage(*StorageConfig) error
	VisitTickets(*TicketConfig) error
	VisitVulnerabilities(*VulnerabilityConfig) error
}

func (p *ProviderConfig) Accept(visitor ProviderConfigVisitor) error {
	switch p.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", p.Type, p)
	case "events":
		return visitor.VisitEvents(p.Events)
	case "hooks":
		return visitor.VisitHooks(p.Hooks)
	case "notifications":
		return visitor.VisitNotifications(p.Notifications)
	case "storage":
		return visitor.VisitStorage(p.Storage)
	case "tickets":
		return visitor.VisitTickets(p.Tickets)
	case "vulnerabilities":
		return visitor.VisitVulnerabilities(p.Vulnerabilities)
	}
}

type SplunkConfig struct {
	// If true, skips verification of the Splunk server's TLS certificate. Defaults to false.
	SkipTlsVerify bool `json:"skip_tls_verify"`
	// Splunk index to send events to. If not provided, will use the default index for the Splunk collector.
	Index *string `json:"index,omitempty"`
	// Splunk source to send events to. If not provided, will use the default source for the Splunk collector.
	Source *string `json:"source,omitempty"`
	// Splunk source type to send events to. If not provided, will use the default source type for the Splunk collector.
	SourceType *string `json:"source_type,omitempty"`
}

type StorageConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	Bucket       string       `json:"bucket"`
	Region       string       `json:"region"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty"`
}

type TicketConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty"`
}

type VulnerabilityConfig struct {
	CredentialId CredentialId `json:"credential_id,omitempty"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty"`
}

type CreateMemberResponseResult struct {
	Member *Member `json:"member,omitempty"`
}

type Member struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
	Id        MemberId  `json:"id,omitempty"`
	State     State     `json:"state,omitempty"`
	// User's full name
	Fullname string `json:"fullname"`
	// User's nickname
	Nickname string `json:"nickname"`
	// Url of user's picture
	Picture  string    `json:"picture"`
	Ttl      string    `json:"ttl"`
	TokenTtl string    `json:"token_ttl"`
	Expires  time.Time `json:"expires"`
	// Roles granted to this member. Tokens inherit this access.
	Roles []*Role `json:"roles,omitempty"`
}

type MemberOptions struct {
	// Optional member time-to-live duration. After a member expires, system requires a change password to re-enable member. Minimum 1 day, Maximum 1 year, Default 180 days.
	Ttl string `json:"ttl"`
	// Options: "expired" will force change password on first logon.
	Options []Options `json:"options,omitempty"`
	// Optional token time-to-live duration. Tokens are created for this member with this duration as their TTL. Minimum 10 miniutes, Maximum 1 week, Defaults 1 hour.
	TokenTtl string `json:"token_ttl"`
}

type Options string

const (
	OptionsDisabled  Options = "disabled"
	OptionsExpired   Options = "expired"
	OptionsForgotten Options = "forgotten"
	OptionsInvited   Options = "invited"
	OptionsLocked    Options = "locked"
)

func NewOptionsFromString(s string) (Options, error) {
	switch s {
	case "disabled":
		return OptionsDisabled, nil
	case "expired":
		return OptionsExpired, nil
	case "forgotten":
		return OptionsForgotten, nil
	case "invited":
		return OptionsInvited, nil
	case "locked":
		return OptionsLocked, nil
	}
	var t Options
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Options) Ptr() *Options {
	return &o
}

type State string

const (
	StateDisabled  State = "disabled"
	StateEnabled   State = "enabled"
	StateForgotten State = "forgotten"
	StateInvited   State = "invited"
	StateLocked    State = "locked"
)

func NewStateFromString(s string) (State, error) {
	switch s {
	case "disabled":
		return StateDisabled, nil
	case "enabled":
		return StateEnabled, nil
	case "forgotten":
		return StateForgotten, nil
	case "invited":
		return StateInvited, nil
	case "locked":
		return StateLocked, nil
	}
	var t State
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s State) Ptr() *State {
	return &s
}

// Type of action granted access by an API operation: "create", "read", "update", "delete", or "*".
type Action = string

// APIs disallowed access to by prefix endpoint match. Can be used to block access to select APIs like /v1/users, /v1/tokens, and /v1/credentials.
type BlockedApi = string

// Contained objects granted access to by Id or "*".
type Object = Id

type Permission struct {
	// List of access roles. Authorization tries each role sequentially until one access role passes or they all fail
	Roles []*Role `json:"roles,omitempty"`
	// ID of the resource that this permission grants access to.
	ResourceId string `json:"resource_id"`
	// Type of the resource that this permission grants access to. Must be one of the following: "organization, "integration"
	ResourceType string `json:"resource_type"`
	// Token parentId
	ParentId string `json:"parent_id"`
}

type Role struct {
	// List of actions that this permission grants access to: "create", "read", "update", "delete" and "*". Use "*" to give all action permissions.
	Actions []Action `json:"actions,omitempty"`
	// List of contained objects ids that this permission grants access to. Use "*" to grant access to all contained objects.
	Objects []Object `json:"objects,omitempty"`
	// Optional list of APIs that this role blocks access to. Can be used to block access to select APIs like /v1/user, v1/tokens and /v1/credentials
	BlockedApis []BlockedApi `json:"blocked_apis,omitempty"`
}

type Token struct {
	// Secret value for the token; used for authentication when making requests.
	Secret string `json:"secret"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires"`
	// Permissions granted to this token.
	Permissions *Permission `json:"permissions,omitempty"`
}

type TokenPair struct {
	// Access token contains the bearer secret
	Access *Token `json:"access,omitempty"`
	// Refresh token used for RefreshToken API
	Refresh *Token `json:"refresh,omitempty"`
}

type RefreshToken struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at"`
	Id        TokenId   `json:"id,omitempty"`
	// Primary running access and refresh tokens
	Primary *TokenPair `json:"primary,omitempty"`
	// Temporary secondary TokenPair created after a RefreshToken operation
	Secondary *TokenPair `json:"secondary,omitempty"`
}

// Transforms data collected before it is sent to the target Integration.
type Transform struct {
	// Human-readable name for this resource
	Name string `json:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time   `json:"updated_at"`
	Id        TransformId `json:"id,omitempty"`
	// Account that manages this Transform.
	AccountId AccountId `json:"account_id,omitempty"`
	// JSON Patch transform to apply (rfc6902).
	Patch []byte `json:"patch"`
}

type Usage struct {
	IntegrationId     Id      `json:"integration_id"`
	RequestsCount     float64 `json:"requests_count"`
	CpuTimeSeconds    float64 `json:"cpu_time_seconds"`
	DbOperationsCount float64 `json:"db_operations_count"`
	IntOpsCount       float64 `json:"int_ops_count"`
}
