// This file was auto-generated by Fern from our API Definition.

package management

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/synqly/go-sdk/client/management/core"
	time "time"
)

// Unique identifier for this Account
type AccountId = Id

type Account struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        AccountId `json:"id" url:"id"`
	// Human friendly display name for this account.
	Fullname string `json:"fullname" url:"fullname"`
	// Organization that manages this Account.
	OrganizationId OrganizationId `json:"organization_id" url:"organization_id"`
	// Environment this account runs in.
	Environment Environment `json:"environment" url:"environment"`
	// User defined labels that apply to this account. These values can be used in role bindings to limit the scope of permissions.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type embed Account
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Account(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Account) MarshalJSON() ([]byte, error) {
	type embed Account
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Account) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type CreateAccountResponseResult struct {
	Account *Account `json:"account" url:"account"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAccountResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAccountResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAccountResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAccountResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateAccountResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Audit struct {
	Environment string `json:"environment" url:"environment"`
	// Time when the API request occurred.
	CreatedAt     time.Time      `json:"created_at" url:"created_at"`
	RemoteAddr    string         `json:"remote_addr" url:"remote_addr"`
	UserAgent     string         `json:"user_agent" url:"user_agent"`
	AuditType     AuditType      `json:"audit_type" url:"audit_type"`
	Method        HttpMethod     `json:"method" url:"method"`
	Path          string         `json:"path" url:"path"`
	Code          string         `json:"code" url:"code"`
	Body          interface{}    `json:"body,omitempty" url:"body,omitempty"`
	Response      *string        `json:"response,omitempty" url:"response,omitempty"`
	Status        *string        `json:"status,omitempty" url:"status,omitempty"`
	MemberId      *MemberId      `json:"member_id,omitempty" url:"member_id,omitempty"`
	AccountId     *AccountId     `json:"account_id,omitempty" url:"account_id,omitempty"`
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`
	BridgeGroupId *BridgeGroupId `json:"bridge_group_id,omitempty" url:"bridge_group_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Audit) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Audit) UnmarshalJSON(data []byte) error {
	type embed Audit
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Audit(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Audit) MarshalJSON() ([]byte, error) {
	type embed Audit
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Audit) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuditType string

const (
	AuditTypeAlarm   AuditType = "ALARM"
	AuditTypeError   AuditType = "ERROR"
	AuditTypeApi     AuditType = "API"
	AuditTypeUnknown AuditType = "UNKNOWN"
)

func NewAuditTypeFromString(s string) (AuditType, error) {
	switch s {
	case "ALARM":
		return AuditTypeAlarm, nil
	case "ERROR":
		return AuditTypeError, nil
	case "API":
		return AuditTypeApi, nil
	case "UNKNOWN":
		return AuditTypeUnknown, nil
	}
	var t AuditType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuditType) Ptr() *AuditType {
	return &a
}

type HttpMethod string

const (
	HttpMethodDelete HttpMethod = "DELETE"
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "DELETE":
		return HttpMethodDelete, nil
	case "GET":
		return HttpMethodGet, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type AuthCode string

const (
	AuthCodeSuccess  AuthCode = "success"
	AuthCodeFailure  AuthCode = "failure"
	AuthCodeDisabled AuthCode = "disabled"
	AuthCodeExpired  AuthCode = "expired"
	AuthCodeInvited  AuthCode = "invited"
	AuthCodeLocked   AuthCode = "locked"
)

func NewAuthCodeFromString(s string) (AuthCode, error) {
	switch s {
	case "success":
		return AuthCodeSuccess, nil
	case "failure":
		return AuthCodeFailure, nil
	case "disabled":
		return AuthCodeDisabled, nil
	case "expired":
		return AuthCodeExpired, nil
	case "invited":
		return AuthCodeInvited, nil
	case "locked":
		return AuthCodeLocked, nil
	}
	var t AuthCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthCode) Ptr() *AuthCode {
	return &a
}

type ChangePasswordResponseResult struct {
	// Authentication result
	AuthCode AuthCode `json:"auth_code" url:"auth_code"`
	// Authentication failure message
	AuthMsg *string `json:"auth_msg,omitempty" url:"auth_msg,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChangePasswordResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChangePasswordResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ChangePasswordResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChangePasswordResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *ChangePasswordResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type LogonResponseResult struct {
	// Authentication result
	AuthCode AuthCode `json:"auth_code" url:"auth_code"`
	// Authentication failure message
	AuthMsg        *string       `json:"auth_msg,omitempty" url:"auth_msg,omitempty"`
	RefreshTokenId TokenId       `json:"refresh_token_id" url:"refresh_token_id"`
	Token          *TokenPair    `json:"token" url:"token"`
	Organization   *Organization `json:"organization" url:"organization"`
	Member         *Member       `json:"member" url:"member"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LogonResponseResult) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogonResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler LogonResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogonResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *LogonResponseResult) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A Bridge Group represents a connection between the Synqly Saas or Embedded service and a Bridge Agent. See 'Synqly Bridge Agent' guide in Synqly docs for additional information.
type BridgeGroup struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time     `json:"updated_at" url:"updated_at"`
	Id        BridgeGroupId `json:"id" url:"id"`
	// Full name of bridge
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the resources included in the bridge and permissions granted on those resources. Includes details of when to use this bridge along with the intended personas.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Labels applied to Bridges within the group. These labels can be used by integrations to select the groups of bridges capable of handling requests to the integration.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeGroup) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeGroup) UnmarshalJSON(data []byte) error {
	type embed BridgeGroup
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BridgeGroup(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeGroup) MarshalJSON() ([]byte, error) {
	type embed BridgeGroup
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BridgeGroup) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgeLocalConfig struct {
	// Version of the Bridge.
	Version string `json:"version" url:"version"`
	// List of IP addresses that the Bridge is allowed to connect to.
	AllowAddresses []string `json:"allow_addresses" url:"allow_addresses"`
	// Vault configuration for the Bridge.
	Vault map[string]string `json:"vault,omitempty" url:"vault,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeLocalConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeLocalConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeLocalConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeLocalConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeLocalConfig) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgeLocalStats struct {
	Requests int64 `json:"requests" url:"requests"`
	Failures int64 `json:"failures" url:"failures"`
	InBytes  int64 `json:"in_bytes" url:"in_bytes"`
	OutBytes int64 `json:"out_bytes" url:"out_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeLocalStats) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeLocalStats) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeLocalStats
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeLocalStats(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeLocalStats) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgeStatus struct {
	// Local time on the Bridge when the status check was performed.
	CurrentTime time.Time `json:"current_time" url:"current_time"`
	// Round trip time for the status check.
	ResponseDuration string `json:"response_duration" url:"response_duration"`
	// Local configuration parameters for the Bridge.
	LocalConfig *BridgeLocalConfig `json:"local_config" url:"local_config"`
	// Local bridge statistics
	LocalStats *BridgeLocalStats `json:"local_stats" url:"local_stats"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeStatus) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeStatus) UnmarshalJSON(data []byte) error {
	type embed BridgeStatus
	var unmarshaler = struct {
		embed
		CurrentTime *core.DateTime `json:"current_time"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BridgeStatus(unmarshaler.embed)
	b.CurrentTime = unmarshaler.CurrentTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeStatus) MarshalJSON() ([]byte, error) {
	type embed BridgeStatus
	var marshaler = struct {
		embed
		CurrentTime *core.DateTime `json:"current_time"`
	}{
		embed:       embed(*b),
		CurrentTime: core.NewDateTime(b.CurrentTime),
	}
	return json.Marshal(marshaler)
}

func (b *BridgeStatus) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CreateBridgeResponseResult struct {
	Bridge *BridgeGroup `json:"bridge" url:"bridge"`
	// JWT for the Bridge Group to connect to Synqly. This must be saved in a file {bridgeId}.creds in the same directory as the bridge executable.
	Credential string `json:"credential" url:"credential"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateBridgeResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBridgeResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBridgeResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBridgeResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateBridgeResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Provides details of the Connector.
type Connector struct {
	// Unique identifier for the Connector.
	Id CategoryId `json:"id" url:"id"`
	// Name of the connector.
	Name CategoryId `json:"name" url:"name"`
	// Display name of the Connector.
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the Connector.
	Description string `json:"description" url:"description"`
	// List of Providers that implement the Connector.
	ProviderIds []ProviderId `json:"provider_ids" url:"provider_ids"`
	// List of capabilities for Providers that implement the Connector.
	Providers []*ProviderCapabilities `json:"providers,omitempty" url:"providers,omitempty"`
	// DEPRECATED – use `id` instead.
	Connector *CategoryId `json:"connector,omitempty" url:"connector,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Connector) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Connector) UnmarshalJSON(data []byte) error {
	type unmarshaler Connector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Connector(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Connector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectorOrId struct {
	CategoryId CategoryId
	Connector  *Connector
}

func (c *ConnectorOrId) UnmarshalJSON(data []byte) error {
	var valueCategoryId CategoryId
	if err := json.Unmarshal(data, &valueCategoryId); err == nil {
		c.CategoryId = valueCategoryId
		return nil
	}
	valueConnector := new(Connector)
	if err := json.Unmarshal(data, &valueConnector); err == nil {
		c.Connector = valueConnector
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConnectorOrId) MarshalJSON() ([]byte, error) {
	if c.CategoryId != "" {
		return json.Marshal(c.CategoryId)
	}
	if c.Connector != nil {
		return json.Marshal(c.Connector)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ConnectorOrIdVisitor interface {
	VisitCategoryId(CategoryId) error
	VisitConnector(*Connector) error
}

func (c *ConnectorOrId) Accept(visitor ConnectorOrIdVisitor) error {
	if c.CategoryId != "" {
		return visitor.VisitCategoryId(c.CategoryId)
	}
	if c.Connector != nil {
		return visitor.VisitConnector(c.Connector)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type FilterOperation string

const (
	// Filter for exact matches.
	FilterOperationEquals FilterOperation = "eq"
	// Filter for non-matches.
	FilterOperationNotEquals FilterOperation = "neq"
	// Filter for values greater than the provided value.
	FilterOperationGreaterThan FilterOperation = "gt"
	// Filter for values less than the provided value.
	FilterOperationLessThan FilterOperation = "lt"
	// Filter for values greater than or equal to the provided value.
	FilterOperationGreaterThanOrEquals FilterOperation = "gte"
	// Filter for values less than or equal to the provided value.
	FilterOperationLessThanOrEquals FilterOperation = "lte"
	// Filter to match values in the provided comma-separated list.
	FilterOperationIn FilterOperation = "in"
	// Filter to match values that contain the provided value.
	FilterOperationLike FilterOperation = "like"
	// Filter to match values not in the provided comma-separated list.
	FilterOperationNotIn FilterOperation = "not in"
	// Filter to match values that do not contain the provided value.
	FilterOperationNotLike FilterOperation = "not like"
)

func NewFilterOperationFromString(s string) (FilterOperation, error) {
	switch s {
	case "eq":
		return FilterOperationEquals, nil
	case "neq":
		return FilterOperationNotEquals, nil
	case "gt":
		return FilterOperationGreaterThan, nil
	case "lt":
		return FilterOperationLessThan, nil
	case "gte":
		return FilterOperationGreaterThanOrEquals, nil
	case "lte":
		return FilterOperationLessThanOrEquals, nil
	case "in":
		return FilterOperationIn, nil
	case "like":
		return FilterOperationLike, nil
	case "not in":
		return FilterOperationNotIn, nil
	case "not like":
		return FilterOperationNotLike, nil
	}
	var t FilterOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterOperation) Ptr() *FilterOperation {
	return &f
}

type FilterType string

const (
	FilterTypeString   FilterType = "string"
	FilterTypeDatetime FilterType = "datetime"
	FilterTypeEnum     FilterType = "enum"
	FilterTypeBoolean  FilterType = "boolean"
	FilterTypeNumber   FilterType = "number"
)

func NewFilterTypeFromString(s string) (FilterType, error) {
	switch s {
	case "string":
		return FilterTypeString, nil
	case "datetime":
		return FilterTypeDatetime, nil
	case "enum":
		return FilterTypeEnum, nil
	case "boolean":
		return FilterTypeBoolean, nil
	case "number":
		return FilterTypeNumber, nil
	}
	var t FilterType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterType) Ptr() *FilterType {
	return &f
}

type ProviderAvailability string

const (
	// Currently in active development.
	ProviderAvailabilityInDevelopment ProviderAvailability = "in-development"
	// Available for use, but not ready for production.
	ProviderAvailabilityPreRelease ProviderAvailability = "pre-release"
	// Will be removed in the future.
	ProviderAvailabilityDeprecated ProviderAvailability = "deprecated"
	// Stable and available for production use.
	ProviderAvailabilityGenerallyAvailable ProviderAvailability = "generally-available"
)

func NewProviderAvailabilityFromString(s string) (ProviderAvailability, error) {
	switch s {
	case "in-development":
		return ProviderAvailabilityInDevelopment, nil
	case "pre-release":
		return ProviderAvailabilityPreRelease, nil
	case "deprecated":
		return ProviderAvailabilityDeprecated, nil
	case "generally-available":
		return ProviderAvailabilityGenerallyAvailable, nil
	}
	var t ProviderAvailability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderAvailability) Ptr() *ProviderAvailability {
	return &p
}

type ProviderCapabilities struct {
	// Unique identifier for the Provider.
	Id ProviderId `json:"id" url:"id"`
	// Name of the Provider.
	Name string `json:"name" url:"name"`
	// Display name of the Provider.
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the Provider.
	Description string `json:"description" url:"description"`
	// Id of the Connector that the Provider implements.
	ConnectorId CategoryId `json:"connector_id" url:"connector_id"`
	// Id of the Connector that the Provider implements – or, if
	// `expand=connector` is set – the details of the Connector. NOTE:
	// The current default behavior is to return the ID of the
	// Connector. This field will soon only be populated when
	// `expand=connector` is set in the APIs that support it. It is
	// recommended you use `connector_id` for a stable reference to the
	// Connector ID. This field will soon only be populated when
	// `expand=connector` is set in the APIs that support it.
	Connector *ConnectorOrId `json:"connector,omitempty" url:"connector,omitempty"`
	// Operations that the Provider implements.
	Operations []*ProviderOperations `json:"operations,omitempty" url:"operations,omitempty"`
	// Details on the specific configuration options for the Provider.
	ProviderConfig interface{} `json:"provider_config,omitempty" url:"provider_config,omitempty"`
	// Provider availability inforamtion.
	Release *ProviderRelease `json:"release,omitempty" url:"release,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderCapabilities) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderCapabilities) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderCapabilities
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderCapabilities(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProviderCapabilities) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderEnvironment string

const (
	// Provider may be used with production accounts.
	ProviderEnvironmentProduction ProviderEnvironment = "prod"
	// Provider may be used with test accounts.
	ProviderEnvironmentTest ProviderEnvironment = "test"
)

func NewProviderEnvironmentFromString(s string) (ProviderEnvironment, error) {
	switch s {
	case "prod":
		return ProviderEnvironmentProduction, nil
	case "test":
		return ProviderEnvironmentTest, nil
	}
	var t ProviderEnvironment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderEnvironment) Ptr() *ProviderEnvironment {
	return &p
}

type ProviderFilter struct {
	// Name of the filter.
	Name string `json:"name" url:"name"`
	// Type of the value that this filter can apply to
	Type FilterType `json:"type" url:"type"`
	// List of operators that this filter supports.
	Operators []string `json:"operators" url:"operators"`
	// List of possible values for this filter.
	Values []string `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderFilter) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProviderFilter) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderOperations struct {
	// Unique identifier for the operation.
	Id string `json:"id" url:"id"`
	// Name of the operation.
	Name string `json:"name" url:"name"`
	// Display name of the operation.
	Fullname *string `json:"fullname,omitempty" url:"fullname,omitempty"`
	// Description of the operation.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// HTTP method used for the operation.
	RequestMethod *string `json:"request_method,omitempty" url:"request_method,omitempty"`
	// URI template path for the operation, including path parameters.
	RequestPath *string `json:"request_path,omitempty" url:"request_path,omitempty"`
	// Whether the operation is supported by the provider.
	Supported bool `json:"supported" url:"supported"`
	// List of fields in the request body that are required by the
	// provider for this operation. Due to limitations of the OpenAPI
	// format these fields may be marked as optional, even though they
	// are in fact required by this provider.
	RequiredFields []string `json:"required_fields,omitempty" url:"required_fields,omitempty"`
	// List of fields that may be returned in the response body. Any
	// fields not listed in this array are not supported by this
	// provider and will not be returned in the response body.
	SupportedResponseFields []string `json:"supported_response_fields,omitempty" url:"supported_response_fields,omitempty"`
	// Filters that can be applied to this operation.
	Filters []*ProviderFilter `json:"filters,omitempty" url:"filters,omitempty"`
	// This field is only available if the operation supports a request
	// body. Describes the request body and its schema.
	RequestBody *RequestBody `json:"request_body,omitempty" url:"request_body,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderOperations) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderOperations) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderOperations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderOperations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProviderOperations) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderRelease struct {
	// Availability status.
	Availability ProviderAvailability `json:"availability" url:"availability"`
	// Environments the Provider is available to.
	Environments []ProviderEnvironment `json:"environments" url:"environments"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderRelease) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderRelease) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderRelease
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderRelease(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProviderRelease) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Describes the request body and its schema.
type RequestBody struct {
	// If true the request body is required, false otherwise.
	Required bool `json:"required" url:"required"`
	// The schema defining the type used for the request body. If
	// expanded will be a full JSON schema of the entire request body,
	// otherwise this will be a reference object. The reference object
	// has a single key `$ref`, which is a URI [RFC3986] identifying the
	// location of a component within the Engine OpenAPI specification.
	Schema map[string]interface{} `json:"schema" url:"schema"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RequestBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler RequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RequestBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RequestBody) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Id of the Integrations category
type CategoryId string

const (
	CategoryIdAssets          CategoryId = "assets"
	CategoryIdCloudsecurity   CategoryId = "cloudsecurity"
	CategoryIdEdr             CategoryId = "edr"
	CategoryIdIdentity        CategoryId = "identity"
	CategoryIdNotifications   CategoryId = "notifications"
	CategoryIdSiem            CategoryId = "siem"
	CategoryIdSink            CategoryId = "sink"
	CategoryIdStorage         CategoryId = "storage"
	CategoryIdTicketing       CategoryId = "ticketing"
	CategoryIdVulnerabilities CategoryId = "vulnerabilities"
)

func NewCategoryIdFromString(s string) (CategoryId, error) {
	switch s {
	case "assets":
		return CategoryIdAssets, nil
	case "cloudsecurity":
		return CategoryIdCloudsecurity, nil
	case "edr":
		return CategoryIdEdr, nil
	case "identity":
		return CategoryIdIdentity, nil
	case "notifications":
		return CategoryIdNotifications, nil
	case "siem":
		return CategoryIdSiem, nil
	case "sink":
		return CategoryIdSink, nil
	case "storage":
		return CategoryIdStorage, nil
	case "ticketing":
		return CategoryIdTicketing, nil
	case "vulnerabilities":
		return CategoryIdVulnerabilities, nil
	}
	var t CategoryId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryId) Ptr() *CategoryId {
	return &c
}

type ProviderId = string

type ActionId string

const (
	ActionIdQuery  ActionId = "query"
	ActionIdRead   ActionId = "read"
	ActionIdCreate ActionId = "create"
	ActionIdUpdate ActionId = "update"
	ActionIdDelete ActionId = "delete"
	ActionIdPatch  ActionId = "patch"
)

func NewActionIdFromString(s string) (ActionId, error) {
	switch s {
	case "query":
		return ActionIdQuery, nil
	case "read":
		return ActionIdRead, nil
	case "create":
		return ActionIdCreate, nil
	case "update":
		return ActionIdUpdate, nil
	case "delete":
		return ActionIdDelete, nil
	case "patch":
		return ActionIdPatch, nil
	}
	var t ActionId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionId) Ptr() *ActionId {
	return &a
}

type Base struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Base) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Base) UnmarshalJSON(data []byte) error {
	type embed Base
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Base(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *Base) MarshalJSON() ([]byte, error) {
	type embed Base
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *Base) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Id = string

type ParameterLocation string

const (
	ParameterLocationHeader ParameterLocation = "header"
	ParameterLocationPath   ParameterLocation = "path"
	ParameterLocationQuery  ParameterLocation = "query"
	ParameterLocationBody   ParameterLocation = "body"
)

func NewParameterLocationFromString(s string) (ParameterLocation, error) {
	switch s {
	case "header":
		return ParameterLocationHeader, nil
	case "path":
		return ParameterLocationPath, nil
	case "query":
		return ParameterLocationQuery, nil
	case "body":
		return ParameterLocationBody, nil
	}
	var t ParameterLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ParameterLocation) Ptr() *ParameterLocation {
	return &p
}

type PatchOp string

const (
	PatchOpAdd     PatchOp = "add"
	PatchOpCopy    PatchOp = "copy"
	PatchOpMove    PatchOp = "move"
	PatchOpRemove  PatchOp = "remove"
	PatchOpReplace PatchOp = "replace"
	PatchOpTest    PatchOp = "test"
)

func NewPatchOpFromString(s string) (PatchOp, error) {
	switch s {
	case "add":
		return PatchOpAdd, nil
	case "copy":
		return PatchOpCopy, nil
	case "move":
		return PatchOpMove, nil
	case "remove":
		return PatchOpRemove, nil
	case "replace":
		return PatchOpReplace, nil
	case "test":
		return PatchOpTest, nil
	}
	var t PatchOp
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PatchOp) Ptr() *PatchOp {
	return &p
}

// JSON patch to apply. A JSON patch is a list of patch operations. (see https://jsonpatch.com/)
type PatchOperation struct {
	// The operation to perform. Supported values are `add`, `copy`, `move`, `replace`, `remove`, and `test`.
	Op PatchOp `json:"op" url:"op"`
	// The path to the field to update. The path is a JSON Pointer.
	Path string `json:"path" url:"path"`
	// The path to the field to copy from. This is required for `copy` and `move` operations.
	From *string `json:"from,omitempty" url:"from,omitempty"`
	// The value to set the field to. This is required for `add`, `replace` and `test` operations.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PatchOperation) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchOperation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *PatchOperation) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Generic base type for problems in Synqly. This object carries both machine-readable data as well as information intended for display purposes.
type Problem struct {
	// A short, display-friendly summary of the problem.
	Message string `json:"message" url:"message"`
	// A display-friendly and more detailed explanation of the problem. It may offer additional contextual detail, but may also be just a generic description of the problem.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// A display-friendly explanation for how to remediate the problem. This field may be omitted in case there are multiple problems, each with its own remediation, or if no remediation is possible.
	Remediation *string `json:"remediation,omitempty" url:"remediation,omitempty"`
	// Additional context providing further detail about the problem, such as a problematic input parameter and/or a list of related resources.
	Context *ProblemContext `json:"context,omitempty" url:"context,omitempty"`
	Type    *ProblemType    `json:"type,omitempty" url:"type,omitempty"`
	// The date and time the problem occurred.
	OccurredAt time.Time `json:"occurred_at" url:"occurred_at"`
	// The HTTP status code of the problem. Matches the HTTP response code sent by the server.
	Status int `json:"status" url:"status"`
	// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	Instance string `json:"instance" url:"instance"`
	// A list of the root cause(s) for this problem occurrence. Includes at minimum one root cause, and is otherwise an unordered list of causes.
	Cause []*ProblemCause `json:"cause,omitempty" url:"cause,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Problem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Problem) UnmarshalJSON(data []byte) error {
	type embed Problem
	var unmarshaler = struct {
		embed
		OccurredAt *core.DateTime `json:"occurred_at"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Problem(unmarshaler.embed)
	p.OccurredAt = unmarshaler.OccurredAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Problem) MarshalJSON() ([]byte, error) {
	type embed Problem
	var marshaler = struct {
		embed
		OccurredAt *core.DateTime `json:"occurred_at"`
	}{
		embed:      embed(*p),
		OccurredAt: core.NewDateTime(p.OccurredAt),
	}
	return json.Marshal(marshaler)
}

func (p *Problem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProblemCause struct {
	// A short, display-friendly summary of the problem.
	Message string `json:"message" url:"message"`
	// A display-friendly and more detailed explanation of the problem. It may offer additional contextual detail, but may also be just a generic description of the problem.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// A display-friendly explanation for how to remediate the problem. This field may be omitted in case there are multiple problems, each with its own remediation, or if no remediation is possible.
	Remediation *string `json:"remediation,omitempty" url:"remediation,omitempty"`
	// Additional context providing further detail about the problem, such as a problematic input parameter and/or a list of related resources.
	Context *ProblemContext `json:"context,omitempty" url:"context,omitempty"`
	Type    ProblemType     `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProblemCause) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProblemCause) UnmarshalJSON(data []byte) error {
	type unmarshaler ProblemCause
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProblemCause(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProblemCause) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProblemContext struct {
	// If the problem is related to a `query`, `header`, `path` or `body` parameter, this field will describe the problematic parameter and where to find it.
	Parameter *ProblematicParameter `json:"parameter,omitempty" url:"parameter,omitempty"`
	Resources []*ResourceReference  `json:"resources,omitempty" url:"resources,omitempty"`
	// If available this represents the underlying raw error, for example an error response from a Provider.
	RawError *string `json:"raw_error,omitempty" url:"raw_error,omitempty"`
	// If available this represents the underlying details from the provider. May include the error message, status code, and other details.
	ProviderDetails map[string]string `json:"provider_details,omitempty" url:"provider_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProblemContext) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProblemContext) UnmarshalJSON(data []byte) error {
	type unmarshaler ProblemContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProblemContext(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProblemContext) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProblemDetails struct {
	// A short, display-friendly summary of the problem.
	Message string `json:"message" url:"message"`
	// A display-friendly and more detailed explanation of the problem. It may offer additional contextual detail, but may also be just a generic description of the problem.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// A display-friendly explanation for how to remediate the problem. This field may be omitted in case there are multiple problems, each with its own remediation, or if no remediation is possible.
	Remediation *string `json:"remediation,omitempty" url:"remediation,omitempty"`
	// Additional context providing further detail about the problem, such as a problematic input parameter and/or a list of related resources.
	Context *ProblemContext `json:"context,omitempty" url:"context,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProblemDetails) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProblemDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ProblemDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProblemDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProblemDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProblemRelation string

const (
	ProblemRelationAffected ProblemRelation = "affected"
	ProblemRelationCause    ProblemRelation = "cause"
)

func NewProblemRelationFromString(s string) (ProblemRelation, error) {
	switch s {
	case "affected":
		return ProblemRelationAffected, nil
	case "cause":
		return ProblemRelationCause, nil
	}
	var t ProblemRelation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProblemRelation) Ptr() *ProblemRelation {
	return &p
}

// A URI reference that identifies the type of problem that occurred. When the URI scheme is HTTP(s), it may or may not be possible to deference the URL to a display-friendly description of the problem type.
type ProblemType = string

type ProblematicParameter struct {
	// If the `location` of the parameter is `body`, this value is always a JSON Pointer, otherwise it's the name of the parameter.
	Id string `json:"id" url:"id"`
	// The location of the parameter. Possible values are `query`, `header`, `path` or `body`.
	Location ParameterLocation `json:"location" url:"location"`
	// The given value of the parameter.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProblematicParameter) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProblematicParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler ProblematicParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProblematicParameter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProblematicParameter) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResourceId string

const (
	ResourceIdAlerts                 ResourceId = "alerts"
	ResourceIdApplications           ResourceId = "applications"
	ResourceIdAuditLogs              ResourceId = "audit_logs"
	ResourceIdComments               ResourceId = "comments"
	ResourceIdDevices                ResourceId = "devices"
	ResourceIdEvents                 ResourceId = "events"
	ResourceIdEvidence               ResourceId = "evidence"
	ResourceIdFindings               ResourceId = "findings"
	ResourceIdGroups                 ResourceId = "groups"
	ResourceIdInvestigations         ResourceId = "investigations"
	ResourceIdIocs                   ResourceId = "iocs"
	ResourceIdLogProviders           ResourceId = "log_providers"
	ResourceIdPostureScores          ResourceId = "posture_scores"
	ResourceIdProjects               ResourceId = "projects"
	ResourceIdScans                  ResourceId = "scans"
	ResourceIdScanActivities         ResourceId = "scan_activities"
	ResourceIdThreats                ResourceId = "threats"
	ResourceIdTickets                ResourceId = "tickets"
	ResourceIdUsers                  ResourceId = "users"
	ResourceIdCompliance             ResourceId = "compliance"
	ResourceIdCloudresourceinventory ResourceId = "cloudresourceinventory"
)

func NewResourceIdFromString(s string) (ResourceId, error) {
	switch s {
	case "alerts":
		return ResourceIdAlerts, nil
	case "applications":
		return ResourceIdApplications, nil
	case "audit_logs":
		return ResourceIdAuditLogs, nil
	case "comments":
		return ResourceIdComments, nil
	case "devices":
		return ResourceIdDevices, nil
	case "events":
		return ResourceIdEvents, nil
	case "evidence":
		return ResourceIdEvidence, nil
	case "findings":
		return ResourceIdFindings, nil
	case "groups":
		return ResourceIdGroups, nil
	case "investigations":
		return ResourceIdInvestigations, nil
	case "iocs":
		return ResourceIdIocs, nil
	case "log_providers":
		return ResourceIdLogProviders, nil
	case "posture_scores":
		return ResourceIdPostureScores, nil
	case "projects":
		return ResourceIdProjects, nil
	case "scans":
		return ResourceIdScans, nil
	case "scan_activities":
		return ResourceIdScanActivities, nil
	case "threats":
		return ResourceIdThreats, nil
	case "tickets":
		return ResourceIdTickets, nil
	case "users":
		return ResourceIdUsers, nil
	case "compliance":
		return ResourceIdCompliance, nil
	case "cloudresourceinventory":
		return ResourceIdCloudresourceinventory, nil
	}
	var t ResourceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResourceId) Ptr() *ResourceId {
	return &r
}

type ResourceReference struct {
	// Type of the related resource.
	Type ResourceType `json:"type" url:"type"`
	// ID of the related resource.
	Id string `json:"id" url:"id"`
	// The way in which the resource relates to the problem.
	Rel ProblemRelation `json:"rel" url:"rel"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResourceReference) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResourceReference) UnmarshalJSON(data []byte) error {
	type unmarshaler ResourceReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResourceReference(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *ResourceReference) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResourceType string

const (
	ResourceTypeAccount             ResourceType = "account"
	ResourceTypeBridge              ResourceType = "bridge"
	ResourceTypeCredential          ResourceType = "credential"
	ResourceTypeIntegrationPoint    ResourceType = "integration_point"
	ResourceTypeIntegration         ResourceType = "integration"
	ResourceTypeMember              ResourceType = "member"
	ResourceTypeOperation           ResourceType = "operation"
	ResourceTypeOrganizationWebhook ResourceType = "organization_webhook"
	ResourceTypeRole                ResourceType = "role"
	ResourceTypeSubOrg              ResourceType = "sub_org"
	ResourceTypeToken               ResourceType = "token"
	ResourceTypeTransform           ResourceType = "transform"
)

func NewResourceTypeFromString(s string) (ResourceType, error) {
	switch s {
	case "account":
		return ResourceTypeAccount, nil
	case "bridge":
		return ResourceTypeBridge, nil
	case "credential":
		return ResourceTypeCredential, nil
	case "integration_point":
		return ResourceTypeIntegrationPoint, nil
	case "integration":
		return ResourceTypeIntegration, nil
	case "member":
		return ResourceTypeMember, nil
	case "operation":
		return ResourceTypeOperation, nil
	case "organization_webhook":
		return ResourceTypeOrganizationWebhook, nil
	case "role":
		return ResourceTypeRole, nil
	case "sub_org":
		return ResourceTypeSubOrg, nil
	case "token":
		return ResourceTypeToken, nil
	case "transform":
		return ResourceTypeTransform, nil
	}
	var t ResourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResourceType) Ptr() *ResourceType {
	return &r
}

// Access key to authenticate with AWS. Access keys are long-term credentials for an IAM user and consist of an Access Key ID and a Secret Access Key. Follow [this guide to generate credentials](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html).
// You may optionally provide a session token if you are using temporary credentials.
type AwsCredential struct {
	// Access Key ID portion of the AWS access key pair.
	AccessKeyId string `json:"access_key_id" url:"access_key_id"`
	// Secret portion of the AWS access key pair.
	SecretAccessKey string `json:"secret_access_key" url:"secret_access_key"`
	// A temporary session token. Session tokens are optional and are only necessary if you are using temporary credentials.
	Session *string `json:"session,omitempty" url:"session,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AwsCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AwsCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler AwsCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AwsCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AwsCredential) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Unique identifier for an AWS Credential
type AwsCredentialId = CredentialId

// Username and secret used to authenticate with an external service.
type BasicCredential struct {
	// Username value for authentication
	Username string `json:"username" url:"username"`
	// Secret value for authentication
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BasicCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BasicCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Unique identifier for a Basic Credential
type BasicCredentialId = CredentialId

// Credential to access an integration. Each credential is owned by an Account, Integration, IntegrationPoint or OrganizationWebhook.
type Credential struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at" url:"updated_at"`
	Id        CredentialId `json:"id" url:"id"`
	// Account that manages this credential.
	AccountId *AccountId `json:"account_id,omitempty" url:"account_id,omitempty"`
	// Integration associated with this credential.
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`
	// Integration Point associated with this credential.
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// Organization Webhook associated with this credential.
	OrganizationWebhookId *WebhookId `json:"organization_webhook_id,omitempty" url:"organization_webhook_id,omitempty"`
	// One of `account` or `integration_point`.
	OwnerType OwnerType `json:"owner_type" url:"owner_type"`
	// Human friendly display name for this Credential
	Fullname string `json:"fullname" url:"fullname"`
	// Credential configuration
	Config *CredentialConfig `json:"config,omitempty" url:"config,omitempty"`
	// Time when this credential expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`
	// Field is set by the management process. Determines lifecycle and ownership of the credential.
	Managed ManagedType `json:"managed" url:"managed"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Credential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Credential) UnmarshalJSON(data []byte) error {
	type embed Credential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Credential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Credential) MarshalJSON() ([]byte, error) {
	type embed Credential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Expires:   core.NewOptionalDateTime(c.Expires),
	}
	return json.Marshal(marshaler)
}

func (c *Credential) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Base type for all credential types
type CredentialBase struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialBase) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialBase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CredentialBase) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialConfig struct {
	Type        string
	Aws         *AwsCredential
	Token       *TokenCredential
	Basic       *BasicCredential
	Secret      *SecretCredential
	OAuthClient *OAuthClientCredential
}

func (c *CredentialConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Aws = value
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Token = value
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Basic = value
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Secret = value
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.OAuthClient = value
	}
	return nil
}

func (c CredentialConfig) MarshalJSON() ([]byte, error) {
	if c.Aws != nil {
		return core.MarshalJSONWithExtraProperty(c.Aws, "type", "aws")
	}
	if c.Token != nil {
		return core.MarshalJSONWithExtraProperty(c.Token, "type", "token")
	}
	if c.Basic != nil {
		return core.MarshalJSONWithExtraProperty(c.Basic, "type", "basic")
	}
	if c.Secret != nil {
		return core.MarshalJSONWithExtraProperty(c.Secret, "type", "secret")
	}
	if c.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(c.OAuthClient, "type", "o_auth_client")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CredentialConfigVisitor interface {
	VisitAws(*AwsCredential) error
	VisitToken(*TokenCredential) error
	VisitBasic(*BasicCredential) error
	VisitSecret(*SecretCredential) error
	VisitOAuthClient(*OAuthClientCredential) error
}

func (c *CredentialConfig) Accept(visitor CredentialConfigVisitor) error {
	if c.Aws != nil {
		return visitor.VisitAws(c.Aws)
	}
	if c.Token != nil {
		return visitor.VisitToken(c.Token)
	}
	if c.Basic != nil {
		return visitor.VisitBasic(c.Basic)
	}
	if c.Secret != nil {
		return visitor.VisitSecret(c.Secret)
	}
	if c.OAuthClient != nil {
		return visitor.VisitOAuthClient(c.OAuthClient)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CredentialConfigNoSecret struct {
	Type string `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialConfigNoSecret) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialConfigNoSecret) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialConfigNoSecret
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialConfigNoSecret(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CredentialConfigNoSecret) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response object for a Credential
type CredentialResponse struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at" url:"updated_at"`
	Id        CredentialId `json:"id" url:"id"`
	// Account that manages this credential.
	AccountId *AccountId `json:"account_id,omitempty" url:"account_id,omitempty"`
	// Integration associated with this credential.
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`
	// Integration Point associated with this credential.
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// Integration Point associated with this credential.
	OrganizationWebhookId *WebhookId `json:"organization_webhook_id,omitempty" url:"organization_webhook_id,omitempty"`
	// One of `account` or `integration_point`.
	OwnerType OwnerType `json:"owner_type" url:"owner_type"`
	// Human friendly display name for this Credential. Defaults to the same value as the 'name' field if not specified.
	Fullname string                    `json:"fullname" url:"fullname"`
	Config   *CredentialConfigNoSecret `json:"config" url:"config"`
	// Time when this credential expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`
	// Field is set by the management process. Determines lifecycle and ownership of the credential.
	Managed ManagedType `json:"managed" url:"managed"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialResponse) UnmarshalJSON(data []byte) error {
	type embed CredentialResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CredentialResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CredentialResponse) MarshalJSON() ([]byte, error) {
	type embed CredentialResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Expires:   core.NewOptionalDateTime(c.Expires),
	}
	return json.Marshal(marshaler)
}

func (c *CredentialResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialType string

const (
	CredentialTypeAws         CredentialType = "aws"
	CredentialTypeToken       CredentialType = "token"
	CredentialTypeBasic       CredentialType = "basic"
	CredentialTypeSecret      CredentialType = "secret"
	CredentialTypeOAuthClient CredentialType = "o_auth_client"
)

func NewCredentialTypeFromString(s string) (CredentialType, error) {
	switch s {
	case "aws":
		return CredentialTypeAws, nil
	case "token":
		return CredentialTypeToken, nil
	case "basic":
		return CredentialTypeBasic, nil
	case "secret":
		return CredentialTypeSecret, nil
	case "o_auth_client":
		return CredentialTypeOAuthClient, nil
	}
	var t CredentialType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialType) Ptr() *CredentialType {
	return &c
}

type ManagedType string

const (
	ManagedTypeManaged   ManagedType = "Managed"
	ManagedTypeUnmanaged ManagedType = "Unmanaged"
)

func NewManagedTypeFromString(s string) (ManagedType, error) {
	switch s {
	case "Managed":
		return ManagedTypeManaged, nil
	case "Unmanaged":
		return ManagedTypeUnmanaged, nil
	}
	var t ManagedType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ManagedType) Ptr() *ManagedType {
	return &m
}

// A Client ID and secret used for authenticating with OAuth 2.0 compatible service using the client credentials grant.
type OAuthClientCredential struct {
	// Optional URL for the OAuth 2.0 token exchange if it can not be constructed based on provider configuration
	TokenUrl *string `json:"token_url,omitempty" url:"token_url,omitempty"`
	// The ID of the client application defined at the service provider
	ClientId string `json:"client_id" url:"client_id"`
	// Secret value for authentication
	ClientSecret string `json:"client_secret" url:"client_secret"`
	// Optional connection specific JSON map data such as a signing key ID or organization ID
	Extra map[string]interface{} `json:"extra,omitempty" url:"extra,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OAuthClientCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthClientCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthClientCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthClientCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OAuthClientCredential) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Unique identifier for an OAuth Client Credential
type OAuthClientCredentialId = CredentialId

type OwnerType string

const (
	OwnerTypeAccount             OwnerType = "account"
	OwnerTypeIntegration         OwnerType = "integration"
	OwnerTypeIntegrationPoint    OwnerType = "integration_point"
	OwnerTypeOrganizationWebhook OwnerType = "organization_webhook"
)

func NewOwnerTypeFromString(s string) (OwnerType, error) {
	switch s {
	case "account":
		return OwnerTypeAccount, nil
	case "integration":
		return OwnerTypeIntegration, nil
	case "integration_point":
		return OwnerTypeIntegrationPoint, nil
	case "organization_webhook":
		return OwnerTypeOrganizationWebhook, nil
	}
	var t OwnerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OwnerType) Ptr() *OwnerType {
	return &o
}

// Secret value such as password or webhook url
type SecretCredential struct {
	// Secret value
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SecretCredential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecretCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler SecretCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecretCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SecretCredential) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Unique identifier for a Secret Credential
type SecretCredentialId = CredentialId

// Token used to authenticate with an external service.
type TokenCredential struct {
	// Secret value of the token.
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TokenCredential) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Unique identifier for a Token Credential
type TokenCredentialId = CredentialId

// Unique identifier for this Integration
type IntegrationId = Id

type AdditionalMappingTemplate struct {
	// The resources that this mapping applies to.
	Resource ResourceId `json:"resource" url:"resource"`
	// The actions that this mapping applies to. At least one action must be specified.
	Actions []ActionId `json:"actions" url:"actions"`
	// The dot-separated path to the field in the source data coming from the provider. Use `\.` to escape literal dots in the field name.
	Source string `json:"source" url:"source"`
	// The dot-separated path to where the data should reside in the custom fields object when data is returned from the provider.
	Destination string `json:"destination" url:"destination"`
	// When true, the value in 'source' is treated as a literal value rather than a mapping. This allows adding static values to custom fields. Default: false
	Literal *bool `json:"literal,omitempty" url:"literal,omitempty"`
	// The data type of the field. This ensures the data is processed to the correct type when mapping. Fields set to 'any' will not get validated
	// or processed. Other types are cast depending as defined by each provider. For example, a field with 'datetime' is parsed based on the date
	// format used by the provider, and normalized to a unix timestamp with millisecond precision.
	DataType MappingDataType `json:"data_type" url:"data_type"`
	// A list of provider ID strings that this mapping applies to. Mapping templates must have at least one provider.
	Providers []ProviderConfigId `json:"providers" url:"providers"`
	// This controls the end-user's responsibility for this mapping when creating an integration in this integration point. Default: 'optional'.
	// When set to 'fixed' the mapping is always included and can not be overridden by the end-user.
	// When 'optional', the end-user can choose to override the mapping.
	// When 'recommended', the provider will enter a warning state if the mapping is missing.
	MappingType *AdditionalMappingType `json:"mapping_type,omitempty" url:"mapping_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdditionalMappingTemplate) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdditionalMappingTemplate) UnmarshalJSON(data []byte) error {
	type unmarshaler AdditionalMappingTemplate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdditionalMappingTemplate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AdditionalMappingTemplate) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AdditionalMappingType string

const (
	AdditionalMappingTypeRecommended AdditionalMappingType = "recommended"
	AdditionalMappingTypeOptional    AdditionalMappingType = "optional"
	AdditionalMappingTypeFixed       AdditionalMappingType = "fixed"
)

func NewAdditionalMappingTypeFromString(s string) (AdditionalMappingType, error) {
	switch s {
	case "recommended":
		return AdditionalMappingTypeRecommended, nil
	case "optional":
		return AdditionalMappingTypeOptional, nil
	case "fixed":
		return AdditionalMappingTypeFixed, nil
	}
	var t AdditionalMappingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AdditionalMappingType) Ptr() *AdditionalMappingType {
	return &a
}

type IntegrationEnvironments struct {
	// List of allowed providers for test environment.
	Test []ProviderConfigId `json:"test,omitempty" url:"test,omitempty"`
	// List of allowed providers for production environment.
	Prod []ProviderConfigId `json:"prod,omitempty" url:"prod,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationEnvironments) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationEnvironments(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationEnvironments) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Enables creation, editing and deletion of Integrations.
type IntegrationPoint struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time          `json:"updated_at" url:"updated_at"`
	Id        IntegrationPointId `json:"id" url:"id"`
	// Name of integration point, will be shown to end-users in the Connect UI.
	Fullname *string `json:"fullname,omitempty" url:"fullname,omitempty"`
	// Optional description of the Integration Point. Will not be displayed to end-users of Connect UI.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Connector to use for the Integration Point.
	Connector CategoryId `json:"connector" url:"connector"`
	// Selects providers to use for account environments.
	Environments *IntegrationEnvironments `json:"environments" url:"environments"`
	// A list of mapping chains to apply to integrations using this integration point. Each mapping chain is a list of mappings to apply to the integration in the order they should be applied. Mappings are applied by operation ID. If an integration is created that declares its own mappings for an operation, they will override this list of mappings. Leave this empty to use the default default mappings.
	Mappings []*MappingChainTemplate `json:"mappings,omitempty" url:"mappings,omitempty"`
	// Additional data mappings for integrations added to this integration point. This allows for custom data to be mapped to the custom_fields portion of the response.
	AdditionalMappings []*AdditionalMappingTemplate `json:"additional_mappings,omitempty" url:"additional_mappings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationPoint) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationPoint) UnmarshalJSON(data []byte) error {
	type embed IntegrationPoint
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = IntegrationPoint(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationPoint) MarshalJSON() ([]byte, error) {
	type embed IntegrationPoint
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*i),
		CreatedAt: core.NewDateTime(i.CreatedAt),
		UpdatedAt: core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *IntegrationPoint) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MappingChainTemplate struct {
	// A list of mapping IDs to apply in the format `{mapping_id}:{version}`.
	Mappings []string `json:"mappings" url:"mappings"`
	// The operation IDs to apply the mappings to.
	OperationIds []string `json:"operation_ids" url:"operation_ids"`
	// A list of provider ID strings that this mapping applies to. Mapping templates must have at least one provider.
	Providers []ProviderConfigId `json:"providers" url:"providers"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MappingChainTemplate) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MappingChainTemplate) UnmarshalJSON(data []byte) error {
	type unmarshaler MappingChainTemplate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MappingChainTemplate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MappingChainTemplate) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type BridgeSelector struct {
	Type string
	// ID of a specific bridge group to use
	Id string
	// Labels the bridge group must have. If multiple labels are provided, the first bridge group that has any one of the labels will be selected.
	Labels []string
}

func (b *BridgeSelector) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "id":
		var valueUnmarshaler struct {
			Id string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		b.Id = valueUnmarshaler.Id
	case "labels":
		var valueUnmarshaler struct {
			Labels []string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		b.Labels = valueUnmarshaler.Labels
	}
	return nil
}

func (b BridgeSelector) MarshalJSON() ([]byte, error) {
	if b.Id != "" {
		var marshaler = struct {
			Type string `json:"type"`
			Id   string `json:"value"`
		}{
			Type: "id",
			Id:   b.Id,
		}
		return json.Marshal(marshaler)
	}
	if b.Labels != nil {
		var marshaler = struct {
			Type   string   `json:"type"`
			Labels []string `json:"value"`
		}{
			Type:   "labels",
			Labels: b.Labels,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BridgeSelectorVisitor interface {
	VisitId(string) error
	VisitLabels([]string) error
}

func (b *BridgeSelector) Accept(visitor BridgeSelectorVisitor) error {
	if b.Id != "" {
		return visitor.VisitId(b.Id)
	}
	if b.Labels != nil {
		return visitor.VisitLabels(b.Labels)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

type CreateIntegrationResponseResult struct {
	CredentialsCreated []*CredentialResponse `json:"credentials_created,omitempty" url:"credentials_created,omitempty"`
	Integration        *Integration          `json:"integration" url:"integration"`
	Token              *TokenPair            `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateIntegrationResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateIntegrationResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateIntegrationResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateIntegrationResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateIntegrationResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Connects an Account to an external service
type Integration struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time     `json:"updated_at" url:"updated_at"`
	Id        IntegrationId `json:"id" url:"id"`
	// Human friendly display name for this integration.
	Fullname string `json:"fullname" url:"fullname"`
	// Integration refresh token id
	RefreshTokenId TokenId `json:"refresh_token_id" url:"refresh_token_id"`
	// Account associated with this integration. Use the expand=accounts parameter with the List and ListAccount APIs to expand the Account to the full object
	AccountId AccountId `json:"account_id" url:"account_id"`
	// When using the expand option on the List or ListAccount APIs, the full account object is included in the response
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// Id of the Connector Category for this Integration.
	Category CategoryId `json:"category" url:"category"`
	// Provider configuration for this Integration.
	ProviderConfig *ProviderConfig `json:"provider_config" url:"provider_config"`
	// Human friendly display name for the provider.
	ProviderFullname string `json:"provider_fullname" url:"provider_fullname"`
	// Type of the provider for this Integration.
	ProviderType string `json:"provider_type" url:"provider_type"`
	// Integration Point associated with this integration. Use the expand=integration_points parameter with the List and ListAccount APIs to expand the Integration Point to the full object
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// When using the expand option on the List or ListAccount APIs, the full integration_point object is included in the response
	IntegrationPoint *IntegrationPoint `json:"integration_point,omitempty" url:"integration_point,omitempty"`
	// Use a Bridge to connect to the provider.
	BridgeSelector *BridgeSelector `json:"bridge_selector,omitempty" url:"bridge_selector,omitempty"`
	// Webhook configuration for this integration. Some providers support webhooks, and will allow end users providers to send events to a server for new or updated data.
	WebhookConfig *WebhookConfig `json:"webhook_config,omitempty" url:"webhook_config,omitempty"`
	// A list of mapping chains to apply to the integration. Each mapping chain is a list of mappings to apply to the integration in the order they should be applied. Mappings are applied by operation ID. Leave this empty to use the default default mappings.
	Mappings []*MappingChain `json:"mappings,omitempty" url:"mappings,omitempty"`
	// Additional data mappings for this integration. This allows for custom data to be mapped to the custom_fields portion of the response.
	AdditionalMappings []*AdditionalMapping `json:"additional_mappings,omitempty" url:"additional_mappings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Integration) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Integration) UnmarshalJSON(data []byte) error {
	type embed Integration
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Integration(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *Integration) MarshalJSON() ([]byte, error) {
	type embed Integration
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*i),
		CreatedAt: core.NewDateTime(i.CreatedAt),
		UpdatedAt: core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *Integration) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type WebhookConfig struct {
	// The key used by Synqly to verify incoming webhook payloads sent by the Provider. The format and requirements for this key is Provider specific:
	//
	// - **ServiceNow**: Webhook payload signing is not currently supported, so the integrity of incoming ServiceNow payloads cannot be verified.
	// - **Jira**: Synqly does _not_ automatically configure Jira webhooks. A user with administrator privileges must configure the webhook, including the signing key. If this key is not specified, Synqly will _not_ validate incoming webhooks from Jira. It is strongly recommended that a key is specified and configured with Jira to ensure the integrity of incoming payloads.
	ProviderKey *string `json:"provider_key,omitempty" url:"provider_key,omitempty"`
	// List of webhooks for an integration. If the provider supports webhooks, they will be sent to the servers provided in this list.
	Items []*WebhookItem `json:"items" url:"items"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhookConfig) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *WebhookConfig) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookEvent string

const (
	WebhookEventTicketCreated        WebhookEvent = "TicketCreated"
	WebhookEventTicketUpdated        WebhookEvent = "TicketUpdated"
	WebhookEventTicketDeleted        WebhookEvent = "TicketDeleted"
	WebhookEventTicketCommentCreated WebhookEvent = "TicketCommentCreated"
	WebhookEventTicketCommentDeleted WebhookEvent = "TicketCommentDeleted"
)

func NewWebhookEventFromString(s string) (WebhookEvent, error) {
	switch s {
	case "TicketCreated":
		return WebhookEventTicketCreated, nil
	case "TicketUpdated":
		return WebhookEventTicketUpdated, nil
	case "TicketDeleted":
		return WebhookEventTicketDeleted, nil
	case "TicketCommentCreated":
		return WebhookEventTicketCommentCreated, nil
	case "TicketCommentDeleted":
		return WebhookEventTicketCommentDeleted, nil
	}
	var t WebhookEvent
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookEvent) Ptr() *WebhookEvent {
	return &w
}

type WebhookItem struct {
	// Webhook URL. Events from providers will be sent to this URL.
	WebhookUrl string `json:"webhook_url" url:"webhook_url"`
	// If specified, only events matching this list will be sent to `webhook_url`. If no filters are specified, all events sent from providers will be forwarded to `webhook_url`.
	EventFilter []WebhookEvent `json:"event_filter,omitempty" url:"event_filter,omitempty"`
	// The key used to sign outgoing web hook payloads. If not specified a random key is automatically generated.
	// Use this key at the target URL to validate that the incoming payload was signed by Synqly. The payload is signed symmetrically with the `integrator_key` using the `HMAC-SHA256` signature scheme. The key should be randomly generated and between 24 bytes (192 bits) and 64 bytes (512 bits) long.
	IntegratorKey *string `json:"integrator_key,omitempty" url:"integrator_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhookItem) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookItem) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *WebhookItem) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type AdditionalMapping struct {
	// The resources that this mapping applies to.
	Resource ResourceId `json:"resource" url:"resource"`
	// The actions that this mapping applies to. At least one action must be specified.
	Actions []ActionId `json:"actions" url:"actions"`
	// The dot-separated path to the field in the source data coming from the provider. Use `\.` to escape literal dots in the field name.
	Source string `json:"source" url:"source"`
	// The dot-separated path to where the data should reside in the custom fields object when data is returned from the provider.
	Destination string `json:"destination" url:"destination"`
	// When true, the value in 'source' is treated as a literal value rather than a mapping. This allows adding static values to custom fields. Default: false
	Literal *bool `json:"literal,omitempty" url:"literal,omitempty"`
	// The data type of the field. This ensures the data is processed to the correct type when mapping. Fields set to 'any' will not get validated
	// or processed. Other types are cast depending as defined by each provider. For example, a field with 'datetime' is parsed based on the date
	// format used by the provider, and normalized to a unix timestamp with millisecond precision.
	DataType MappingDataType `json:"data_type" url:"data_type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdditionalMapping) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdditionalMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler AdditionalMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdditionalMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AdditionalMapping) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type MappingChain struct {
	// A list of mapping IDs to apply in the format `{mapping_id}:{version}`.
	Mappings []string `json:"mappings" url:"mappings"`
	// The operation IDs to apply the mappings to.
	OperationIds []string `json:"operation_ids" url:"operation_ids"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MappingChain) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MappingChain) UnmarshalJSON(data []byte) error {
	type unmarshaler MappingChain
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MappingChain(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MappingChain) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MappingDataType string

const (
	MappingDataTypeString   MappingDataType = "string"
	MappingDataTypeNumber   MappingDataType = "number"
	MappingDataTypeDatetime MappingDataType = "datetime"
	MappingDataTypeBoolean  MappingDataType = "boolean"
	MappingDataTypeArray    MappingDataType = "array"
	MappingDataTypeAny      MappingDataType = "any"
)

func NewMappingDataTypeFromString(s string) (MappingDataType, error) {
	switch s {
	case "string":
		return MappingDataTypeString, nil
	case "number":
		return MappingDataTypeNumber, nil
	case "datetime":
		return MappingDataTypeDatetime, nil
	case "boolean":
		return MappingDataTypeBoolean, nil
	case "array":
		return MappingDataTypeArray, nil
	case "any":
		return MappingDataTypeAny, nil
	}
	var t MappingDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MappingDataType) Ptr() *MappingDataType {
	return &m
}

type ApplyMappingResponseResult struct {
	// The JSON object resulting from applying the mapping chain defined by the request over the input data.
	Mapping map[string]interface{} `json:"mapping" url:"mapping"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApplyMappingResponseResult) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApplyMappingResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ApplyMappingResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApplyMappingResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *ApplyMappingResponseResult) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type CreateMappingResponseResult struct {
	Mapping *Mapping `json:"mapping" url:"mapping"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateMappingResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMappingResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateMappingResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateMappingResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateMappingResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Mapping struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        MappingId `json:"id" url:"id"`
	// Human friendly display name for this mapping.
	Fullname string `json:"fullname" url:"fullname"`
	// Organization that manages this Mapping.
	OrganizationId OrganizationId `json:"organization_id" url:"organization_id"`
	// transform to apply.
	Data string `json:"data" url:"data"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Mapping) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Mapping) UnmarshalJSON(data []byte) error {
	type embed Mapping
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Mapping(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *Mapping) MarshalJSON() ([]byte, error) {
	type embed Mapping
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*m),
		CreatedAt: core.NewDateTime(m.CreatedAt),
		UpdatedAt: core.NewDateTime(m.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (m *Mapping) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MappingBase struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        MappingId `json:"id" url:"id"`
	// Human friendly display name for this mapping.
	Fullname string `json:"fullname" url:"fullname"`
	// Organization that manages this Mapping.
	OrganizationId OrganizationId `json:"organization_id" url:"organization_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MappingBase) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MappingBase) UnmarshalJSON(data []byte) error {
	type embed MappingBase
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MappingBase(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MappingBase) MarshalJSON() ([]byte, error) {
	type embed MappingBase
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*m),
		CreatedAt: core.NewDateTime(m.CreatedAt),
		UpdatedAt: core.NewDateTime(m.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (m *MappingBase) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type CreateMemberResponseResult struct {
	Member *Member `json:"member" url:"member"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateMemberResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMemberResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateMemberResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateMemberResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateMemberResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Member struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        MemberId  `json:"id" url:"id"`
	State     State     `json:"state" url:"state"`
	// Last logon time
	LastLogon time.Time `json:"last_logon" url:"last_logon"`
	// User's full display name.
	Fullname string `json:"fullname" url:"fullname"`
	// User's nickname
	Nickname *string `json:"nickname,omitempty" url:"nickname,omitempty"`
	// Url of user's picture
	Picture    *string   `json:"picture,omitempty" url:"picture,omitempty"`
	Ttl        string    `json:"ttl" url:"ttl"`
	TokenTtl   string    `json:"token_ttl" url:"token_ttl"`
	Expires    time.Time `json:"expires" url:"expires"`
	PinExpires time.Time `json:"pin_expires" url:"pin_expires"`
	// Roles granted to this member. Tokens inherit this access.
	RoleBinding []RoleName `json:"role_binding" url:"role_binding"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Member) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Member) UnmarshalJSON(data []byte) error {
	type embed Member
	var unmarshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"created_at"`
		UpdatedAt  *core.DateTime `json:"updated_at"`
		LastLogon  *core.DateTime `json:"last_logon"`
		Expires    *core.DateTime `json:"expires"`
		PinExpires *core.DateTime `json:"pin_expires"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Member(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	m.LastLogon = unmarshaler.LastLogon.Time()
	m.Expires = unmarshaler.Expires.Time()
	m.PinExpires = unmarshaler.PinExpires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *Member) MarshalJSON() ([]byte, error) {
	type embed Member
	var marshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"created_at"`
		UpdatedAt  *core.DateTime `json:"updated_at"`
		LastLogon  *core.DateTime `json:"last_logon"`
		Expires    *core.DateTime `json:"expires"`
		PinExpires *core.DateTime `json:"pin_expires"`
	}{
		embed:      embed(*m),
		CreatedAt:  core.NewDateTime(m.CreatedAt),
		UpdatedAt:  core.NewDateTime(m.UpdatedAt),
		LastLogon:  core.NewDateTime(m.LastLogon),
		Expires:    core.NewDateTime(m.Expires),
		PinExpires: core.NewDateTime(m.PinExpires),
	}
	return json.Marshal(marshaler)
}

func (m *Member) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MemberOptions struct {
	// Optional member time-to-live duration. After a member expires, system requires a change password to re-enable member. Minimum 1 day, Maximum 1 year, Default 180 days.
	Ttl string `json:"ttl" url:"ttl"`
	// Options: "expired" will force change password on first logon.
	Options []Options `json:"options" url:"options"`
	// Optional token time-to-live duration. Tokens are created for this member with this duration as their TTL. Minimum 10 miniutes, Maximum 1 week, Defaults 1 hour.
	TokenTtl string `json:"token_ttl" url:"token_ttl"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MemberOptions) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MemberOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler MemberOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MemberOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MemberOptions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Options string

const (
	OptionsDisabled  Options = "disabled"
	OptionsExpired   Options = "expired"
	OptionsForgotten Options = "forgotten"
	OptionsInvited   Options = "invited"
	OptionsLocked    Options = "locked"
)

func NewOptionsFromString(s string) (Options, error) {
	switch s {
	case "disabled":
		return OptionsDisabled, nil
	case "expired":
		return OptionsExpired, nil
	case "forgotten":
		return OptionsForgotten, nil
	case "invited":
		return OptionsInvited, nil
	case "locked":
		return OptionsLocked, nil
	}
	var t Options
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Options) Ptr() *Options {
	return &o
}

type State string

const (
	StateDisabled  State = "disabled"
	StateEnabled   State = "enabled"
	StateForgotten State = "forgotten"
	StateInvited   State = "invited"
	StateLocked    State = "locked"
)

func NewStateFromString(s string) (State, error) {
	switch s {
	case "disabled":
		return StateDisabled, nil
	case "enabled":
		return StateEnabled, nil
	case "forgotten":
		return StateForgotten, nil
	case "invited":
		return StateInvited, nil
	case "locked":
		return StateLocked, nil
	}
	var t State
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s State) Ptr() *State {
	return &s
}

// Unique request identifier for this Asynchronous Operation.
type AsyncOperationRequestId = Id

type Operation struct {
	// ID of the operation
	Id AsyncOperationRequestId `json:"id" url:"id"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// Account ID containing the integration.
	AccountId Id `json:"account_id" url:"account_id"`
	// Integration ID to use for the operation.
	IntegrationId Id `json:"integration_id" url:"integration_id"`
	// Run now or on the specified schedule.
	Schedule *OperationSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// Name of the operation that will be run for this operation.
	Operation string `json:"operation" url:"operation"`
	// Parameters for the operation that will be run for this operation.
	Input *OperationInput `json:"input" url:"input"`
	// Status of the operation
	Status OperationStatus `json:"status" url:"status"`
	// Errors that occurred during the operation
	Errors []*OperationError `json:"errors,omitempty" url:"errors,omitempty"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time" url:"cpu_time"`
	// Number of bytes sent to sink integration
	InBytes int64 `json:"in_bytes" url:"in_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Operation) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Operation) UnmarshalJSON(data []byte) error {
	type embed Operation
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Operation(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Operation) MarshalJSON() ([]byte, error) {
	type embed Operation
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *Operation) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OperationError struct {
	// Error message
	Message string `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OperationError) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OperationError) UnmarshalJSON(data []byte) error {
	type unmarshaler OperationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OperationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OperationError) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OperationInput struct {
	// Limit the number of results returned by the operation. If not specified, the operation will return all results.
	Filters []string `json:"filters,omitempty" url:"filters,omitempty"`
	// Limit query results by these filters.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OperationInput) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OperationInput) UnmarshalJSON(data []byte) error {
	type unmarshaler OperationInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OperationInput(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OperationInput) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OperationSchedule struct {
	// Run now or on the specified time.
	RunAt *time.Time `json:"run_at,omitempty" url:"run_at,omitempty"`
	// Set the interval duration for recuring operations. (minimum 1h)
	Interval *string `json:"interval,omitempty" url:"interval,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OperationSchedule) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OperationSchedule) UnmarshalJSON(data []byte) error {
	type embed OperationSchedule
	var unmarshaler = struct {
		embed
		RunAt *core.DateTime `json:"run_at,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OperationSchedule(unmarshaler.embed)
	o.RunAt = unmarshaler.RunAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OperationSchedule) MarshalJSON() ([]byte, error) {
	type embed OperationSchedule
	var marshaler = struct {
		embed
		RunAt *core.DateTime `json:"run_at,omitempty"`
	}{
		embed: embed(*o),
		RunAt: core.NewOptionalDateTime(o.RunAt),
	}
	return json.Marshal(marshaler)
}

func (o *OperationSchedule) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OperationStatus string

const (
	OperationStatusScheduled  OperationStatus = "SCHEDULED"
	OperationStatusProcessing OperationStatus = "PROCESSING"
	OperationStatusCancelled  OperationStatus = "CANCELLED"
	OperationStatusComplete   OperationStatus = "COMPLETE"
)

func NewOperationStatusFromString(s string) (OperationStatus, error) {
	switch s {
	case "SCHEDULED":
		return OperationStatusScheduled, nil
	case "PROCESSING":
		return OperationStatusProcessing, nil
	case "CANCELLED":
		return OperationStatusCancelled, nil
	case "COMPLETE":
		return OperationStatusComplete, nil
	}
	var t OperationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OperationStatus) Ptr() *OperationStatus {
	return &o
}

type OperationId string

const (
	OperationIdAssetsCreateAsset                        OperationId = "assets_create_asset"
	OperationIdAssetsGetLabels                          OperationId = "assets_get_labels"
	OperationIdAssetsQueryDevices                       OperationId = "assets_query_devices"
	OperationIdCloudsecurityQueryCloudResourceInventory OperationId = "cloudsecurity_query_cloud_resource_inventory"
	OperationIdCloudsecurityQueryComplianceFindings     OperationId = "cloudsecurity_query_compliance_findings"
	OperationIdCloudsecurityQueryEvents                 OperationId = "cloudsecurity_query_events"
	OperationIdCloudsecurityQueryIoms                   OperationId = "cloudsecurity_query_ioms"
	OperationIdEdrCreateIocs                            OperationId = "edr_create_iocs"
	OperationIdEdrDeleteIocs                            OperationId = "edr_delete_iocs"
	OperationIdEdrGetEndpoint                           OperationId = "edr_get_endpoint"
	OperationIdEdrNetworkQuarantine                     OperationId = "edr_network_quarantine"
	OperationIdEdrQueryAlerts                           OperationId = "edr_query_alerts"
	OperationIdEdrQueryApplications                     OperationId = "edr_query_applications"
	OperationIdEdrQueryEdrEvents                        OperationId = "edr_query_edr_events"
	OperationIdEdrQueryEndpoints                        OperationId = "edr_query_endpoints"
	OperationIdEdrQueryIocs                             OperationId = "edr_query_iocs"
	OperationIdEdrQueryPostureScore                     OperationId = "edr_query_posture_score"
	OperationIdEdrQueryThreatevents                     OperationId = "edr_query_threatevents"
	OperationIdIdentityDisableUser                      OperationId = "identity_disable_user"
	OperationIdIdentityEnableUser                       OperationId = "identity_enable_user"
	OperationIdIdentityExpireAllUserSessions            OperationId = "identity_expire_all_user_sessions"
	OperationIdIdentityForceUserPasswordReset           OperationId = "identity_force_user_password_reset"
	OperationIdIdentityGetGroup                         OperationId = "identity_get_group"
	OperationIdIdentityGetGroupMembers                  OperationId = "identity_get_group_members"
	OperationIdIdentityGetUser                          OperationId = "identity_get_user"
	OperationIdIdentityQueryAuditLog                    OperationId = "identity_query_audit_log"
	OperationIdIdentityQueryGroups                      OperationId = "identity_query_groups"
	OperationIdIdentityQueryUsers                       OperationId = "identity_query_users"
	OperationIdNotificationsClearMessage                OperationId = "notifications_clear_message"
	OperationIdNotificationsCreateMessage               OperationId = "notifications_create_message"
	OperationIdNotificationsGetMessage                  OperationId = "notifications_get_message"
	OperationIdSiemGetEvidence                          OperationId = "siem_get_evidence"
	OperationIdSiemGetInvestigation                     OperationId = "siem_get_investigation"
	OperationIdSiemPatchInvestigation                   OperationId = "siem_patch_investigation"
	OperationIdSiemPostEvents                           OperationId = "siem_post_events"
	OperationIdSiemQueryAlerts                          OperationId = "siem_query_alerts"
	OperationIdSiemQueryEvents                          OperationId = "siem_query_events"
	OperationIdSiemQueryInvestigations                  OperationId = "siem_query_investigations"
	OperationIdSiemQueryLogProviders                    OperationId = "siem_query_log_providers"
	OperationIdSinkPostEvents                           OperationId = "sink_post_events"
	OperationIdStorageDeleteFile                        OperationId = "storage_delete_file"
	OperationIdStorageDownloadFile                      OperationId = "storage_download_file"
	OperationIdStorageListFiles                         OperationId = "storage_list_files"
	OperationIdStorageUploadFile                        OperationId = "storage_upload_file"
	OperationIdTicketingCreateAttachment                OperationId = "ticketing_create_attachment"
	OperationIdTicketingCreateComment                   OperationId = "ticketing_create_comment"
	OperationIdTicketingCreateNote                      OperationId = "ticketing_create_note"
	OperationIdTicketingCreateTicket                    OperationId = "ticketing_create_ticket"
	OperationIdTicketingDeleteAttachment                OperationId = "ticketing_delete_attachment"
	OperationIdTicketingDeleteComment                   OperationId = "ticketing_delete_comment"
	OperationIdTicketingDeleteNote                      OperationId = "ticketing_delete_note"
	OperationIdTicketingDownloadAttachment              OperationId = "ticketing_download_attachment"
	OperationIdTicketingGetTicket                       OperationId = "ticketing_get_ticket"
	OperationIdTicketingListAttachmentsMetadata         OperationId = "ticketing_list_attachments_metadata"
	OperationIdTicketingListComments                    OperationId = "ticketing_list_comments"
	OperationIdTicketingListNotes                       OperationId = "ticketing_list_notes"
	OperationIdTicketingListOnCall                      OperationId = "ticketing_list_on_call"
	OperationIdTicketingListProjects                    OperationId = "ticketing_list_projects"
	OperationIdTicketingListRemoteFields                OperationId = "ticketing_list_remote_fields"
	OperationIdTicketingPatchNote                       OperationId = "ticketing_patch_note"
	OperationIdTicketingPatchTicket                     OperationId = "ticketing_patch_ticket"
	OperationIdTicketingQueryEscalationPolicies         OperationId = "ticketing_query_escalation_policies"
	OperationIdTicketingQueryTickets                    OperationId = "ticketing_query_tickets"
	OperationIdVulnerabilitiesCreateAsset               OperationId = "vulnerabilities_create_asset"
	OperationIdVulnerabilitiesCreateFindings            OperationId = "vulnerabilities_create_findings"
	OperationIdVulnerabilitiesGetScanActivity           OperationId = "vulnerabilities_get_scan_activity"
	OperationIdVulnerabilitiesQueryAssets               OperationId = "vulnerabilities_query_assets"
	OperationIdVulnerabilitiesQueryFindings             OperationId = "vulnerabilities_query_findings"
	OperationIdVulnerabilitiesQueryScans                OperationId = "vulnerabilities_query_scans"
	OperationIdVulnerabilitiesUpdateAsset               OperationId = "vulnerabilities_update_asset"
	OperationIdVulnerabilitiesUpdateFinding             OperationId = "vulnerabilities_update_finding"
)

func NewOperationIdFromString(s string) (OperationId, error) {
	switch s {
	case "assets_create_asset":
		return OperationIdAssetsCreateAsset, nil
	case "assets_get_labels":
		return OperationIdAssetsGetLabels, nil
	case "assets_query_devices":
		return OperationIdAssetsQueryDevices, nil
	case "cloudsecurity_query_cloud_resource_inventory":
		return OperationIdCloudsecurityQueryCloudResourceInventory, nil
	case "cloudsecurity_query_compliance_findings":
		return OperationIdCloudsecurityQueryComplianceFindings, nil
	case "cloudsecurity_query_events":
		return OperationIdCloudsecurityQueryEvents, nil
	case "cloudsecurity_query_ioms":
		return OperationIdCloudsecurityQueryIoms, nil
	case "edr_create_iocs":
		return OperationIdEdrCreateIocs, nil
	case "edr_delete_iocs":
		return OperationIdEdrDeleteIocs, nil
	case "edr_get_endpoint":
		return OperationIdEdrGetEndpoint, nil
	case "edr_network_quarantine":
		return OperationIdEdrNetworkQuarantine, nil
	case "edr_query_alerts":
		return OperationIdEdrQueryAlerts, nil
	case "edr_query_applications":
		return OperationIdEdrQueryApplications, nil
	case "edr_query_edr_events":
		return OperationIdEdrQueryEdrEvents, nil
	case "edr_query_endpoints":
		return OperationIdEdrQueryEndpoints, nil
	case "edr_query_iocs":
		return OperationIdEdrQueryIocs, nil
	case "edr_query_posture_score":
		return OperationIdEdrQueryPostureScore, nil
	case "edr_query_threatevents":
		return OperationIdEdrQueryThreatevents, nil
	case "identity_disable_user":
		return OperationIdIdentityDisableUser, nil
	case "identity_enable_user":
		return OperationIdIdentityEnableUser, nil
	case "identity_expire_all_user_sessions":
		return OperationIdIdentityExpireAllUserSessions, nil
	case "identity_force_user_password_reset":
		return OperationIdIdentityForceUserPasswordReset, nil
	case "identity_get_group":
		return OperationIdIdentityGetGroup, nil
	case "identity_get_group_members":
		return OperationIdIdentityGetGroupMembers, nil
	case "identity_get_user":
		return OperationIdIdentityGetUser, nil
	case "identity_query_audit_log":
		return OperationIdIdentityQueryAuditLog, nil
	case "identity_query_groups":
		return OperationIdIdentityQueryGroups, nil
	case "identity_query_users":
		return OperationIdIdentityQueryUsers, nil
	case "notifications_clear_message":
		return OperationIdNotificationsClearMessage, nil
	case "notifications_create_message":
		return OperationIdNotificationsCreateMessage, nil
	case "notifications_get_message":
		return OperationIdNotificationsGetMessage, nil
	case "siem_get_evidence":
		return OperationIdSiemGetEvidence, nil
	case "siem_get_investigation":
		return OperationIdSiemGetInvestigation, nil
	case "siem_patch_investigation":
		return OperationIdSiemPatchInvestigation, nil
	case "siem_post_events":
		return OperationIdSiemPostEvents, nil
	case "siem_query_alerts":
		return OperationIdSiemQueryAlerts, nil
	case "siem_query_events":
		return OperationIdSiemQueryEvents, nil
	case "siem_query_investigations":
		return OperationIdSiemQueryInvestigations, nil
	case "siem_query_log_providers":
		return OperationIdSiemQueryLogProviders, nil
	case "sink_post_events":
		return OperationIdSinkPostEvents, nil
	case "storage_delete_file":
		return OperationIdStorageDeleteFile, nil
	case "storage_download_file":
		return OperationIdStorageDownloadFile, nil
	case "storage_list_files":
		return OperationIdStorageListFiles, nil
	case "storage_upload_file":
		return OperationIdStorageUploadFile, nil
	case "ticketing_create_attachment":
		return OperationIdTicketingCreateAttachment, nil
	case "ticketing_create_comment":
		return OperationIdTicketingCreateComment, nil
	case "ticketing_create_note":
		return OperationIdTicketingCreateNote, nil
	case "ticketing_create_ticket":
		return OperationIdTicketingCreateTicket, nil
	case "ticketing_delete_attachment":
		return OperationIdTicketingDeleteAttachment, nil
	case "ticketing_delete_comment":
		return OperationIdTicketingDeleteComment, nil
	case "ticketing_delete_note":
		return OperationIdTicketingDeleteNote, nil
	case "ticketing_download_attachment":
		return OperationIdTicketingDownloadAttachment, nil
	case "ticketing_get_ticket":
		return OperationIdTicketingGetTicket, nil
	case "ticketing_list_attachments_metadata":
		return OperationIdTicketingListAttachmentsMetadata, nil
	case "ticketing_list_comments":
		return OperationIdTicketingListComments, nil
	case "ticketing_list_notes":
		return OperationIdTicketingListNotes, nil
	case "ticketing_list_on_call":
		return OperationIdTicketingListOnCall, nil
	case "ticketing_list_projects":
		return OperationIdTicketingListProjects, nil
	case "ticketing_list_remote_fields":
		return OperationIdTicketingListRemoteFields, nil
	case "ticketing_patch_note":
		return OperationIdTicketingPatchNote, nil
	case "ticketing_patch_ticket":
		return OperationIdTicketingPatchTicket, nil
	case "ticketing_query_escalation_policies":
		return OperationIdTicketingQueryEscalationPolicies, nil
	case "ticketing_query_tickets":
		return OperationIdTicketingQueryTickets, nil
	case "vulnerabilities_create_asset":
		return OperationIdVulnerabilitiesCreateAsset, nil
	case "vulnerabilities_create_findings":
		return OperationIdVulnerabilitiesCreateFindings, nil
	case "vulnerabilities_get_scan_activity":
		return OperationIdVulnerabilitiesGetScanActivity, nil
	case "vulnerabilities_query_assets":
		return OperationIdVulnerabilitiesQueryAssets, nil
	case "vulnerabilities_query_findings":
		return OperationIdVulnerabilitiesQueryFindings, nil
	case "vulnerabilities_query_scans":
		return OperationIdVulnerabilitiesQueryScans, nil
	case "vulnerabilities_update_asset":
		return OperationIdVulnerabilitiesUpdateAsset, nil
	case "vulnerabilities_update_finding":
		return OperationIdVulnerabilitiesUpdateFinding, nil
	}
	var t OperationId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OperationId) Ptr() *OperationId {
	return &o
}

type CreateOrganizationResponseResult struct {
	Member       *Member       `json:"member,omitempty" url:"member,omitempty"`
	Organization *Organization `json:"organization" url:"organization"`
	Token        *TokenPair    `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrganizationResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrganizationResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrganizationResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrganizationResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateOrganizationResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Environment string

const (
	EnvironmentTest Environment = "test"
	EnvironmentProd Environment = "prod"
)

func NewEnvironmentFromString(s string) (Environment, error) {
	switch s {
	case "test":
		return EnvironmentTest, nil
	case "prod":
		return EnvironmentProd, nil
	}
	var t Environment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e Environment) Ptr() *Environment {
	return &e
}

type GetOrganizationResponse struct {
	Result *Organization `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetOrganizationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOrganizationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrganizationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrganizationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetOrganizationResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Organization struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time      `json:"updated_at" url:"updated_at"`
	Id        OrganizationId `json:"id" url:"id"`
	// Organization refresh token id
	RefreshTokenId TokenId `json:"refresh_token_id" url:"refresh_token_id"`
	// Organization type: root or standard
	OrganizationType OrganizationType `json:"organization_type" url:"organization_type"`
	// Human friendly display name for this Organization
	Fullname string `json:"fullname" url:"fullname"`
	// Organization email address
	Contact *string `json:"contact,omitempty" url:"contact,omitempty"`
	// Reply-to email address, used for SMTP emails. Defaults to no-reply@synqly.com
	ReplyTo *string `json:"reply_to,omitempty" url:"reply_to,omitempty"`
	// Picture URL of the organization
	Picture *string `json:"picture,omitempty" url:"picture,omitempty"`
	// Organization options
	Options *OrganizationOptions `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Organization) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Organization) UnmarshalJSON(data []byte) error {
	type embed Organization
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Organization(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Organization) MarshalJSON() ([]byte, error) {
	type embed Organization
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *Organization) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Unique identifier for this Organization
type OrganizationId = Id

type OrganizationOptions struct {
	// Duration new member invitations will be valid. Default: 168h (7 days), minimum 24h, maximum 168h (7 days).
	InviteDuration *string `json:"invite_duration,omitempty" url:"invite_duration,omitempty"`
	// Duration forgotten password invitations will be valid. Default: 24h, minimum 24h, maximum 168h (7 days).
	ForgotDuration *string `json:"forgot_duration,omitempty" url:"forgot_duration,omitempty"`
	// Duration before member password expires, part of required password rotation. Default: 4320h (180 days), minimum: 24h, maximum: 8760h (365 days).
	PasswordDuration *string `json:"password_duration,omitempty" url:"password_duration,omitempty"`
	// Minimum password length. Default: 8, minimum 8, maximum 72.
	MinimumPasswordLength *int `json:"minimum_password_length,omitempty" url:"minimum_password_length,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationOptions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationOptions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationType string

const (
	OrganizationTypeRoot     OrganizationType = "root"
	OrganizationTypeStandard OrganizationType = "standard"
)

func NewOrganizationTypeFromString(s string) (OrganizationType, error) {
	switch s {
	case "root":
		return OrganizationTypeRoot, nil
	case "standard":
		return OrganizationTypeStandard, nil
	}
	var t OrganizationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrganizationType) Ptr() *OrganizationType {
	return &o
}

type WebhookFilter string

const (
	WebhookFilterAll               WebhookFilter = "all"
	WebhookFilterAccountCreate     WebhookFilter = "account_create"
	WebhookFilterAccountDelete     WebhookFilter = "account_delete"
	WebhookFilterAccountUpdate     WebhookFilter = "account_update"
	WebhookFilterIntegrationCreate WebhookFilter = "integration_create"
	WebhookFilterIntegrationDelete WebhookFilter = "integration_delete"
	WebhookFilterIntegrationUpdate WebhookFilter = "integration_update"
	WebhookFilterOperationComplete WebhookFilter = "operation_complete"
)

func NewWebhookFilterFromString(s string) (WebhookFilter, error) {
	switch s {
	case "all":
		return WebhookFilterAll, nil
	case "account_create":
		return WebhookFilterAccountCreate, nil
	case "account_delete":
		return WebhookFilterAccountDelete, nil
	case "account_update":
		return WebhookFilterAccountUpdate, nil
	case "integration_create":
		return WebhookFilterIntegrationCreate, nil
	case "integration_delete":
		return WebhookFilterIntegrationDelete, nil
	case "integration_update":
		return WebhookFilterIntegrationUpdate, nil
	case "operation_complete":
		return WebhookFilterOperationComplete, nil
	}
	var t WebhookFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookFilter) Ptr() *WebhookFilter {
	return &w
}

// Response payload for webhook events. This payload is sent to the webhook URL when an event occurs.
type OrganizationWebhookPayload struct {
	// The event that triggered the webhook
	Event WebhookFilter `json:"event" url:"event"`
	// The account that the event occurred in
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// The integration that the event occurred in
	Integration *Integration `json:"integration,omitempty" url:"integration,omitempty"`
	// A unique identifier for this webhook event
	Nonce string `json:"nonce" url:"nonce"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhookPayload) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhookPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationWebhookPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationWebhookPayload(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationWebhookPayload) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationWebhook struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        WebhookId `json:"id" url:"id"`
	// Human friendly slug for this webhook
	Fullname string `json:"fullname" url:"fullname"`
	// Environment that the webhook is configured for. Only events associated with this environment will trigger the webhook.
	Environment Environment `json:"environment" url:"environment"`
	// Specifies which Webhooks to send.
	Filters []WebhookFilter `json:"filters" url:"filters"`
	// URL that webhooks will be sent to
	Url string `json:"url" url:"url"`
	// Credential contain secret
	CredentialId CredentialId `json:"credential_id" url:"credential_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhook) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhook) UnmarshalJSON(data []byte) error {
	type embed OrganizationWebhook
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OrganizationWebhook(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationWebhook) MarshalJSON() ([]byte, error) {
	type embed OrganizationWebhook
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *OrganizationWebhook) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationWebhookSecret struct {
	// Secret used for signing webhooks. This value is used to verify the authenticity of the webhook payload.
	Value string `json:"value" url:"value"`
	// Time when this secret expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhookSecret) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhookSecret) UnmarshalJSON(data []byte) error {
	type embed OrganizationWebhookSecret
	var unmarshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OrganizationWebhookSecret(unmarshaler.embed)
	o.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationWebhookSecret) MarshalJSON() ([]byte, error) {
	type embed OrganizationWebhookSecret
	var marshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed:   embed(*o),
		Expires: core.NewOptionalDateTime(o.Expires),
	}
	return json.Marshal(marshaler)
}

func (o *OrganizationWebhookSecret) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type Permission struct {
	// Roles granted to this token.
	RoleBinding []RoleName `json:"role_binding,omitempty" url:"role_binding,omitempty"`
	// Adhoc role granted to this token.
	AdhocRole *AdhocRole `json:"adhoc_role,omitempty" url:"adhoc_role,omitempty"`
	// ID of the resource that this permission grants access to.
	ResourceId Id `json:"resource_id" url:"resource_id"`
	// Type of the resource that this permission grants access to. Must be one of the following: "organization, "integration"
	ResourceType string `json:"resource_type" url:"resource_type"`
	// Token parentId
	ParentId Id `json:"parent_id" url:"parent_id"`
	// Token Id
	Id Id `json:"id" url:"id"`
	// Token organizationId
	OrganizationId Id `json:"organization_id" url:"organization_id"`
	// Token root organizationId
	RootOrganizationId *Id `json:"root_organization_id,omitempty" url:"root_organization_id,omitempty"`
	// Token memberId
	MemberId Id `json:"member_id" url:"member_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Permission) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Permission) UnmarshalJSON(data []byte) error {
	type unmarshaler Permission
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Permission(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Permission) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type AccountsActions string

const (
	AccountsActionsList   AccountsActions = "list"
	AccountsActionsCreate AccountsActions = "create"
	AccountsActionsGet    AccountsActions = "get"
	AccountsActionsUpdate AccountsActions = "update"
	AccountsActionsPatch  AccountsActions = "patch"
	AccountsActionsDelete AccountsActions = "delete"
	AccountsActionsAll    AccountsActions = "*"
)

func NewAccountsActionsFromString(s string) (AccountsActions, error) {
	switch s {
	case "list":
		return AccountsActionsList, nil
	case "create":
		return AccountsActionsCreate, nil
	case "get":
		return AccountsActionsGet, nil
	case "update":
		return AccountsActionsUpdate, nil
	case "patch":
		return AccountsActionsPatch, nil
	case "delete":
		return AccountsActionsDelete, nil
	case "*":
		return AccountsActionsAll, nil
	}
	var t AccountsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountsActions) Ptr() *AccountsActions {
	return &a
}

// Permissions for the accounts API
type AccountsPermissions struct {
	Actions []AccountsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AccountsPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AccountsPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AlarmPoliciesActions string

const (
	AlarmPoliciesActionsGet    AlarmPoliciesActions = "get"
	AlarmPoliciesActionsUpdate AlarmPoliciesActions = "update"
	AlarmPoliciesActionsPatch  AlarmPoliciesActions = "patch"
	AlarmPoliciesActionsAll    AlarmPoliciesActions = "*"
)

func NewAlarmPoliciesActionsFromString(s string) (AlarmPoliciesActions, error) {
	switch s {
	case "get":
		return AlarmPoliciesActionsGet, nil
	case "update":
		return AlarmPoliciesActionsUpdate, nil
	case "patch":
		return AlarmPoliciesActionsPatch, nil
	case "*":
		return AlarmPoliciesActionsAll, nil
	}
	var t AlarmPoliciesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AlarmPoliciesActions) Ptr() *AlarmPoliciesActions {
	return &a
}

// Permissions for the alarm policy API
type AlarmPoliciesPermissions struct {
	Actions []AlarmPoliciesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AlarmPoliciesPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AlarmPoliciesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AlarmPoliciesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlarmPoliciesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AlarmPoliciesPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AlarmsActions string

const (
	AlarmsActionsList     AlarmsActions = "list"
	AlarmsActionsGet      AlarmsActions = "get"
	AlarmsActionsMode     AlarmsActions = "mode"
	AlarmsActionsPriority AlarmsActions = "priority"
	AlarmsActionsClear    AlarmsActions = "clear"
	AlarmsActionsAll      AlarmsActions = "*"
)

func NewAlarmsActionsFromString(s string) (AlarmsActions, error) {
	switch s {
	case "list":
		return AlarmsActionsList, nil
	case "get":
		return AlarmsActionsGet, nil
	case "mode":
		return AlarmsActionsMode, nil
	case "priority":
		return AlarmsActionsPriority, nil
	case "clear":
		return AlarmsActionsClear, nil
	case "*":
		return AlarmsActionsAll, nil
	}
	var t AlarmsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AlarmsActions) Ptr() *AlarmsActions {
	return &a
}

// Permissions for the alarms API
type AlarmsPermissions struct {
	Actions []AlarmsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AlarmsPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AlarmsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AlarmsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlarmsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AlarmsPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiPermissionMap struct {
	All               *ReadWritePermissions         `json:"all,omitempty" url:"all,omitempty"`
	Accounts          *AccountsPermissions          `json:"accounts,omitempty" url:"accounts,omitempty"`
	Alarms            *AlarmsPermissions            `json:"alarms,omitempty" url:"alarms,omitempty"`
	AlarmPolicies     *AlarmPoliciesPermissions     `json:"alarm_policies,omitempty" url:"alarm_policies,omitempty"`
	Audit             *AuditPermissions             `json:"audit,omitempty" url:"audit,omitempty"`
	Auth              *AuthPermissions              `json:"auth,omitempty" url:"auth,omitempty"`
	Billing           *BillingPermissions           `json:"billing,omitempty" url:"billing,omitempty"`
	Bridges           *BridgesPermissions           `json:"bridges,omitempty" url:"bridges,omitempty"`
	Credentials       *CredentialsPermissions       `json:"credentials,omitempty" url:"credentials,omitempty"`
	Integrations      *IntegrationsPermissions      `json:"integrations,omitempty" url:"integrations,omitempty"`
	IntegrationPoints *IntegrationPointsPermissions `json:"integration_points,omitempty" url:"integration_points,omitempty"`
	Operations        *OperationsPermissions        `json:"operations,omitempty" url:"operations,omitempty"`
	Mappings          *MappingsPermissions          `json:"mappings,omitempty" url:"mappings,omitempty"`
	Members           *MembersPermissions           `json:"members,omitempty" url:"members,omitempty"`
	Organizations     *OrganizationPermissions      `json:"organizations,omitempty" url:"organizations,omitempty"`
	PermissionSet     *PermissionSetPermissions     `json:"permission_set,omitempty" url:"permission_set,omitempty"`
	Roles             *RolesPermissions             `json:"roles,omitempty" url:"roles,omitempty"`
	Status            *StatusPermissions            `json:"status,omitempty" url:"status,omitempty"`
	Suborgs           *SubOrgsPermissions           `json:"suborgs,omitempty" url:"suborgs,omitempty"`
	Tokens            *TokensPermissions            `json:"tokens,omitempty" url:"tokens,omitempty"`
	Transforms        *TransformsPermissions        `json:"transforms,omitempty" url:"transforms,omitempty"`
	Webhooks          *WebhooksPermissions          `json:"webhooks,omitempty" url:"webhooks,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiPermissionMap) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiPermissionMap) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiPermissionMap
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiPermissionMap(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *ApiPermissionMap) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuditActions string

const (
	AuditActionsList AuditActions = "list"
	AuditActionsAll  AuditActions = "*"
)

func NewAuditActionsFromString(s string) (AuditActions, error) {
	switch s {
	case "list":
		return AuditActionsList, nil
	case "*":
		return AuditActionsAll, nil
	}
	var t AuditActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuditActions) Ptr() *AuditActions {
	return &a
}

// Permissions for the audit API
type AuditPermissions struct {
	Actions []AuditActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AuditPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AuditPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AuditPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuditPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AuditPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuthActions string

const (
	AuthActionsLogon          AuthActions = "logon"
	AuthActionsChangePassword AuthActions = "change_password"
	AuthActionsLogoff         AuthActions = "logoff"
	AuthActionsAll            AuthActions = "*"
)

func NewAuthActionsFromString(s string) (AuthActions, error) {
	switch s {
	case "logon":
		return AuthActionsLogon, nil
	case "change_password":
		return AuthActionsChangePassword, nil
	case "logoff":
		return AuthActionsLogoff, nil
	case "*":
		return AuthActionsAll, nil
	}
	var t AuthActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthActions) Ptr() *AuthActions {
	return &a
}

// Permissions for the auth logon/logoff API
type AuthPermissions struct {
	Actions []AuthActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AuthPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AuthPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AuthPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BillingActions string

const (
	BillingActionsList BillingActions = "list"
	BillingActionsGet  BillingActions = "get"
	BillingActionsAll  BillingActions = "*"
)

func NewBillingActionsFromString(s string) (BillingActions, error) {
	switch s {
	case "list":
		return BillingActionsList, nil
	case "get":
		return BillingActionsGet, nil
	case "*":
		return BillingActionsAll, nil
	}
	var t BillingActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BillingActions) Ptr() *BillingActions {
	return &b
}

// Permissions for the billing API
type BillingPermissions struct {
	Actions []BillingActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BillingPermissions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BillingPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler BillingPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BillingPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BillingPermissions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgesActions string

const (
	BridgesActionsList   BridgesActions = "list"
	BridgesActionsCreate BridgesActions = "create"
	BridgesActionsGet    BridgesActions = "get"
	BridgesActionsUpdate BridgesActions = "update"
	BridgesActionsPatch  BridgesActions = "patch"
	BridgesActionsDelete BridgesActions = "delete"
	BridgesActionsStatus BridgesActions = "status"
	BridgesActionsAll    BridgesActions = "*"
)

func NewBridgesActionsFromString(s string) (BridgesActions, error) {
	switch s {
	case "list":
		return BridgesActionsList, nil
	case "create":
		return BridgesActionsCreate, nil
	case "get":
		return BridgesActionsGet, nil
	case "update":
		return BridgesActionsUpdate, nil
	case "patch":
		return BridgesActionsPatch, nil
	case "delete":
		return BridgesActionsDelete, nil
	case "status":
		return BridgesActionsStatus, nil
	case "*":
		return BridgesActionsAll, nil
	}
	var t BridgesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BridgesActions) Ptr() *BridgesActions {
	return &b
}

// Permissions for the bridge API
type BridgesPermissions struct {
	Actions []BridgesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgesPermissions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgesPermissions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CredentialsActions string

const (
	CredentialsActionsList   CredentialsActions = "list"
	CredentialsActionsCreate CredentialsActions = "create"
	CredentialsActionsGet    CredentialsActions = "get"
	CredentialsActionsUpdate CredentialsActions = "update"
	CredentialsActionsPatch  CredentialsActions = "patch"
	CredentialsActionsDelete CredentialsActions = "delete"
	CredentialsActionsLookup CredentialsActions = "lookup"
	CredentialsActionsAll    CredentialsActions = "*"
)

func NewCredentialsActionsFromString(s string) (CredentialsActions, error) {
	switch s {
	case "list":
		return CredentialsActionsList, nil
	case "create":
		return CredentialsActionsCreate, nil
	case "get":
		return CredentialsActionsGet, nil
	case "update":
		return CredentialsActionsUpdate, nil
	case "patch":
		return CredentialsActionsPatch, nil
	case "delete":
		return CredentialsActionsDelete, nil
	case "lookup":
		return CredentialsActionsLookup, nil
	case "*":
		return CredentialsActionsAll, nil
	}
	var t CredentialsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialsActions) Ptr() *CredentialsActions {
	return &c
}

// Permissions for the credentials API
type CredentialsPermissions struct {
	Actions []CredentialsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialsPermissions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CredentialsPermissions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type IntegrationPointsActions string

const (
	IntegrationPointsActionsList   IntegrationPointsActions = "list"
	IntegrationPointsActionsCreate IntegrationPointsActions = "create"
	IntegrationPointsActionsGet    IntegrationPointsActions = "get"
	IntegrationPointsActionsUpdate IntegrationPointsActions = "update"
	IntegrationPointsActionsPatch  IntegrationPointsActions = "patch"
	IntegrationPointsActionsDelete IntegrationPointsActions = "delete"
	IntegrationPointsActionsAll    IntegrationPointsActions = "*"
)

func NewIntegrationPointsActionsFromString(s string) (IntegrationPointsActions, error) {
	switch s {
	case "list":
		return IntegrationPointsActionsList, nil
	case "create":
		return IntegrationPointsActionsCreate, nil
	case "get":
		return IntegrationPointsActionsGet, nil
	case "update":
		return IntegrationPointsActionsUpdate, nil
	case "patch":
		return IntegrationPointsActionsPatch, nil
	case "delete":
		return IntegrationPointsActionsDelete, nil
	case "*":
		return IntegrationPointsActionsAll, nil
	}
	var t IntegrationPointsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationPointsActions) Ptr() *IntegrationPointsActions {
	return &i
}

// Permissions for the integrations points API
type IntegrationPointsPermissions struct {
	Actions []IntegrationPointsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationPointsPermissions) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationPointsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationPointsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationPointsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationPointsPermissions) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IntegrationsActions string

const (
	IntegrationsActionsList        IntegrationsActions = "list"
	IntegrationsActionsCreate      IntegrationsActions = "create"
	IntegrationsActionsGet         IntegrationsActions = "get"
	IntegrationsActionsUpdate      IntegrationsActions = "update"
	IntegrationsActionsPatch       IntegrationsActions = "patch"
	IntegrationsActionsDelete      IntegrationsActions = "delete"
	IntegrationsActionsListAccount IntegrationsActions = "list_account"
	IntegrationsActionsVerify      IntegrationsActions = "verify"
	IntegrationsActionsAll         IntegrationsActions = "*"
)

func NewIntegrationsActionsFromString(s string) (IntegrationsActions, error) {
	switch s {
	case "list":
		return IntegrationsActionsList, nil
	case "create":
		return IntegrationsActionsCreate, nil
	case "get":
		return IntegrationsActionsGet, nil
	case "update":
		return IntegrationsActionsUpdate, nil
	case "patch":
		return IntegrationsActionsPatch, nil
	case "delete":
		return IntegrationsActionsDelete, nil
	case "list_account":
		return IntegrationsActionsListAccount, nil
	case "verify":
		return IntegrationsActionsVerify, nil
	case "*":
		return IntegrationsActionsAll, nil
	}
	var t IntegrationsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationsActions) Ptr() *IntegrationsActions {
	return &i
}

// Permissions for the integrations API
type IntegrationsPermissions struct {
	Actions []IntegrationsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationsPermissions) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationsPermissions) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MappingsActions string

const (
	MappingsActionsList   MappingsActions = "list"
	MappingsActionsCreate MappingsActions = "create"
	MappingsActionsGet    MappingsActions = "get"
	MappingsActionsUpdate MappingsActions = "update"
	MappingsActionsPatch  MappingsActions = "patch"
	MappingsActionsDelete MappingsActions = "delete"
	MappingsActionsApply  MappingsActions = "apply"
	MappingsActionsAll    MappingsActions = "*"
)

func NewMappingsActionsFromString(s string) (MappingsActions, error) {
	switch s {
	case "list":
		return MappingsActionsList, nil
	case "create":
		return MappingsActionsCreate, nil
	case "get":
		return MappingsActionsGet, nil
	case "update":
		return MappingsActionsUpdate, nil
	case "patch":
		return MappingsActionsPatch, nil
	case "delete":
		return MappingsActionsDelete, nil
	case "apply":
		return MappingsActionsApply, nil
	case "*":
		return MappingsActionsAll, nil
	}
	var t MappingsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MappingsActions) Ptr() *MappingsActions {
	return &m
}

// Permissions for the mappings API
type MappingsPermissions struct {
	Actions []MappingsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MappingsPermissions) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MappingsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler MappingsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MappingsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MappingsPermissions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MembersActions string

const (
	MembersActionsList   MembersActions = "list"
	MembersActionsCreate MembersActions = "create"
	MembersActionsGet    MembersActions = "get"
	MembersActionsUpdate MembersActions = "update"
	MembersActionsPatch  MembersActions = "patch"
	MembersActionsDelete MembersActions = "delete"
	MembersActionsAll    MembersActions = "*"
)

func NewMembersActionsFromString(s string) (MembersActions, error) {
	switch s {
	case "list":
		return MembersActionsList, nil
	case "create":
		return MembersActionsCreate, nil
	case "get":
		return MembersActionsGet, nil
	case "update":
		return MembersActionsUpdate, nil
	case "patch":
		return MembersActionsPatch, nil
	case "delete":
		return MembersActionsDelete, nil
	case "*":
		return MembersActionsAll, nil
	}
	var t MembersActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MembersActions) Ptr() *MembersActions {
	return &m
}

// Permissions for the members API
type MembersPermissions struct {
	Actions []MembersActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MembersPermissions) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MembersPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler MembersPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MembersPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MembersPermissions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OperationsActions string

const (
	OperationsActionsList OperationsActions = "list"
	OperationsActionsAll  OperationsActions = "*"
)

func NewOperationsActionsFromString(s string) (OperationsActions, error) {
	switch s {
	case "list":
		return OperationsActionsList, nil
	case "*":
		return OperationsActionsAll, nil
	}
	var t OperationsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OperationsActions) Ptr() *OperationsActions {
	return &o
}

// Permissions for the operations API
type OperationsPermissions struct {
	Actions []OperationsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OperationsPermissions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OperationsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler OperationsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OperationsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OperationsPermissions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationActions string

const (
	OrganizationActionsGet    OrganizationActions = "get"
	OrganizationActionsUpdate OrganizationActions = "update"
	OrganizationActionsPatch  OrganizationActions = "patch"
	OrganizationActionsAll    OrganizationActions = "*"
)

func NewOrganizationActionsFromString(s string) (OrganizationActions, error) {
	switch s {
	case "get":
		return OrganizationActionsGet, nil
	case "update":
		return OrganizationActionsUpdate, nil
	case "patch":
		return OrganizationActionsPatch, nil
	case "*":
		return OrganizationActionsAll, nil
	}
	var t OrganizationActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrganizationActions) Ptr() *OrganizationActions {
	return &o
}

// Permissions for the organization API
type OrganizationPermissions struct {
	Actions []OrganizationActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationPermissions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationPermissions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PermissionSet struct {
	Name Permissions `json:"name" url:"name"`
	// Description of when the permission set should be used and what permissions are granted by the permission set.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Resources that can be used with this permission set
	ResourceRestrictions []ResourceRestrictions `json:"resource_restrictions,omitempty" url:"resource_restrictions,omitempty"`
	// API permissions granted by the permission set.
	Permissions *ApiPermissionMap `json:"permissions" url:"permissions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PermissionSet) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PermissionSet) UnmarshalJSON(data []byte) error {
	type unmarshaler PermissionSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PermissionSet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *PermissionSet) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PermissionSetActions string

const (
	PermissionSetActionsList PermissionSetActions = "list"
	PermissionSetActionsGet  PermissionSetActions = "get"
	PermissionSetActionsAll  PermissionSetActions = "*"
)

func NewPermissionSetActionsFromString(s string) (PermissionSetActions, error) {
	switch s {
	case "list":
		return PermissionSetActionsList, nil
	case "get":
		return PermissionSetActionsGet, nil
	case "*":
		return PermissionSetActionsAll, nil
	}
	var t PermissionSetActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PermissionSetActions) Ptr() *PermissionSetActions {
	return &p
}

// Permissions for the permissionset API
type PermissionSetPermissions struct {
	Actions []PermissionSetActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PermissionSetPermissions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PermissionSetPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler PermissionSetPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PermissionSetPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *PermissionSetPermissions) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ReadWriteActions string

const (
	ReadWriteActionsRead      ReadWriteActions = "read"
	ReadWriteActionsReadWrite ReadWriteActions = "*"
)

func NewReadWriteActionsFromString(s string) (ReadWriteActions, error) {
	switch s {
	case "read":
		return ReadWriteActionsRead, nil
	case "*":
		return ReadWriteActionsReadWrite, nil
	}
	var t ReadWriteActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReadWriteActions) Ptr() *ReadWriteActions {
	return &r
}

// Permissions for all accounts
type ReadWritePermissions struct {
	Actions []ReadWriteActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReadWritePermissions) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReadWritePermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler ReadWritePermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReadWritePermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *ReadWritePermissions) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResourceRestrictions string

const (
	ResourceRestrictionsAccounts     ResourceRestrictions = "accounts"
	ResourceRestrictionsIntegrations ResourceRestrictions = "integrations"
)

func NewResourceRestrictionsFromString(s string) (ResourceRestrictions, error) {
	switch s {
	case "accounts":
		return ResourceRestrictionsAccounts, nil
	case "integrations":
		return ResourceRestrictionsIntegrations, nil
	}
	var t ResourceRestrictions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResourceRestrictions) Ptr() *ResourceRestrictions {
	return &r
}

type RolesActions string

const (
	RolesActionsList   RolesActions = "list"
	RolesActionsCreate RolesActions = "create"
	RolesActionsGet    RolesActions = "get"
	RolesActionsUpdate RolesActions = "update"
	RolesActionsPatch  RolesActions = "patch"
	RolesActionsDelete RolesActions = "delete"
	RolesActionsAll    RolesActions = "*"
)

func NewRolesActionsFromString(s string) (RolesActions, error) {
	switch s {
	case "list":
		return RolesActionsList, nil
	case "create":
		return RolesActionsCreate, nil
	case "get":
		return RolesActionsGet, nil
	case "update":
		return RolesActionsUpdate, nil
	case "patch":
		return RolesActionsPatch, nil
	case "delete":
		return RolesActionsDelete, nil
	case "*":
		return RolesActionsAll, nil
	}
	var t RolesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RolesActions) Ptr() *RolesActions {
	return &r
}

// Permissions for the roles API
type RolesPermissions struct {
	Actions []RolesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RolesPermissions) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RolesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler RolesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RolesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RolesPermissions) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type StatusActions string

const (
	StatusActionsList                  StatusActions = "list"
	StatusActionsGet                   StatusActions = "get"
	StatusActionsReset                 StatusActions = "reset"
	StatusActionsListEvents            StatusActions = "list_events"
	StatusActionsTimeseries            StatusActions = "timeseries"
	StatusActionsIntegrationTimeseries StatusActions = "integration_timeseries"
	StatusActionsAll                   StatusActions = "*"
)

func NewStatusActionsFromString(s string) (StatusActions, error) {
	switch s {
	case "list":
		return StatusActionsList, nil
	case "get":
		return StatusActionsGet, nil
	case "reset":
		return StatusActionsReset, nil
	case "list_events":
		return StatusActionsListEvents, nil
	case "timeseries":
		return StatusActionsTimeseries, nil
	case "integration_timeseries":
		return StatusActionsIntegrationTimeseries, nil
	case "*":
		return StatusActionsAll, nil
	}
	var t StatusActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusActions) Ptr() *StatusActions {
	return &s
}

// Permissions for the status API
type StatusPermissions struct {
	Actions []StatusActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StatusPermissions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StatusPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler StatusPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StatusPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StatusPermissions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubOrgsActions string

const (
	SubOrgsActionsList   SubOrgsActions = "list"
	SubOrgsActionsCreate SubOrgsActions = "create"
	SubOrgsActionsGet    SubOrgsActions = "get"
	SubOrgsActionsDelete SubOrgsActions = "delete"
	SubOrgsActionsAll    SubOrgsActions = "*"
)

func NewSubOrgsActionsFromString(s string) (SubOrgsActions, error) {
	switch s {
	case "list":
		return SubOrgsActionsList, nil
	case "create":
		return SubOrgsActionsCreate, nil
	case "get":
		return SubOrgsActionsGet, nil
	case "delete":
		return SubOrgsActionsDelete, nil
	case "*":
		return SubOrgsActionsAll, nil
	}
	var t SubOrgsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubOrgsActions) Ptr() *SubOrgsActions {
	return &s
}

// Permissions for the roles API
type SubOrgsPermissions struct {
	Actions []SubOrgsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubOrgsPermissions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubOrgsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler SubOrgsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubOrgsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SubOrgsPermissions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TokensActions string

const (
	TokensActionsList                     TokensActions = "list"
	TokensActionsCreate                   TokensActions = "create"
	TokensActionsCreateIntegration        TokensActions = "create_integration"
	TokensActionsCreateSynqlyIntegrations TokensActions = "create_synqly_integrations"
	TokensActionsDelete                   TokensActions = "delete"
	TokensActionsGet                      TokensActions = "get"
	TokensActionsReset                    TokensActions = "reset"
	TokensActionsRefresh                  TokensActions = "refresh"
	TokensActionsRemoveSecondary          TokensActions = "remove_secondary"
	TokensActionsAll                      TokensActions = "*"
)

func NewTokensActionsFromString(s string) (TokensActions, error) {
	switch s {
	case "list":
		return TokensActionsList, nil
	case "create":
		return TokensActionsCreate, nil
	case "create_integration":
		return TokensActionsCreateIntegration, nil
	case "create_synqly_integrations":
		return TokensActionsCreateSynqlyIntegrations, nil
	case "delete":
		return TokensActionsDelete, nil
	case "get":
		return TokensActionsGet, nil
	case "reset":
		return TokensActionsReset, nil
	case "refresh":
		return TokensActionsRefresh, nil
	case "remove_secondary":
		return TokensActionsRemoveSecondary, nil
	case "*":
		return TokensActionsAll, nil
	}
	var t TokensActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokensActions) Ptr() *TokensActions {
	return &t
}

// Permissions for the tokens API
type TokensPermissions struct {
	Actions []TokensActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokensPermissions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokensPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokensPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokensPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TokensPermissions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransformsActions string

const (
	TransformsActionsList   TransformsActions = "list"
	TransformsActionsCreate TransformsActions = "create"
	TransformsActionsGet    TransformsActions = "get"
	TransformsActionsUpdate TransformsActions = "update"
	TransformsActionsPatch  TransformsActions = "patch"
	TransformsActionsDelete TransformsActions = "delete"
	TransformsActionsAll    TransformsActions = "*"
)

func NewTransformsActionsFromString(s string) (TransformsActions, error) {
	switch s {
	case "list":
		return TransformsActionsList, nil
	case "create":
		return TransformsActionsCreate, nil
	case "get":
		return TransformsActionsGet, nil
	case "update":
		return TransformsActionsUpdate, nil
	case "patch":
		return TransformsActionsPatch, nil
	case "delete":
		return TransformsActionsDelete, nil
	case "*":
		return TransformsActionsAll, nil
	}
	var t TransformsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformsActions) Ptr() *TransformsActions {
	return &t
}

// Permissions for the transforms API
type TransformsPermissions struct {
	Actions []TransformsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransformsPermissions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TransformsPermissions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type WebhooksActions string

const (
	WebhooksActionsList   WebhooksActions = "list"
	WebhooksActionsCreate WebhooksActions = "create"
	WebhooksActionsGet    WebhooksActions = "get"
	WebhooksActionsUpdate WebhooksActions = "update"
	WebhooksActionsPatch  WebhooksActions = "patch"
	WebhooksActionsDelete WebhooksActions = "delete"
	WebhooksActionsAll    WebhooksActions = "*"
)

func NewWebhooksActionsFromString(s string) (WebhooksActions, error) {
	switch s {
	case "list":
		return WebhooksActionsList, nil
	case "create":
		return WebhooksActionsCreate, nil
	case "get":
		return WebhooksActionsGet, nil
	case "update":
		return WebhooksActionsUpdate, nil
	case "patch":
		return WebhooksActionsPatch, nil
	case "delete":
		return WebhooksActionsDelete, nil
	case "*":
		return WebhooksActionsAll, nil
	}
	var t WebhooksActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhooksActions) Ptr() *WebhooksActions {
	return &w
}

// Permissions for the webhooks API
type WebhooksPermissions struct {
	Actions []WebhooksActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhooksPermissions) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhooksPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhooksPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhooksPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *WebhooksPermissions) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type ArmisCredential struct {
	Type string
	// Configuration when creating new API Key.
	Token *TokenCredential
	// Reference to existing API Key.
	TokenId TokenCredentialId
}

func (a *ArmisCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a ArmisCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type ArmisCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *ArmisCredential) Accept(visitor ArmisCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AssetsArmisDataset string

const (
	AssetsArmisDatasetBasicVer0 AssetsArmisDataset = "basic_v0"
)

func NewAssetsArmisDatasetFromString(s string) (AssetsArmisDataset, error) {
	switch s {
	case "basic_v0":
		return AssetsArmisDatasetBasicVer0, nil
	}
	var t AssetsArmisDataset
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssetsArmisDataset) Ptr() *AssetsArmisDataset {
	return &a
}

type AssetsNozomiVantageDataset string

const (
	AssetsNozomiVantageDatasetBasicVer0 AssetsNozomiVantageDataset = "basic_v0"
)

func NewAssetsNozomiVantageDatasetFromString(s string) (AssetsNozomiVantageDataset, error) {
	switch s {
	case "basic_v0":
		return AssetsNozomiVantageDatasetBasicVer0, nil
	}
	var t AssetsNozomiVantageDataset
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssetsNozomiVantageDataset) Ptr() *AssetsNozomiVantageDataset {
	return &a
}

type AssetsQualysCloudDataset string

const (
	AssetsQualysCloudDatasetBasicVer0 AssetsQualysCloudDataset = "basic_v0"
)

func NewAssetsQualysCloudDatasetFromString(s string) (AssetsQualysCloudDataset, error) {
	switch s {
	case "basic_v0":
		return AssetsQualysCloudDatasetBasicVer0, nil
	}
	var t AssetsQualysCloudDataset
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssetsQualysCloudDataset) Ptr() *AssetsQualysCloudDataset {
	return &a
}

type AssetsServiceNowDataset string

const (
	AssetsServiceNowDatasetBasicVer0 AssetsServiceNowDataset = "basic_v0"
)

func NewAssetsServiceNowDatasetFromString(s string) (AssetsServiceNowDataset, error) {
	switch s {
	case "basic_v0":
		return AssetsServiceNowDatasetBasicVer0, nil
	}
	var t AssetsServiceNowDataset
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssetsServiceNowDataset) Ptr() *AssetsServiceNowDataset {
	return &a
}

type AssetsTaniumCloudDataset string

const (
	AssetsTaniumCloudDatasetBasicVer0 AssetsTaniumCloudDataset = "basic_v0"
)

func NewAssetsTaniumCloudDatasetFromString(s string) (AssetsTaniumCloudDataset, error) {
	switch s {
	case "basic_v0":
		return AssetsTaniumCloudDatasetBasicVer0, nil
	}
	var t AssetsTaniumCloudDataset
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AssetsTaniumCloudDataset) Ptr() *AssetsTaniumCloudDataset {
	return &a
}

// Configuration for Armis Centrix™ for Asset Management and Security.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/armis-centrix-setup)
type AssetsArmisCentrix struct {
	Credential *ArmisCredential `json:"credential" url:"credential"`
	// Base URL for the Armis Centrix™ API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsArmisCentrix) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsArmisCentrix) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsArmisCentrix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsArmisCentrix(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsArmisCentrix) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for a mocked Armis Centrix Assets Provider
type AssetsArmisCentrixMock struct {
	Dataset AssetsArmisDataset `json:"dataset" url:"dataset"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsArmisCentrixMock) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsArmisCentrixMock) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsArmisCentrixMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsArmisCentrixMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsArmisCentrixMock) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for the Axonius Assets Provider
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/axonius-asset-setup)
type AssetsAxonius struct {
	Credential *AxoniusCredential `json:"credential" url:"credential"`
	// Base URL for the Axonius API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsAxonius) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsAxonius) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsAxonius
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsAxonius(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsAxonius) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for CrowdStrike Falcon as an Assets Provider
type AssetsCrowdStrike struct {
	// The credential to use for the CrowdStrike Falcon tenant.
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// Base URL for the CrowdStrike Falcon Spotlight API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsCrowdStrike) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsCrowdStrike) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsCrowdStrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsCrowdStrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsCrowdStrike) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for Nozomi Vantage.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/nozomi-vantage-setup)
type AssetsNozomiVantage struct {
	// Credentials used to authenticate with Nozomi Vantage.
	Credential *NozomiVantageCredential `json:"credential" url:"credential"`
	// Base URL for the Nozomi Vantage API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsNozomiVantage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsNozomiVantage) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsNozomiVantage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsNozomiVantage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsNozomiVantage) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for a mocked Nozomi Vantage provider
type AssetsNozomiVantageMock struct {
	Dataset AssetsNozomiVantageDataset `json:"dataset" url:"dataset"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsNozomiVantageMock) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsNozomiVantageMock) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsNozomiVantageMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsNozomiVantageMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsNozomiVantageMock) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for Qualys Cloud Platform as an Assets Provider
type AssetsQualysCloud struct {
	Credential *QualysCloudCredential `json:"credential" url:"credential"`
	// URL for the Qualys Cloud API. This should be the base URL for the API, without any path components.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsQualysCloud) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsQualysCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsQualysCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsQualysCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsQualysCloud) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for a mock Qualys Cloud Platform as an Assets Provider
type AssetsQualysCloudMock struct {
	Dataset AssetsQualysCloudDataset `json:"dataset" url:"dataset"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsQualysCloudMock) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsQualysCloudMock) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsQualysCloudMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsQualysCloudMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsQualysCloudMock) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for ServiceNow Configuration Management Database (CMDB).
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/servicenow-assets-setup)
type AssetsServiceNow struct {
	Credential *ServiceNowCredential `json:"credential" url:"credential"`
	// Base URL for the ServiceNow API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsServiceNow) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsServiceNow) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsServiceNow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsServiceNow(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsServiceNow) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for a mocked ServiceNow as an Assets Provider
type AssetsServiceNowMock struct {
	Dataset AssetsServiceNowDataset `json:"dataset" url:"dataset"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsServiceNowMock) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsServiceNowMock) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsServiceNowMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsServiceNowMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsServiceNowMock) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for the Sevco Assets Provider
type AssetsSevco struct {
	Credential *SevcoCredential `json:"credential" url:"credential"`
	// URL for the Sevco API. This should be the base URL for the API, without any path components.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsSevco) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsSevco) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsSevco
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsSevco(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsSevco) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for Tanium Cloud as an Assets Provider
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/tanium-setup)
type AssetsTaniumCloud struct {
	Credential *TaniumCloudCredential `json:"credential" url:"credential"`
	// Base URL for the Tanium Cloud API
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsTaniumCloud) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsTaniumCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsTaniumCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsTaniumCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsTaniumCloud) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for a mocked Tanium Cloud as an Assets Provider
type AssetsTaniumCloudMock struct {
	Dataset AssetsTaniumCloudDataset `json:"dataset" url:"dataset"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsTaniumCloudMock) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsTaniumCloudMock) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsTaniumCloudMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsTaniumCloudMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsTaniumCloudMock) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AutotaskApiIntegrationCodeCredential struct {
	Type string
	// Identifier used for individual tracking and management of API calls.
	Secret *SecretCredential
	// Reference to existing API Tracking ID.
	SecretId SecretCredentialId
}

func (a *AutotaskApiIntegrationCodeCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (a AutotaskApiIntegrationCodeCredential) MarshalJSON() ([]byte, error) {
	if a.Secret != nil {
		return core.MarshalJSONWithExtraProperty(a.Secret, "type", "secret")
	}
	if a.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: a.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AutotaskApiIntegrationCodeCredentialVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (a *AutotaskApiIntegrationCodeCredential) Accept(visitor AutotaskApiIntegrationCodeCredentialVisitor) error {
	if a.Secret != nil {
		return visitor.VisitSecret(a.Secret)
	}
	if a.SecretId != "" {
		return visitor.VisitSecretId(a.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AutotaskSecretCredential struct {
	Type string
	// Configuration when creating new Secret.
	Secret *SecretCredential
	// Reference to existing Secret.
	SecretId SecretCredentialId
}

func (a *AutotaskSecretCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (a AutotaskSecretCredential) MarshalJSON() ([]byte, error) {
	if a.Secret != nil {
		return core.MarshalJSONWithExtraProperty(a.Secret, "type", "secret")
	}
	if a.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: a.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AutotaskSecretCredentialVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (a *AutotaskSecretCredential) Accept(visitor AutotaskSecretCredentialVisitor) error {
	if a.Secret != nil {
		return visitor.VisitSecret(a.Secret)
	}
	if a.SecretId != "" {
		return visitor.VisitSecretId(a.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsS3Credential struct {
	Type string
	// Configuration when creating new AWS Access Keys.
	Aws *AwsCredential
	// Reference to existing AWS Access Keys.
	AwsId AwsCredentialId
}

func (a *AwsS3Credential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsS3Credential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsS3CredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsS3Credential) Accept(visitor AwsS3CredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSqsCredential struct {
	Type string
	// Configuration when creating new AWS Access Keys.
	Aws *AwsCredential
	// Reference to existing AWS Access Keys.
	AwsId AwsCredentialId
}

func (a *AwsSqsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsSqsCredential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSqsCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsSqsCredential) Accept(visitor AwsSqsCredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSecurityLakeCredential struct {
	Type string
	// Configuration when creating new AWS Access Keys.
	Aws *AwsCredential
	// Reference to existing AWS Access Keys.
	AwsId AwsCredentialId
}

func (a *AwsSecurityLakeCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsSecurityLakeCredential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSecurityLakeCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsSecurityLakeCredential) Accept(visitor AwsSecurityLakeCredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AxoniusCredential struct {
	Type string
	// This credential must be an API Key and API Secret. For more details, see the [Getting an API Key and API Secret](https://docs.axonius.com/docs/axonius-rest-api#getting-an-api-key-and-api-secret).
	Basic *BasicCredential
	// Reference to existing Basic Credentials.
	BasicId BasicCredentialId
}

func (a *AxoniusCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (a AxoniusCredential) MarshalJSON() ([]byte, error) {
	if a.Basic != nil {
		return core.MarshalJSONWithExtraProperty(a.Basic, "type", "basic")
	}
	if a.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: a.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AxoniusCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (a *AxoniusCredential) Accept(visitor AxoniusCredentialVisitor) error {
	if a.Basic != nil {
		return visitor.VisitBasic(a.Basic)
	}
	if a.BasicId != "" {
		return visitor.VisitBasicId(a.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureBlobCredential struct {
	Type string
	// Configuration when creating new Client Secret.
	Token *TokenCredential
	// Reference to existing Client Secret.
	TokenId TokenCredentialId
}

func (a *AzureBlobCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a AzureBlobCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureBlobCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *AzureBlobCredential) Accept(visitor AzureBlobCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureMonitorLogsCredential struct {
	Type string
	// Configuration when creating new Client Secret.
	Token *TokenCredential
	// Reference to existing Client Secret.
	TokenId TokenCredentialId
}

func (a *AzureMonitorLogsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a AzureMonitorLogsCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureMonitorLogsCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *AzureMonitorLogsCredential) Accept(visitor AzureMonitorLogsCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

// Configuration for the CrowdStrike Cloud Security Provider
type CloudSecurityCrowdStrike struct {
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// The root domain where your CrowdStrike Falcon tenant is located.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CloudSecurityCrowdStrike) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloudSecurityCrowdStrike) UnmarshalJSON(data []byte) error {
	type unmarshaler CloudSecurityCrowdStrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloudSecurityCrowdStrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CloudSecurityCrowdStrike) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration for the Microsoft Defender for Cloud Provider
type CloudSecurityDefender struct {
	Credential *DefenderCredential `json:"credential" url:"credential"`
	// The Azure subscription ID that contains the Microsoft Defender for Cloud workspace.
	SubscriptionId string `json:"subscription_id" url:"subscription_id"`
	// The Azure Active Directory tenant ID that contains the Microsoft Defender for Cloud workspace.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// Base URL to your Microsoft Defender for Cloud workspace.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CloudSecurityDefender) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloudSecurityDefender) UnmarshalJSON(data []byte) error {
	type unmarshaler CloudSecurityDefender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloudSecurityDefender(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CloudSecurityDefender) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CrowdStrikeCredential struct {
	Type string
	// Configuration when creating new Client Credentials.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (c *CrowdStrikeCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (c CrowdStrikeCredential) MarshalJSON() ([]byte, error) {
	if c.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(c.OAuthClient, "type", "o_auth_client")
	}
	if c.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: c.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CrowdStrikeCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (c *CrowdStrikeCredential) Accept(visitor CrowdStrikeCredentialVisitor) error {
	if c.OAuthClient != nil {
		return visitor.VisitOAuthClient(c.OAuthClient)
	}
	if c.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(c.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CrowdstrikeHecCredential struct {
	Type string
	// Configuration when creating new API Key.
	Token *TokenCredential
	// Reference to existing API Key.
	TokenId TokenCredentialId
}

func (c *CrowdstrikeHecCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (c CrowdstrikeHecCredential) MarshalJSON() ([]byte, error) {
	if c.Token != nil {
		return core.MarshalJSONWithExtraProperty(c.Token, "type", "token")
	}
	if c.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: c.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CrowdstrikeHecCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (c *CrowdstrikeHecCredential) Accept(visitor CrowdstrikeHecCredentialVisitor) error {
	if c.Token != nil {
		return visitor.VisitToken(c.Token)
	}
	if c.TokenId != "" {
		return visitor.VisitTokenId(c.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CustomFieldMapping struct {
	// Name for the custom field that you will use in the `custom_fields` field in the returned ticket objects.
	Name string `json:"name" url:"name"`
	// ID of the project this field mapping is associated with. ID of "\*" is used to apply to all projects.
	ProjectId string `json:"project_id" url:"project_id"`
	// Path to or name of the custom field in the provider.
	ProviderFieldPath string `json:"provider_field_path" url:"provider_field_path"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomFieldMapping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomFieldMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomFieldMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomFieldMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CustomFieldMapping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DefenderCredential struct {
	Type string
	// Microsoft Defender OAuth client credentials.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (d *DefenderCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", d)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		d.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (d DefenderCredential) MarshalJSON() ([]byte, error) {
	if d.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(d.OAuthClient, "type", "o_auth_client")
	}
	if d.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: d.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", d)
}

type DefenderCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (d *DefenderCredential) Accept(visitor DefenderCredentialVisitor) error {
	if d.OAuthClient != nil {
		return visitor.VisitOAuthClient(d.OAuthClient)
	}
	if d.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(d.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", d)
}

// Configuration for CrowdStrike Falcon® Insight EDR.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/crowdstrike-edr-setup)
type EdrCrowdStrike struct {
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// Base URL for the CrowdStrike Falcon® API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrCrowdStrike) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrCrowdStrike) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrCrowdStrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrCrowdStrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrCrowdStrike) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for Microsoft Defender for Endpoint.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/defender-setup)
type EdrDefender struct {
	Credential *DefenderCredential `json:"credential" url:"credential"`
	// Tenant ID for the Microsoft Defender Management Console.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// Base URL for the Microsoft Defender API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrDefender) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrDefender) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrDefender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrDefender(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrDefender) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for ThreatDown Endpoint Detection & Response.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/malwarebytes-setup)
type EdrMalwarebytes struct {
	// Account identifier for the ThreatDown EDR tenant.
	AccountIdentifier string                  `json:"account_identifier" url:"account_identifier"`
	Credential        *MalwarebytesCredential `json:"credential" url:"credential"`
	// Base URL for the ThreatDown EDR API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrMalwarebytes) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrMalwarebytes) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrMalwarebytes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrMalwarebytes(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrMalwarebytes) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for SentinelOne Singularity™ Endpoint.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/sentinelone-setup)
type EdrSentinelOne struct {
	Credential *SentinelOneCredential `json:"credential" url:"credential"`
	// Credential used for the SentinelOne Singularity Data Lake API. This credential is required when querying EDR events.
	EdrEventsCredential *SentinelOneEdrEventsCredential `json:"edr_events_credential,omitempty" url:"edr_events_credential,omitempty"`
	// Base URL for the SentinelOne Singularity Data Lake API. This URL is required is required when querying EDR events.
	EdrEventsUrl *string `json:"edr_events_url,omitempty" url:"edr_events_url,omitempty"`
	// Base URL for the SentinelOne Management API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrSentinelOne) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrSentinelOne) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrSentinelOne
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrSentinelOne(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrSentinelOne) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for Sophos Endpoint.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/sophos-setup)
type EdrSophos struct {
	Credential *SophosCredential `json:"credential" url:"credential"`
	// Base URL for the Sophos Endpoint API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrSophos) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrSophos) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrSophos
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrSophos(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrSophos) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for Tanium Cloud as a EDR Provider
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/tanium-setup)
type EdrTanium struct {
	Credential *TaniumCloudCredential `json:"credential" url:"credential"`
	// URL for the Tanium Cloud API. This should be the base URL for the API, without any path components and must be HTTPS, e.g. "https://<customername>-api.cloud.tanium.com" or "https://<customername>-api.titankube.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrTanium) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrTanium) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrTanium
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrTanium(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrTanium) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Options used to control how requests are made to Elasticsearch when different authentication types are used.
type ElasticsearchAuthOptions struct {
	// Submit API requests as a specific user, with all of their roles and permissions. When populated, this option will send the `es-security-runas-user` header with every request made to the Elasticsearch API.
	RunAs *string `json:"run_as,omitempty" url:"run_as,omitempty"`
	// Some auth cases, notably JWT auth, can be configured to require sending a shared secret in the `ES-Client-Authentication` header. When this secret is populated it will get added as the shared secret for every request made to Elasticsearch.
	SharedSecret *ElasticsearchSharedSecret `json:"shared_secret,omitempty" url:"shared_secret,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ElasticsearchAuthOptions) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElasticsearchAuthOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ElasticsearchAuthOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElasticsearchAuthOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *ElasticsearchAuthOptions) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElasticsearchCredential struct {
	Type string
	// Basic authentication credentials for Elasticsearch. It is recommended to use API keys or OAuth client credentials whenever possible.
	Basic *BasicCredential
	// Reference to existing Basic Credentials.
	BasicId BasicCredentialId
	// Client credentials and connection data for an identity provider (IdP) that has been configured for use as a [JWT realm](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/jwt-auth-realm.html) in Elasticsearch. *([Instructions for Elastic Cloud](https://www.elastic.co/guide/en/cloud/current/ec-securing-clusters-JWT.html).)*
	// Requires a Token URL for the third party identity provider. To send specific scopes during the client credentials OAuth flow, specify them in `extra.scopes` as a list of strings.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
	// Elasticsearch API Key. Follow [this guide to generate an API Key](https://www.elastic.co/guide/en/kibana/current/api-keys.html). The API Key must have sufficient permissions to the target index.
	Token *TokenCredential
	// Reference to existing API Key.
	TokenId TokenCredentialId
}

func (e *ElasticsearchCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.BasicId = valueUnmarshaler.BasicId
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.OAuthClientId = valueUnmarshaler.OAuthClientId
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (e ElasticsearchCredential) MarshalJSON() ([]byte, error) {
	if e.Basic != nil {
		return core.MarshalJSONWithExtraProperty(e.Basic, "type", "basic")
	}
	if e.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: e.BasicId,
		}
		return json.Marshal(marshaler)
	}
	if e.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(e.OAuthClient, "type", "o_auth_client")
	}
	if e.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: e.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if e.Token != nil {
		return core.MarshalJSONWithExtraProperty(e.Token, "type", "token")
	}
	if e.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: e.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (e *ElasticsearchCredential) Accept(visitor ElasticsearchCredentialVisitor) error {
	if e.Basic != nil {
		return visitor.VisitBasic(e.Basic)
	}
	if e.BasicId != "" {
		return visitor.VisitBasicId(e.BasicId)
	}
	if e.OAuthClient != nil {
		return visitor.VisitOAuthClient(e.OAuthClient)
	}
	if e.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(e.OAuthClientId)
	}
	if e.Token != nil {
		return visitor.VisitToken(e.Token)
	}
	if e.TokenId != "" {
		return visitor.VisitTokenId(e.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchSharedSecret struct {
	Type string
	// Shared secret used to populate the `ES-Client-Authentication` header during Elasticsearch requests.
	Secret *SecretCredential
	// Reference to existing Shared Secret.
	SecretId SecretCredentialId
}

func (e *ElasticsearchSharedSecret) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (e ElasticsearchSharedSecret) MarshalJSON() ([]byte, error) {
	if e.Secret != nil {
		return core.MarshalJSONWithExtraProperty(e.Secret, "type", "secret")
	}
	if e.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: e.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchSharedSecretVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (e *ElasticsearchSharedSecret) Accept(visitor ElasticsearchSharedSecretVisitor) error {
	if e.Secret != nil {
		return visitor.VisitSecret(e.Secret)
	}
	if e.SecretId != "" {
		return visitor.VisitSecretId(e.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EntraIdCredential struct {
	Type string
	// Azure Client ID and Client Secret for a service principal. The application must be configured with permissions to access the user, group, and audit log graph APIs.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (e *EntraIdCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (e EntraIdCredential) MarshalJSON() ([]byte, error) {
	if e.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(e.OAuthClient, "type", "o_auth_client")
	}
	if e.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: e.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EntraIdCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (e *EntraIdCredential) Accept(visitor EntraIdCredentialVisitor) error {
	if e.OAuthClient != nil {
		return visitor.VisitOAuthClient(e.OAuthClient)
	}
	if e.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(e.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type FreshdeskCredential struct {
	Type string
	// You can use your personal API key to authenticate the request. If you use the API key, there is no need for a password. The token is supplied as "Your API Key". [Freshdesk API token generation documentation](https://developer.freshdesk.com/api/#authentication)
	Token *TokenCredential
	// Reference to existing Token.
	TokenId TokenCredentialId
}

func (f *FreshdeskCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (f FreshdeskCredential) MarshalJSON() ([]byte, error) {
	if f.Token != nil {
		return core.MarshalJSONWithExtraProperty(f.Token, "type", "token")
	}
	if f.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: f.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", f)
}

type FreshdeskCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (f *FreshdeskCredential) Accept(visitor FreshdeskCredentialVisitor) error {
	if f.Token != nil {
		return visitor.VisitToken(f.Token)
	}
	if f.TokenId != "" {
		return visitor.VisitTokenId(f.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", f)
}

type GcsCredential struct {
	Type string
	// AWS like credential that stores [hash-based message authentication code (HMAC) keys](https://cloud.google.com/storage/docs/authentication/hmackeys) with write access to the GCS bucket.
	Aws *AwsCredential
	// Reference to existing AWS Access Keys.
	AwsId AwsCredentialId
}

func (g *GcsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (g GcsCredential) MarshalJSON() ([]byte, error) {
	if g.Aws != nil {
		return core.MarshalJSONWithExtraProperty(g.Aws, "type", "aws")
	}
	if g.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: g.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GcsCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (g *GcsCredential) Accept(visitor GcsCredentialVisitor) error {
	if g.Aws != nil {
		return visitor.VisitAws(g.Aws)
	}
	if g.AwsId != "" {
		return visitor.VisitAwsId(g.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleChronicleCredential struct {
	Type string
	// OAuth client credentials for a Google Cloud Service Account with permissions for Google Security Operations (formerly Google Chronicle).
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (g *GoogleChronicleCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (g GoogleChronicleCredential) MarshalJSON() ([]byte, error) {
	if g.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(g.OAuthClient, "type", "o_auth_client")
	}
	if g.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: g.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleChronicleCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (g *GoogleChronicleCredential) Accept(visitor GoogleChronicleCredentialVisitor) error {
	if g.OAuthClient != nil {
		return visitor.VisitOAuthClient(g.OAuthClient)
	}
	if g.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(g.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleCredential struct {
	Type string
	// Configuration when creating new Client Credentials.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (g *GoogleCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (g GoogleCredential) MarshalJSON() ([]byte, error) {
	if g.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(g.OAuthClient, "type", "o_auth_client")
	}
	if g.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: g.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (g *GoogleCredential) Accept(visitor GoogleCredentialVisitor) error {
	if g.OAuthClient != nil {
		return visitor.VisitOAuthClient(g.OAuthClient)
	}
	if g.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(g.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleServiceAccountCredential struct {
	Type string
	// OAuth client credentials for a Google Cloud Service Account with permissions for Google Security Operations.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (g *GoogleServiceAccountCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (g GoogleServiceAccountCredential) MarshalJSON() ([]byte, error) {
	if g.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(g.OAuthClient, "type", "o_auth_client")
	}
	if g.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: g.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleServiceAccountCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (g *GoogleServiceAccountCredential) Accept(visitor GoogleServiceAccountCredentialVisitor) error {
	if g.OAuthClient != nil {
		return visitor.VisitOAuthClient(g.OAuthClient)
	}
	if g.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(g.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

// Configuration for Microsoft Entra ID.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/entra-id-setup)
type IdentityEntraId struct {
	Credential *EntraIdCredential `json:"credential" url:"credential"`
	// Azure Directory (tenant) identifier.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// Base URL for the the Microsoft Graph API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityEntraId) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityEntraId) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityEntraId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityEntraId(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IdentityEntraId) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for Google Workspace.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-workspace-setup)
type IdentityGoogle struct {
	// Client email associated with the service account key.
	ClientEmail string            `json:"client_email" url:"client_email"`
	Credential  *GoogleCredential `json:"credential" url:"credential"`
	// Email address of the user that the service account is impersonating for domain-wide delegation. For more information, see [this Google support article](https://support.google.com/a/answer/162106).
	Delegate string `json:"delegate" url:"delegate"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityGoogle) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityGoogle) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityGoogle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityGoogle(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IdentityGoogle) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for Okta Identity.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/okta-identity-setup)
type IdentityOkta struct {
	Credential *OktaCredential `json:"credential" url:"credential"`
	// Base URL for the Okta API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityOkta) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityOkta) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityOkta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityOkta(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IdentityOkta) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for PingOne Cloud Platform.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/ping-identity-setup)
type IdentityPingOne struct {
	// Base URL for making authentication requests to PingOne.
	AuthUrl string `json:"auth_url" url:"auth_url"`
	// Client ID for the application set up as a worker.
	ClientId   string             `json:"client_id" url:"client_id"`
	Credential *PingOneCredential `json:"credential" url:"credential"`
	// The organization ID that the client app is a part of.
	OrganizationId string `json:"organization_id" url:"organization_id"`
	// Base URL for the PingOne API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityPingOne) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityPingOne) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityPingOne
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityPingOne(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IdentityPingOne) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JiraCredential struct {
	Type string
	// Configuration when creating new Basic Credentials.
	Basic *BasicCredential
	// Reference to existing Basic Credentials.
	BasicId BasicCredentialId
}

func (j *JiraCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", j)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		j.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (j JiraCredential) MarshalJSON() ([]byte, error) {
	if j.Basic != nil {
		return core.MarshalJSONWithExtraProperty(j.Basic, "type", "basic")
	}
	if j.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: j.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", j)
}

type JiraCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (j *JiraCredential) Accept(visitor JiraCredentialVisitor) error {
	if j.Basic != nil {
		return visitor.VisitBasic(j.Basic)
	}
	if j.BasicId != "" {
		return visitor.VisitBasicId(j.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", j)
}

type MalwarebytesCredential struct {
	Type string
	// Configuration when creating new Client Credentials.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (m *MalwarebytesCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	m.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", m)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		m.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		m.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (m MalwarebytesCredential) MarshalJSON() ([]byte, error) {
	if m.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(m.OAuthClient, "type", "o_auth_client")
	}
	if m.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: m.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", m)
}

type MalwarebytesCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (m *MalwarebytesCredential) Accept(visitor MalwarebytesCredentialVisitor) error {
	if m.OAuthClient != nil {
		return visitor.VisitOAuthClient(m.OAuthClient)
	}
	if m.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(m.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", m)
}

// Configuration for Atlassian Jira.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/jira-notification-setup)
type NotificationsJira struct {
	Credential *JiraCredential `json:"credential" url:"credential"`
	// Base URL for the Jira API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsJira) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsJira) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsJira
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsJira(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsJira) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for the Synqly mock in-memory SIEM Provider. This provider is for testing purposes only and does not retain noficiations pushed to it.
type NotificationsMock struct {
	// The channel to send notifications to.
	Channel *string `json:"channel,omitempty" url:"channel,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsMock) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsMock) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsMock) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for Slack.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/slack-notification-setup)
type NotificationsSlack struct {
	// Channel to send notifications to. Must be a valid existing channel.
	Channel    string           `json:"channel" url:"channel"`
	Credential *SlackCredential `json:"credential" url:"credential"`
	// Base URL for the Slack API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsSlack) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsSlack) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsSlack
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsSlack(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsSlack) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for the Slack Notification Provider using Incoming Webhooks.
// Incoming Webhooks are a way to post messages from apps into Slack. The can not be used for any other actions, such as reading or deleting messages.
type NotificationsSlackWebhook struct {
	WebhookUrl *SlackWebhookCredential `json:"webhook_url" url:"webhook_url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsSlackWebhook) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsSlackWebhook) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsSlackWebhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsSlackWebhook(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsSlackWebhook) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for Microsoft Teams.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/teams-notification-setup)
type NotificationsTeams struct {
	// Identifier of the channel to send messages to.
	ChannelId  string           `json:"channel_id" url:"channel_id"`
	Credential *TeamsCredential `json:"credential" url:"credential"`
	// URL of the endpoint to send messages to. Only required if OAuth Client Credentials are used for authentication.
	Endpoint *string `json:"endpoint,omitempty" url:"endpoint,omitempty"`
	// Identifier of the team to send messages to.
	TeamId string `json:"team_id" url:"team_id"`
	// Azure Directory (tenant) ID. Only required if OAuth Client Credentials are used for authentication.
	TenantId *string `json:"tenant_id,omitempty" url:"tenant_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsTeams) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsTeams) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsTeams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsTeams(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsTeams) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NozomiVantageCredential struct {
	Type string
	// API key name and secret value of your Nozomi Vantage API token.
	Basic *BasicCredential
	// Reference to existing API Token.
	BasicId BasicCredentialId
}

func (n *NozomiVantageCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		n.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (n NozomiVantageCredential) MarshalJSON() ([]byte, error) {
	if n.Basic != nil {
		return core.MarshalJSONWithExtraProperty(n.Basic, "type", "basic")
	}
	if n.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: n.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NozomiVantageCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (n *NozomiVantageCredential) Accept(visitor NozomiVantageCredentialVisitor) error {
	if n.Basic != nil {
		return visitor.VisitBasic(n.Basic)
	}
	if n.BasicId != "" {
		return visitor.VisitBasicId(n.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NucleusCredential struct {
	Type string
	// Configuration when creating new API Key.
	Token *TokenCredential
	// Reference to existing API Key.
	TokenId TokenCredentialId
}

func (n *NucleusCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		n.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (n NucleusCredential) MarshalJSON() ([]byte, error) {
	if n.Token != nil {
		return core.MarshalJSONWithExtraProperty(n.Token, "type", "token")
	}
	if n.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: n.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NucleusCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (n *NucleusCredential) Accept(visitor NucleusCredentialVisitor) error {
	if n.Token != nil {
		return visitor.VisitToken(n.Token)
	}
	if n.TokenId != "" {
		return visitor.VisitTokenId(n.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

type OktaCredential struct {
	Type string
	// OAuth 2.0 Token URL, Client ID, and Client Secret for a Synqly Identity Connector API service application.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
	// Token to authenticate with Okta. Follow [this guide to generate an API token](https://developer.okta.com/docs/guides/create-an-api-token). The token must have access to list records in the system audit log. (Not for production use. Use `o_auth_client` instead)
	Token *TokenCredential
	// Reference to existing Token.
	TokenId TokenCredentialId
}

func (o *OktaCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", o)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		o.OAuthClientId = valueUnmarshaler.OAuthClientId
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		o.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (o OktaCredential) MarshalJSON() ([]byte, error) {
	if o.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(o.OAuthClient, "type", "o_auth_client")
	}
	if o.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: o.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if o.Token != nil {
		return core.MarshalJSONWithExtraProperty(o.Token, "type", "token")
	}
	if o.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: o.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", o)
}

type OktaCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (o *OktaCredential) Accept(visitor OktaCredentialVisitor) error {
	if o.OAuthClient != nil {
		return visitor.VisitOAuthClient(o.OAuthClient)
	}
	if o.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(o.OAuthClientId)
	}
	if o.Token != nil {
		return visitor.VisitToken(o.Token)
	}
	if o.TokenId != "" {
		return visitor.VisitTokenId(o.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", o)
}

type OpenSearchCredential struct {
	Type string
	// Basic authentication credentials for OpenSearch.
	Basic *BasicCredential
	// Reference to existing Basic Credentials.
	BasicId BasicCredentialId
}

func (o *OpenSearchCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", o)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		o.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (o OpenSearchCredential) MarshalJSON() ([]byte, error) {
	if o.Basic != nil {
		return core.MarshalJSONWithExtraProperty(o.Basic, "type", "basic")
	}
	if o.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: o.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", o)
}

type OpenSearchCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (o *OpenSearchCredential) Accept(visitor OpenSearchCredentialVisitor) error {
	if o.Basic != nil {
		return visitor.VisitBasic(o.Basic)
	}
	if o.BasicId != "" {
		return visitor.VisitBasicId(o.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", o)
}

type PagerDutyCredential struct {
	Type string
	// Configuration when creating new API Key.
	Token *TokenCredential
	// Reference to existing API Key.
	TokenId TokenCredentialId
}

func (p *PagerDutyCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (p PagerDutyCredential) MarshalJSON() ([]byte, error) {
	if p.Token != nil {
		return core.MarshalJSONWithExtraProperty(p.Token, "type", "token")
	}
	if p.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: p.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PagerDutyCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (p *PagerDutyCredential) Accept(visitor PagerDutyCredentialVisitor) error {
	if p.Token != nil {
		return visitor.VisitToken(p.Token)
	}
	if p.TokenId != "" {
		return visitor.VisitTokenId(p.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PingOneCredential struct {
	Type string
	// Configuration when creating new Token.
	Token *TokenCredential
	// Reference to existing Token.
	TokenId TokenCredentialId
}

func (p *PingOneCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (p PingOneCredential) MarshalJSON() ([]byte, error) {
	if p.Token != nil {
		return core.MarshalJSONWithExtraProperty(p.Token, "type", "token")
	}
	if p.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: p.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PingOneCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (p *PingOneCredential) Accept(visitor PingOneCredentialVisitor) error {
	if p.Token != nil {
		return visitor.VisitToken(p.Token)
	}
	if p.TokenId != "" {
		return visitor.VisitTokenId(p.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type ProviderConfig struct {
	Type string
	// Configuration for Armis Centrix™ for Asset Management and Security.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/armis-centrix-setup)
	AssetsArmisCentrix *AssetsArmisCentrix
	// Configuration for a mocked Armis Centrix Assets Provider
	AssetsArmisCentrixMock *AssetsArmisCentrixMock
	// Configuration for the Axonius Assets Provider
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/axonius-asset-setup)
	AssetsAxonius *AssetsAxonius
	// Configuration for CrowdStrike Falcon as an Assets Provider
	AssetsCrowdstrike *AssetsCrowdStrike
	// Configuration for Nozomi Vantage.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/nozomi-vantage-setup)
	AssetsNozomiVantage *AssetsNozomiVantage
	// Configuration for a mocked Nozomi Vantage provider
	AssetsNozomiVantageMock *AssetsNozomiVantageMock
	// Configuration for Qualys Cloud Platform as an Assets Provider
	AssetsQualysCloud *AssetsQualysCloud
	// Configuration for a mock Qualys Cloud Platform as an Assets Provider
	AssetsQualysCloudMock *AssetsQualysCloudMock
	// Configuration for ServiceNow Configuration Management Database (CMDB).
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/servicenow-assets-setup)
	AssetsServicenow *AssetsServiceNow
	// Configuration for a mocked ServiceNow as an Assets Provider
	AssetsServicenowMock *AssetsServiceNowMock
	// Configuration for the Sevco Assets Provider
	AssetsSevco *AssetsSevco
	// Configuration for Tanium Cloud as an Assets Provider
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/tanium-setup)
	AssetsTaniumCloud *AssetsTaniumCloud
	// Configuration for a mocked Tanium Cloud as an Assets Provider
	AssetsTaniumCloudMock *AssetsTaniumCloudMock
	// Configuration for the CrowdStrike Cloud Security Provider
	CloudsecurityCrowdstrike *CloudSecurityCrowdStrike
	// Configuration for the Microsoft Defender for Cloud Provider
	CloudsecurityDefender *CloudSecurityDefender
	// Configuration for CrowdStrike Falcon® Insight EDR.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/crowdstrike-edr-setup)
	EdrCrowdstrike *EdrCrowdStrike
	// Configuration for Microsoft Defender for Endpoint.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/defender-setup)
	EdrDefender *EdrDefender
	// Configuration for ThreatDown Endpoint Detection & Response.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/malwarebytes-setup)
	EdrMalwarebytes *EdrMalwarebytes
	// Configuration for SentinelOne Singularity™ Endpoint.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/sentinelone-setup)
	EdrSentinelone *EdrSentinelOne
	// Configuration for Sophos Endpoint.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/sophos-setup)
	EdrSophos *EdrSophos
	// Configuration for Tanium Cloud as a EDR Provider
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/tanium-setup)
	EdrTanium *EdrTanium
	// Configuration for Microsoft Entra ID.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/entra-id-setup)
	IdentityEntraId *IdentityEntraId
	// Configuration for Google Workspace.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-workspace-setup)
	IdentityGoogle *IdentityGoogle
	// Configuration for Okta Identity.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/okta-identity-setup)
	IdentityOkta *IdentityOkta
	// Configuration for PingOne Cloud Platform.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/ping-identity-setup)
	IdentityPingone *IdentityPingOne
	// Configuration for Atlassian Jira.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/jira-notification-setup)
	NotificationsJira *NotificationsJira
	// Configuration for the Synqly mock in-memory SIEM Provider. This provider is for testing purposes only and does not retain noficiations pushed to it.
	NotificationsMockNotifications *NotificationsMock
	// Configuration for Slack.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/slack-notification-setup)
	NotificationsSlack *NotificationsSlack
	// Configuration for the Slack Notification Provider using Incoming Webhooks.
	// Incoming Webhooks are a way to post messages from apps into Slack. The can not be used for any other actions, such as reading or deleting messages.
	NotificationsSlackWebhook *NotificationsSlackWebhook
	// Configuration for Microsoft Teams.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/teams-notification-setup)
	NotificationsTeams *NotificationsTeams
	// Configuration for CrowdStrike Falcon® Next-Gen SIEM.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/crowdstrike-siem-setup)
	SiemCrowdstrike *SiemCrowdstrike
	// Configuration for Elastic SIEM.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/elastic-setup)
	SiemElasticsearch *SiemElasticsearch
	// Configuration for Google Security Operations (formerly Google Chronicle) as a SIEM Provider connecting via the older Backstory and Malachite APIs.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-chronicle-setup)
	SiemGoogleChronicle *SiemGoogleChronicle
	// Configuration for Google Security Operations (formerly Google Chronicle) as a SIEM Provider.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-security-operations-siem-setup)
	SiemGoogleSecurityOperations *SiemGoogleSecurityOperations
	// Configuration for the Synqly mock in-memory SIEM Provider. This provider is for testing purposes only and does not retain events pushed to it.
	SiemMockSiem *SiemMock
	// Configuration for OpenSearch search and analytics engine. Supports both managed and self-hosted OpenSearch deployments
	SiemOpensearch *SiemOpenSearch
	// Configuration for IBM QRadar SIEM.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/qradar-setup)
	SiemQRadar *SiemQRadar
	// Configuration for Rapid7 InsightIDR.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/rapid7-idr-setup)
	SiemRapid7Insightidr *SiemRapid7InsightIdr
	// Configuration for Microsoft Sentinel SIEM Product.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/microsoft-sentinel-siem-setup)
	SiemSentinel *SiemSentinel
	// Configuration for Splunk Enterprise Security.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/splunk-setup)
	SiemSplunk *SiemSplunk
	// Configuration for Sumo Logic Cloud SIEM.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/sumo-logic-setup)
	SiemSumoLogic *SiemSumoLogic
	// Configuration for Amazon Security Lake as a Sink provider. Events are written directly to an AWS S3 bucket in Apache Parquet format.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/amazon-security-lake-sink-setup)
	SinkAwsSecurityLake *SinkAwsSecurityLake
	// Configuration for Amazon Simple Queue Service (SQS).
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/aws-sqs-sink-setup)
	SinkAwsSqs *SinkAwsSqs
	// Configuration for Azure Monitor Logs as a Sink Provider. Azure Monitor Logs is a feature of Azure Monitor that collects and organizes log and performance data from monitored resources.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/azure-monitor-logs)
	SinkAzureMonitorLogs *SinkAzureMonitorLogs
	// Configuration for CrowdStrike Falcon® Next-Gen SIEM (HEC).
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/crowdstrike-sink-setup)
	SinkCrowdstrikeHec *SinkCrowdstrikeHec
	// Configuration for Elasticsearch.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/elastic-setup)
	SinkElasticsearch *SinkElasticsearch
	// Configuration for Google Security Operations (formerly Google Chronicle) as a Sink Provider connecting via the older Malachite API.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-chronicle-setup)
	SinkGoogleSecOps *SinkGoogleSecOps
	// Configuration for Google Security Operations (formerly Google Chronicle) as a Sink Provider.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-security-operations-sink-setup)
	SinkGoogleSecurityOperations *SinkGoogleSecurityOperations
	// Configuration for the Synqly mock in-memory Sink Provider. This provider is for testing purposes only and does not retain events pushed to it.
	SinkMockSink *SinkMock
	// Configuration for OpenSearch search and analytics engine. Supports both managed and self-hosted OpenSearch deployments
	SinkOpensearch *SinkOpenSearch
	// Configuration for Splunk as a Sink provider. Allows sending data to Splunk using an HTTP Event Collector (HEC).
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/splunk-setup)
	SinkSplunk *SinkSplunk
	// Configuration for Amazon S3.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/aws-s3-storage-setup)
	StorageAwsS3 *StorageAwsS3
	// Configuration for Azure Blob Storage as a Storage Provider
	StorageAzureBlob *StorageAzureBlob
	// Configuration for Google Cloud Storage for storing unstructured data
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-gcs-storage-setup)
	StorageGcs *StorageGcs
	// Configuration for the Synqly mock in-memory storage Provider. This provider is for testing purposes only and does not retain files pushed to it.
	StorageMockStorage *StorageMock
	// Configuration for Autotask Operations Cloud.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/autotask-ticketing-setup)
	TicketingAutotask *TicketingAutotask
	// Configuration for Freshdesk.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/freshdesk-ticketing-setup)
	TicketingFreshdesk *TicketingFreshdesk
	// Configuration for Atlassian Jira.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/jira-ticketing-setup)
	TicketingJira *TicketingJira
	// Configuration for the Synqly mock in-memory ticketing Provider. This provider is for testing purposes only. It retains tickets for a limited time and does not persist them for long-term usage.
	TicketingMockTicketing *TicketingMock
	// Configuration for PagerDuty Operations Cloud.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/pagerduty-ticketing-setup)
	TicketingPagerduty *TicketingPagerDuty
	// Configuration for ServiceNow IT Service Management (ITSM).
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/servicenow-ticketing-setup)
	TicketingServicenow *TicketingServiceNow
	// Configuration for ServiceNow Security Incident Response (SIR).
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/servicenow-ticketing-setup)
	TicketingServicenowSir *TicketingServiceNowSir
	// Configuration for Torq.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/torq-ticketing-setup)
	TicketingTorq *TicketingTorq
	// Configuration for Zendesk as a Ticketing Provider
	TicketingZendesk *TicketingZendesk
	// Configuration for CrowdStrike Falcon® Spotlight.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/crowdstrike-vulns-setup)
	VulnerabilitiesCrowdstrike *VulnerabilitiesCrowdStrike
	// Configuration for Nucleus Vulnerability Management.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/nucleus-vulns-setup)
	VulnerabilitiesNucleus *VulnerabilitiesNucleus
	// Configuration for Qualys Vulnerability Management, Detection & Response (VMDR).
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/qualys-vulns-setup)
	VulnerabilitiesQualysCloud *VulnerabilitiesQualysCloud
	// Configuration for a mocked Qualys Cloud Platform as a Vulnerabilities Provider
	VulnerabilitiesQualysCloudMock *VulnerabilitiesQualysCloudMock
	// Configuration for Rapid7 InsightVM.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/rapid7-vulns-setup)
	VulnerabilitiesRapid7InsightCloud *VulnerabilitiesRapid7InsightCloud
	// Configuration for a mocked Rapid7 Insight Cloud as a Vulnerabilities Provider
	VulnerabilitiesRapid7InsightCloudMock *VulnerabilitiesRapid7InsightCloudMock
	// Configuration for Tanium Vulnerability Management.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/tanium-setup)
	VulnerabilitiesTaniumCloud *VulnerabilitiesTaniumCloud
	// Configuration for a mock Tanium Cloud as a Vulnerabilities Provider
	VulnerabilitiesTaniumCloudMock *VulnerabilitiesTaniumCloudMock
	// Configuration for Tenable Vulnerability Management.
	//
	// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/tenable-vulns-setup)
	VulnerabilitiesTenableCloud *VulnerabilitiesTenableCloud
}

func (p *ProviderConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "assets_armis_centrix":
		value := new(AssetsArmisCentrix)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsArmisCentrix = value
	case "assets_armis_centrix_mock":
		value := new(AssetsArmisCentrixMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsArmisCentrixMock = value
	case "assets_axonius":
		value := new(AssetsAxonius)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsAxonius = value
	case "assets_crowdstrike":
		value := new(AssetsCrowdStrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsCrowdstrike = value
	case "assets_nozomi_vantage":
		value := new(AssetsNozomiVantage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsNozomiVantage = value
	case "assets_nozomi_vantage_mock":
		value := new(AssetsNozomiVantageMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsNozomiVantageMock = value
	case "assets_qualys_cloud":
		value := new(AssetsQualysCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsQualysCloud = value
	case "assets_qualys_cloud_mock":
		value := new(AssetsQualysCloudMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsQualysCloudMock = value
	case "assets_servicenow":
		value := new(AssetsServiceNow)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsServicenow = value
	case "assets_servicenow_mock":
		value := new(AssetsServiceNowMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsServicenowMock = value
	case "assets_sevco":
		value := new(AssetsSevco)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsSevco = value
	case "assets_tanium_cloud":
		value := new(AssetsTaniumCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsTaniumCloud = value
	case "assets_tanium_cloud_mock":
		value := new(AssetsTaniumCloudMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsTaniumCloudMock = value
	case "cloudsecurity_crowdstrike":
		value := new(CloudSecurityCrowdStrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.CloudsecurityCrowdstrike = value
	case "cloudsecurity_defender":
		value := new(CloudSecurityDefender)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.CloudsecurityDefender = value
	case "edr_crowdstrike":
		value := new(EdrCrowdStrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrCrowdstrike = value
	case "edr_defender":
		value := new(EdrDefender)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrDefender = value
	case "edr_malwarebytes":
		value := new(EdrMalwarebytes)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrMalwarebytes = value
	case "edr_sentinelone":
		value := new(EdrSentinelOne)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrSentinelone = value
	case "edr_sophos":
		value := new(EdrSophos)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrSophos = value
	case "edr_tanium":
		value := new(EdrTanium)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrTanium = value
	case "identity_entra_id":
		value := new(IdentityEntraId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityEntraId = value
	case "identity_google":
		value := new(IdentityGoogle)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityGoogle = value
	case "identity_okta":
		value := new(IdentityOkta)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityOkta = value
	case "identity_pingone":
		value := new(IdentityPingOne)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityPingone = value
	case "notifications_jira":
		value := new(NotificationsJira)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsJira = value
	case "notifications_mock_notifications":
		value := new(NotificationsMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsMockNotifications = value
	case "notifications_slack":
		value := new(NotificationsSlack)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsSlack = value
	case "notifications_slack_webhook":
		value := new(NotificationsSlackWebhook)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsSlackWebhook = value
	case "notifications_teams":
		value := new(NotificationsTeams)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsTeams = value
	case "siem_crowdstrike":
		value := new(SiemCrowdstrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemCrowdstrike = value
	case "siem_elasticsearch":
		value := new(SiemElasticsearch)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemElasticsearch = value
	case "siem_google_chronicle":
		value := new(SiemGoogleChronicle)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemGoogleChronicle = value
	case "siem_google_security_operations":
		value := new(SiemGoogleSecurityOperations)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemGoogleSecurityOperations = value
	case "siem_mock_siem":
		value := new(SiemMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemMockSiem = value
	case "siem_opensearch":
		value := new(SiemOpenSearch)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemOpensearch = value
	case "siem_q_radar":
		value := new(SiemQRadar)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemQRadar = value
	case "siem_rapid7_insightidr":
		value := new(SiemRapid7InsightIdr)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemRapid7Insightidr = value
	case "siem_sentinel":
		value := new(SiemSentinel)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemSentinel = value
	case "siem_splunk":
		value := new(SiemSplunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemSplunk = value
	case "siem_sumo_logic":
		value := new(SiemSumoLogic)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemSumoLogic = value
	case "sink_aws_security_lake":
		value := new(SinkAwsSecurityLake)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAwsSecurityLake = value
	case "sink_aws_sqs":
		value := new(SinkAwsSqs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAwsSqs = value
	case "sink_azure_monitor_logs":
		value := new(SinkAzureMonitorLogs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAzureMonitorLogs = value
	case "sink_crowdstrike_hec":
		value := new(SinkCrowdstrikeHec)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkCrowdstrikeHec = value
	case "sink_elasticsearch":
		value := new(SinkElasticsearch)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkElasticsearch = value
	case "sink_google_sec_ops":
		value := new(SinkGoogleSecOps)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkGoogleSecOps = value
	case "sink_google_security_operations":
		value := new(SinkGoogleSecurityOperations)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkGoogleSecurityOperations = value
	case "sink_mock_sink":
		value := new(SinkMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkMockSink = value
	case "sink_opensearch":
		value := new(SinkOpenSearch)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkOpensearch = value
	case "sink_splunk":
		value := new(SinkSplunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkSplunk = value
	case "storage_aws_s3":
		value := new(StorageAwsS3)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageAwsS3 = value
	case "storage_azure_blob":
		value := new(StorageAzureBlob)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageAzureBlob = value
	case "storage_gcs":
		value := new(StorageGcs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageGcs = value
	case "storage_mock_storage":
		value := new(StorageMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageMockStorage = value
	case "ticketing_autotask":
		value := new(TicketingAutotask)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingAutotask = value
	case "ticketing_freshdesk":
		value := new(TicketingFreshdesk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingFreshdesk = value
	case "ticketing_jira":
		value := new(TicketingJira)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingJira = value
	case "ticketing_mock_ticketing":
		value := new(TicketingMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingMockTicketing = value
	case "ticketing_pagerduty":
		value := new(TicketingPagerDuty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingPagerduty = value
	case "ticketing_servicenow":
		value := new(TicketingServiceNow)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingServicenow = value
	case "ticketing_servicenow_sir":
		value := new(TicketingServiceNowSir)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingServicenowSir = value
	case "ticketing_torq":
		value := new(TicketingTorq)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingTorq = value
	case "ticketing_zendesk":
		value := new(TicketingZendesk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingZendesk = value
	case "vulnerabilities_crowdstrike":
		value := new(VulnerabilitiesCrowdStrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesCrowdstrike = value
	case "vulnerabilities_nucleus":
		value := new(VulnerabilitiesNucleus)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesNucleus = value
	case "vulnerabilities_qualys_cloud":
		value := new(VulnerabilitiesQualysCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesQualysCloud = value
	case "vulnerabilities_qualys_cloud_mock":
		value := new(VulnerabilitiesQualysCloudMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesQualysCloudMock = value
	case "vulnerabilities_rapid7_insight_cloud":
		value := new(VulnerabilitiesRapid7InsightCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesRapid7InsightCloud = value
	case "vulnerabilities_rapid7_insight_cloud_mock":
		value := new(VulnerabilitiesRapid7InsightCloudMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesRapid7InsightCloudMock = value
	case "vulnerabilities_tanium_cloud":
		value := new(VulnerabilitiesTaniumCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesTaniumCloud = value
	case "vulnerabilities_tanium_cloud_mock":
		value := new(VulnerabilitiesTaniumCloudMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesTaniumCloudMock = value
	case "vulnerabilities_tenable_cloud":
		value := new(VulnerabilitiesTenableCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesTenableCloud = value
	}
	return nil
}

func (p ProviderConfig) MarshalJSON() ([]byte, error) {
	if p.AssetsArmisCentrix != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsArmisCentrix, "type", "assets_armis_centrix")
	}
	if p.AssetsArmisCentrixMock != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsArmisCentrixMock, "type", "assets_armis_centrix_mock")
	}
	if p.AssetsAxonius != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsAxonius, "type", "assets_axonius")
	}
	if p.AssetsCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsCrowdstrike, "type", "assets_crowdstrike")
	}
	if p.AssetsNozomiVantage != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsNozomiVantage, "type", "assets_nozomi_vantage")
	}
	if p.AssetsNozomiVantageMock != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsNozomiVantageMock, "type", "assets_nozomi_vantage_mock")
	}
	if p.AssetsQualysCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsQualysCloud, "type", "assets_qualys_cloud")
	}
	if p.AssetsQualysCloudMock != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsQualysCloudMock, "type", "assets_qualys_cloud_mock")
	}
	if p.AssetsServicenow != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsServicenow, "type", "assets_servicenow")
	}
	if p.AssetsServicenowMock != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsServicenowMock, "type", "assets_servicenow_mock")
	}
	if p.AssetsSevco != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsSevco, "type", "assets_sevco")
	}
	if p.AssetsTaniumCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsTaniumCloud, "type", "assets_tanium_cloud")
	}
	if p.AssetsTaniumCloudMock != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsTaniumCloudMock, "type", "assets_tanium_cloud_mock")
	}
	if p.CloudsecurityCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.CloudsecurityCrowdstrike, "type", "cloudsecurity_crowdstrike")
	}
	if p.CloudsecurityDefender != nil {
		return core.MarshalJSONWithExtraProperty(p.CloudsecurityDefender, "type", "cloudsecurity_defender")
	}
	if p.EdrCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrCrowdstrike, "type", "edr_crowdstrike")
	}
	if p.EdrDefender != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrDefender, "type", "edr_defender")
	}
	if p.EdrMalwarebytes != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrMalwarebytes, "type", "edr_malwarebytes")
	}
	if p.EdrSentinelone != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrSentinelone, "type", "edr_sentinelone")
	}
	if p.EdrSophos != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrSophos, "type", "edr_sophos")
	}
	if p.EdrTanium != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrTanium, "type", "edr_tanium")
	}
	if p.IdentityEntraId != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityEntraId, "type", "identity_entra_id")
	}
	if p.IdentityGoogle != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityGoogle, "type", "identity_google")
	}
	if p.IdentityOkta != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityOkta, "type", "identity_okta")
	}
	if p.IdentityPingone != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityPingone, "type", "identity_pingone")
	}
	if p.NotificationsJira != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsJira, "type", "notifications_jira")
	}
	if p.NotificationsMockNotifications != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsMockNotifications, "type", "notifications_mock_notifications")
	}
	if p.NotificationsSlack != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsSlack, "type", "notifications_slack")
	}
	if p.NotificationsSlackWebhook != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsSlackWebhook, "type", "notifications_slack_webhook")
	}
	if p.NotificationsTeams != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsTeams, "type", "notifications_teams")
	}
	if p.SiemCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemCrowdstrike, "type", "siem_crowdstrike")
	}
	if p.SiemElasticsearch != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemElasticsearch, "type", "siem_elasticsearch")
	}
	if p.SiemGoogleChronicle != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemGoogleChronicle, "type", "siem_google_chronicle")
	}
	if p.SiemGoogleSecurityOperations != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemGoogleSecurityOperations, "type", "siem_google_security_operations")
	}
	if p.SiemMockSiem != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemMockSiem, "type", "siem_mock_siem")
	}
	if p.SiemOpensearch != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemOpensearch, "type", "siem_opensearch")
	}
	if p.SiemQRadar != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemQRadar, "type", "siem_q_radar")
	}
	if p.SiemRapid7Insightidr != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemRapid7Insightidr, "type", "siem_rapid7_insightidr")
	}
	if p.SiemSentinel != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemSentinel, "type", "siem_sentinel")
	}
	if p.SiemSplunk != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemSplunk, "type", "siem_splunk")
	}
	if p.SiemSumoLogic != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemSumoLogic, "type", "siem_sumo_logic")
	}
	if p.SinkAwsSecurityLake != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAwsSecurityLake, "type", "sink_aws_security_lake")
	}
	if p.SinkAwsSqs != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAwsSqs, "type", "sink_aws_sqs")
	}
	if p.SinkAzureMonitorLogs != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAzureMonitorLogs, "type", "sink_azure_monitor_logs")
	}
	if p.SinkCrowdstrikeHec != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkCrowdstrikeHec, "type", "sink_crowdstrike_hec")
	}
	if p.SinkElasticsearch != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkElasticsearch, "type", "sink_elasticsearch")
	}
	if p.SinkGoogleSecOps != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkGoogleSecOps, "type", "sink_google_sec_ops")
	}
	if p.SinkGoogleSecurityOperations != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkGoogleSecurityOperations, "type", "sink_google_security_operations")
	}
	if p.SinkMockSink != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkMockSink, "type", "sink_mock_sink")
	}
	if p.SinkOpensearch != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkOpensearch, "type", "sink_opensearch")
	}
	if p.SinkSplunk != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkSplunk, "type", "sink_splunk")
	}
	if p.StorageAwsS3 != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageAwsS3, "type", "storage_aws_s3")
	}
	if p.StorageAzureBlob != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageAzureBlob, "type", "storage_azure_blob")
	}
	if p.StorageGcs != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageGcs, "type", "storage_gcs")
	}
	if p.StorageMockStorage != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageMockStorage, "type", "storage_mock_storage")
	}
	if p.TicketingAutotask != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingAutotask, "type", "ticketing_autotask")
	}
	if p.TicketingFreshdesk != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingFreshdesk, "type", "ticketing_freshdesk")
	}
	if p.TicketingJira != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingJira, "type", "ticketing_jira")
	}
	if p.TicketingMockTicketing != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingMockTicketing, "type", "ticketing_mock_ticketing")
	}
	if p.TicketingPagerduty != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingPagerduty, "type", "ticketing_pagerduty")
	}
	if p.TicketingServicenow != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingServicenow, "type", "ticketing_servicenow")
	}
	if p.TicketingServicenowSir != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingServicenowSir, "type", "ticketing_servicenow_sir")
	}
	if p.TicketingTorq != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingTorq, "type", "ticketing_torq")
	}
	if p.TicketingZendesk != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingZendesk, "type", "ticketing_zendesk")
	}
	if p.VulnerabilitiesCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesCrowdstrike, "type", "vulnerabilities_crowdstrike")
	}
	if p.VulnerabilitiesNucleus != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesNucleus, "type", "vulnerabilities_nucleus")
	}
	if p.VulnerabilitiesQualysCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesQualysCloud, "type", "vulnerabilities_qualys_cloud")
	}
	if p.VulnerabilitiesQualysCloudMock != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesQualysCloudMock, "type", "vulnerabilities_qualys_cloud_mock")
	}
	if p.VulnerabilitiesRapid7InsightCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesRapid7InsightCloud, "type", "vulnerabilities_rapid7_insight_cloud")
	}
	if p.VulnerabilitiesRapid7InsightCloudMock != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesRapid7InsightCloudMock, "type", "vulnerabilities_rapid7_insight_cloud_mock")
	}
	if p.VulnerabilitiesTaniumCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesTaniumCloud, "type", "vulnerabilities_tanium_cloud")
	}
	if p.VulnerabilitiesTaniumCloudMock != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesTaniumCloudMock, "type", "vulnerabilities_tanium_cloud_mock")
	}
	if p.VulnerabilitiesTenableCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesTenableCloud, "type", "vulnerabilities_tenable_cloud")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type ProviderConfigVisitor interface {
	VisitAssetsArmisCentrix(*AssetsArmisCentrix) error
	VisitAssetsArmisCentrixMock(*AssetsArmisCentrixMock) error
	VisitAssetsAxonius(*AssetsAxonius) error
	VisitAssetsCrowdstrike(*AssetsCrowdStrike) error
	VisitAssetsNozomiVantage(*AssetsNozomiVantage) error
	VisitAssetsNozomiVantageMock(*AssetsNozomiVantageMock) error
	VisitAssetsQualysCloud(*AssetsQualysCloud) error
	VisitAssetsQualysCloudMock(*AssetsQualysCloudMock) error
	VisitAssetsServicenow(*AssetsServiceNow) error
	VisitAssetsServicenowMock(*AssetsServiceNowMock) error
	VisitAssetsSevco(*AssetsSevco) error
	VisitAssetsTaniumCloud(*AssetsTaniumCloud) error
	VisitAssetsTaniumCloudMock(*AssetsTaniumCloudMock) error
	VisitCloudsecurityCrowdstrike(*CloudSecurityCrowdStrike) error
	VisitCloudsecurityDefender(*CloudSecurityDefender) error
	VisitEdrCrowdstrike(*EdrCrowdStrike) error
	VisitEdrDefender(*EdrDefender) error
	VisitEdrMalwarebytes(*EdrMalwarebytes) error
	VisitEdrSentinelone(*EdrSentinelOne) error
	VisitEdrSophos(*EdrSophos) error
	VisitEdrTanium(*EdrTanium) error
	VisitIdentityEntraId(*IdentityEntraId) error
	VisitIdentityGoogle(*IdentityGoogle) error
	VisitIdentityOkta(*IdentityOkta) error
	VisitIdentityPingone(*IdentityPingOne) error
	VisitNotificationsJira(*NotificationsJira) error
	VisitNotificationsMockNotifications(*NotificationsMock) error
	VisitNotificationsSlack(*NotificationsSlack) error
	VisitNotificationsSlackWebhook(*NotificationsSlackWebhook) error
	VisitNotificationsTeams(*NotificationsTeams) error
	VisitSiemCrowdstrike(*SiemCrowdstrike) error
	VisitSiemElasticsearch(*SiemElasticsearch) error
	VisitSiemGoogleChronicle(*SiemGoogleChronicle) error
	VisitSiemGoogleSecurityOperations(*SiemGoogleSecurityOperations) error
	VisitSiemMockSiem(*SiemMock) error
	VisitSiemOpensearch(*SiemOpenSearch) error
	VisitSiemQRadar(*SiemQRadar) error
	VisitSiemRapid7Insightidr(*SiemRapid7InsightIdr) error
	VisitSiemSentinel(*SiemSentinel) error
	VisitSiemSplunk(*SiemSplunk) error
	VisitSiemSumoLogic(*SiemSumoLogic) error
	VisitSinkAwsSecurityLake(*SinkAwsSecurityLake) error
	VisitSinkAwsSqs(*SinkAwsSqs) error
	VisitSinkAzureMonitorLogs(*SinkAzureMonitorLogs) error
	VisitSinkCrowdstrikeHec(*SinkCrowdstrikeHec) error
	VisitSinkElasticsearch(*SinkElasticsearch) error
	VisitSinkGoogleSecOps(*SinkGoogleSecOps) error
	VisitSinkGoogleSecurityOperations(*SinkGoogleSecurityOperations) error
	VisitSinkMockSink(*SinkMock) error
	VisitSinkOpensearch(*SinkOpenSearch) error
	VisitSinkSplunk(*SinkSplunk) error
	VisitStorageAwsS3(*StorageAwsS3) error
	VisitStorageAzureBlob(*StorageAzureBlob) error
	VisitStorageGcs(*StorageGcs) error
	VisitStorageMockStorage(*StorageMock) error
	VisitTicketingAutotask(*TicketingAutotask) error
	VisitTicketingFreshdesk(*TicketingFreshdesk) error
	VisitTicketingJira(*TicketingJira) error
	VisitTicketingMockTicketing(*TicketingMock) error
	VisitTicketingPagerduty(*TicketingPagerDuty) error
	VisitTicketingServicenow(*TicketingServiceNow) error
	VisitTicketingServicenowSir(*TicketingServiceNowSir) error
	VisitTicketingTorq(*TicketingTorq) error
	VisitTicketingZendesk(*TicketingZendesk) error
	VisitVulnerabilitiesCrowdstrike(*VulnerabilitiesCrowdStrike) error
	VisitVulnerabilitiesNucleus(*VulnerabilitiesNucleus) error
	VisitVulnerabilitiesQualysCloud(*VulnerabilitiesQualysCloud) error
	VisitVulnerabilitiesQualysCloudMock(*VulnerabilitiesQualysCloudMock) error
	VisitVulnerabilitiesRapid7InsightCloud(*VulnerabilitiesRapid7InsightCloud) error
	VisitVulnerabilitiesRapid7InsightCloudMock(*VulnerabilitiesRapid7InsightCloudMock) error
	VisitVulnerabilitiesTaniumCloud(*VulnerabilitiesTaniumCloud) error
	VisitVulnerabilitiesTaniumCloudMock(*VulnerabilitiesTaniumCloudMock) error
	VisitVulnerabilitiesTenableCloud(*VulnerabilitiesTenableCloud) error
}

func (p *ProviderConfig) Accept(visitor ProviderConfigVisitor) error {
	if p.AssetsArmisCentrix != nil {
		return visitor.VisitAssetsArmisCentrix(p.AssetsArmisCentrix)
	}
	if p.AssetsArmisCentrixMock != nil {
		return visitor.VisitAssetsArmisCentrixMock(p.AssetsArmisCentrixMock)
	}
	if p.AssetsAxonius != nil {
		return visitor.VisitAssetsAxonius(p.AssetsAxonius)
	}
	if p.AssetsCrowdstrike != nil {
		return visitor.VisitAssetsCrowdstrike(p.AssetsCrowdstrike)
	}
	if p.AssetsNozomiVantage != nil {
		return visitor.VisitAssetsNozomiVantage(p.AssetsNozomiVantage)
	}
	if p.AssetsNozomiVantageMock != nil {
		return visitor.VisitAssetsNozomiVantageMock(p.AssetsNozomiVantageMock)
	}
	if p.AssetsQualysCloud != nil {
		return visitor.VisitAssetsQualysCloud(p.AssetsQualysCloud)
	}
	if p.AssetsQualysCloudMock != nil {
		return visitor.VisitAssetsQualysCloudMock(p.AssetsQualysCloudMock)
	}
	if p.AssetsServicenow != nil {
		return visitor.VisitAssetsServicenow(p.AssetsServicenow)
	}
	if p.AssetsServicenowMock != nil {
		return visitor.VisitAssetsServicenowMock(p.AssetsServicenowMock)
	}
	if p.AssetsSevco != nil {
		return visitor.VisitAssetsSevco(p.AssetsSevco)
	}
	if p.AssetsTaniumCloud != nil {
		return visitor.VisitAssetsTaniumCloud(p.AssetsTaniumCloud)
	}
	if p.AssetsTaniumCloudMock != nil {
		return visitor.VisitAssetsTaniumCloudMock(p.AssetsTaniumCloudMock)
	}
	if p.CloudsecurityCrowdstrike != nil {
		return visitor.VisitCloudsecurityCrowdstrike(p.CloudsecurityCrowdstrike)
	}
	if p.CloudsecurityDefender != nil {
		return visitor.VisitCloudsecurityDefender(p.CloudsecurityDefender)
	}
	if p.EdrCrowdstrike != nil {
		return visitor.VisitEdrCrowdstrike(p.EdrCrowdstrike)
	}
	if p.EdrDefender != nil {
		return visitor.VisitEdrDefender(p.EdrDefender)
	}
	if p.EdrMalwarebytes != nil {
		return visitor.VisitEdrMalwarebytes(p.EdrMalwarebytes)
	}
	if p.EdrSentinelone != nil {
		return visitor.VisitEdrSentinelone(p.EdrSentinelone)
	}
	if p.EdrSophos != nil {
		return visitor.VisitEdrSophos(p.EdrSophos)
	}
	if p.EdrTanium != nil {
		return visitor.VisitEdrTanium(p.EdrTanium)
	}
	if p.IdentityEntraId != nil {
		return visitor.VisitIdentityEntraId(p.IdentityEntraId)
	}
	if p.IdentityGoogle != nil {
		return visitor.VisitIdentityGoogle(p.IdentityGoogle)
	}
	if p.IdentityOkta != nil {
		return visitor.VisitIdentityOkta(p.IdentityOkta)
	}
	if p.IdentityPingone != nil {
		return visitor.VisitIdentityPingone(p.IdentityPingone)
	}
	if p.NotificationsJira != nil {
		return visitor.VisitNotificationsJira(p.NotificationsJira)
	}
	if p.NotificationsMockNotifications != nil {
		return visitor.VisitNotificationsMockNotifications(p.NotificationsMockNotifications)
	}
	if p.NotificationsSlack != nil {
		return visitor.VisitNotificationsSlack(p.NotificationsSlack)
	}
	if p.NotificationsSlackWebhook != nil {
		return visitor.VisitNotificationsSlackWebhook(p.NotificationsSlackWebhook)
	}
	if p.NotificationsTeams != nil {
		return visitor.VisitNotificationsTeams(p.NotificationsTeams)
	}
	if p.SiemCrowdstrike != nil {
		return visitor.VisitSiemCrowdstrike(p.SiemCrowdstrike)
	}
	if p.SiemElasticsearch != nil {
		return visitor.VisitSiemElasticsearch(p.SiemElasticsearch)
	}
	if p.SiemGoogleChronicle != nil {
		return visitor.VisitSiemGoogleChronicle(p.SiemGoogleChronicle)
	}
	if p.SiemGoogleSecurityOperations != nil {
		return visitor.VisitSiemGoogleSecurityOperations(p.SiemGoogleSecurityOperations)
	}
	if p.SiemMockSiem != nil {
		return visitor.VisitSiemMockSiem(p.SiemMockSiem)
	}
	if p.SiemOpensearch != nil {
		return visitor.VisitSiemOpensearch(p.SiemOpensearch)
	}
	if p.SiemQRadar != nil {
		return visitor.VisitSiemQRadar(p.SiemQRadar)
	}
	if p.SiemRapid7Insightidr != nil {
		return visitor.VisitSiemRapid7Insightidr(p.SiemRapid7Insightidr)
	}
	if p.SiemSentinel != nil {
		return visitor.VisitSiemSentinel(p.SiemSentinel)
	}
	if p.SiemSplunk != nil {
		return visitor.VisitSiemSplunk(p.SiemSplunk)
	}
	if p.SiemSumoLogic != nil {
		return visitor.VisitSiemSumoLogic(p.SiemSumoLogic)
	}
	if p.SinkAwsSecurityLake != nil {
		return visitor.VisitSinkAwsSecurityLake(p.SinkAwsSecurityLake)
	}
	if p.SinkAwsSqs != nil {
		return visitor.VisitSinkAwsSqs(p.SinkAwsSqs)
	}
	if p.SinkAzureMonitorLogs != nil {
		return visitor.VisitSinkAzureMonitorLogs(p.SinkAzureMonitorLogs)
	}
	if p.SinkCrowdstrikeHec != nil {
		return visitor.VisitSinkCrowdstrikeHec(p.SinkCrowdstrikeHec)
	}
	if p.SinkElasticsearch != nil {
		return visitor.VisitSinkElasticsearch(p.SinkElasticsearch)
	}
	if p.SinkGoogleSecOps != nil {
		return visitor.VisitSinkGoogleSecOps(p.SinkGoogleSecOps)
	}
	if p.SinkGoogleSecurityOperations != nil {
		return visitor.VisitSinkGoogleSecurityOperations(p.SinkGoogleSecurityOperations)
	}
	if p.SinkMockSink != nil {
		return visitor.VisitSinkMockSink(p.SinkMockSink)
	}
	if p.SinkOpensearch != nil {
		return visitor.VisitSinkOpensearch(p.SinkOpensearch)
	}
	if p.SinkSplunk != nil {
		return visitor.VisitSinkSplunk(p.SinkSplunk)
	}
	if p.StorageAwsS3 != nil {
		return visitor.VisitStorageAwsS3(p.StorageAwsS3)
	}
	if p.StorageAzureBlob != nil {
		return visitor.VisitStorageAzureBlob(p.StorageAzureBlob)
	}
	if p.StorageGcs != nil {
		return visitor.VisitStorageGcs(p.StorageGcs)
	}
	if p.StorageMockStorage != nil {
		return visitor.VisitStorageMockStorage(p.StorageMockStorage)
	}
	if p.TicketingAutotask != nil {
		return visitor.VisitTicketingAutotask(p.TicketingAutotask)
	}
	if p.TicketingFreshdesk != nil {
		return visitor.VisitTicketingFreshdesk(p.TicketingFreshdesk)
	}
	if p.TicketingJira != nil {
		return visitor.VisitTicketingJira(p.TicketingJira)
	}
	if p.TicketingMockTicketing != nil {
		return visitor.VisitTicketingMockTicketing(p.TicketingMockTicketing)
	}
	if p.TicketingPagerduty != nil {
		return visitor.VisitTicketingPagerduty(p.TicketingPagerduty)
	}
	if p.TicketingServicenow != nil {
		return visitor.VisitTicketingServicenow(p.TicketingServicenow)
	}
	if p.TicketingServicenowSir != nil {
		return visitor.VisitTicketingServicenowSir(p.TicketingServicenowSir)
	}
	if p.TicketingTorq != nil {
		return visitor.VisitTicketingTorq(p.TicketingTorq)
	}
	if p.TicketingZendesk != nil {
		return visitor.VisitTicketingZendesk(p.TicketingZendesk)
	}
	if p.VulnerabilitiesCrowdstrike != nil {
		return visitor.VisitVulnerabilitiesCrowdstrike(p.VulnerabilitiesCrowdstrike)
	}
	if p.VulnerabilitiesNucleus != nil {
		return visitor.VisitVulnerabilitiesNucleus(p.VulnerabilitiesNucleus)
	}
	if p.VulnerabilitiesQualysCloud != nil {
		return visitor.VisitVulnerabilitiesQualysCloud(p.VulnerabilitiesQualysCloud)
	}
	if p.VulnerabilitiesQualysCloudMock != nil {
		return visitor.VisitVulnerabilitiesQualysCloudMock(p.VulnerabilitiesQualysCloudMock)
	}
	if p.VulnerabilitiesRapid7InsightCloud != nil {
		return visitor.VisitVulnerabilitiesRapid7InsightCloud(p.VulnerabilitiesRapid7InsightCloud)
	}
	if p.VulnerabilitiesRapid7InsightCloudMock != nil {
		return visitor.VisitVulnerabilitiesRapid7InsightCloudMock(p.VulnerabilitiesRapid7InsightCloudMock)
	}
	if p.VulnerabilitiesTaniumCloud != nil {
		return visitor.VisitVulnerabilitiesTaniumCloud(p.VulnerabilitiesTaniumCloud)
	}
	if p.VulnerabilitiesTaniumCloudMock != nil {
		return visitor.VisitVulnerabilitiesTaniumCloudMock(p.VulnerabilitiesTaniumCloudMock)
	}
	if p.VulnerabilitiesTenableCloud != nil {
		return visitor.VisitVulnerabilitiesTenableCloud(p.VulnerabilitiesTenableCloud)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

// List of supported providers.
type ProviderConfigId string

const (
	// Armis Centrix™ for Asset Management and Security
	ProviderConfigIdAssetsArmisCentrix ProviderConfigId = "assets_armis_centrix"
	// [MOCK] Armis Centrix™ for Asset Management and Security
	ProviderConfigIdAssetsArmisCentrixMock ProviderConfigId = "assets_armis_centrix_mock"
	// Axonius Asset Cloud
	ProviderConfigIdAssetsAxonius ProviderConfigId = "assets_axonius"
	// CrowdStrike Falcon Spotlight
	ProviderConfigIdAssetsCrowdStrike ProviderConfigId = "assets_crowdstrike"
	// Nozomi Vantage
	ProviderConfigIdAssetsNozomiVantage ProviderConfigId = "assets_nozomi_vantage"
	// [MOCK] Nozomi Vantage
	ProviderConfigIdAssetsNozomiVantageMock ProviderConfigId = "assets_nozomi_vantage_mock"
	// Qualys Vulnerability Management, Detection & Response (VMDR)
	ProviderConfigIdAssetsQualysCloud ProviderConfigId = "assets_qualys_cloud"
	// [MOCK] Qualys Vulnerability Management, Detection & Response (VMDR)
	ProviderConfigIdAssetsQualysCloudMock ProviderConfigId = "assets_qualys_cloud_mock"
	// ServiceNow Configuration Management Database (CMDB)
	ProviderConfigIdAssetsServiceNow ProviderConfigId = "assets_servicenow"
	// [MOCK] ServiceNow Configuration Management Database (CMDB)
	ProviderConfigIdAssetsServiceNowMock ProviderConfigId = "assets_servicenow_mock"
	// Sevco for Asset Management and Security
	ProviderConfigIdAssetsSevco ProviderConfigId = "assets_sevco"
	// Tanium Vulnerability Management
	ProviderConfigIdAssetsTaniumCloud ProviderConfigId = "assets_tanium_cloud"
	// [MOCK] Tanium Vulnerability Management
	ProviderConfigIdAssetsTaniumCloudMock ProviderConfigId = "assets_tanium_cloud_mock"
	// CrowdStrike Falcon® Insight EDR
	ProviderConfigIdCloudSecurityCrowdStrike ProviderConfigId = "cloudsecurity_crowdstrike"
	// Microsoft Defender for Cloud
	ProviderConfigIdCloudSecurityDefender ProviderConfigId = "cloudsecurity_defender"
	// CrowdStrike Falcon® Insight EDR
	ProviderConfigIdEdrCrowdStrike ProviderConfigId = "edr_crowdstrike"
	// Microsoft Defender for Endpoint
	ProviderConfigIdEdrDefender ProviderConfigId = "edr_defender"
	// ThreatDown Endpoint Detection & Response
	ProviderConfigIdEdrMalwarebytes ProviderConfigId = "edr_malwarebytes"
	// SentinelOne Singularity™ Endpoint
	ProviderConfigIdEdrSentinelOne ProviderConfigId = "edr_sentinelone"
	// Sophos Endpoint
	ProviderConfigIdEdrSophos ProviderConfigId = "edr_sophos"
	// Tanium EDR
	ProviderConfigIdEdrTanium ProviderConfigId = "edr_tanium"
	// Microsoft Entra ID
	ProviderConfigIdIdentityEntraId ProviderConfigId = "identity_entra_id"
	// Google Workspace
	ProviderConfigIdIdentityGoogle ProviderConfigId = "identity_google"
	// Okta Identity
	ProviderConfigIdIdentityOkta ProviderConfigId = "identity_okta"
	// PingOne Cloud Platform
	ProviderConfigIdIdentityPingOne ProviderConfigId = "identity_pingone"
	// Atlassian Jira
	ProviderConfigIdNotificationsJira ProviderConfigId = "notifications_jira"
	// Synqly Test Provider
	ProviderConfigIdNotificationsMock ProviderConfigId = "notifications_mock_notifications"
	// Slack Incoming Webhook
	ProviderConfigIdNotificationsSlackWebhook ProviderConfigId = "notifications_slack_webhook"
	// Slack
	ProviderConfigIdNotificationsSlack ProviderConfigId = "notifications_slack"
	// Microsoft Teams
	ProviderConfigIdNotificationsTeams ProviderConfigId = "notifications_teams"
	// CrowdStrike Falcon® Next-Gen SIEM
	ProviderConfigIdSiemCrowdstrike ProviderConfigId = "siem_crowdstrike"
	// Elastic SIEM
	ProviderConfigIdSiemElasticsearch ProviderConfigId = "siem_elasticsearch"
	// Google Security Operations (Chronicle Compatibility)
	ProviderConfigIdSiemGoogleChronicle ProviderConfigId = "siem_google_chronicle"
	// Google Security Operations
	ProviderConfigIdSiemGoogleSecurityOperations ProviderConfigId = "siem_google_security_operations"
	// Synqly Test Provider
	ProviderConfigIdSiemMock ProviderConfigId = "siem_mock_siem"
	// OpenSearch SIEM
	ProviderConfigIdSiemOpenSearch ProviderConfigId = "siem_opensearch"
	// IBM QRadar SIEM
	ProviderConfigIdSiemQRadar ProviderConfigId = "siem_q_radar"
	// Rapid7 InsightIDR
	ProviderConfigIdSiemRapid7InsightIdr ProviderConfigId = "siem_rapid7_insightidr"
	// Microsoft Sentinel
	ProviderConfigIdSiemSentinel ProviderConfigId = "siem_sentinel"
	// Splunk Enterprise Security
	ProviderConfigIdSiemSplunk ProviderConfigId = "siem_splunk"
	// Sumo Logic Cloud SIEM
	ProviderConfigIdSiemSumoLogic ProviderConfigId = "siem_sumo_logic"
	// Amazon Security Lake
	ProviderConfigIdSinkAwsSecurityLake ProviderConfigId = "sink_aws_security_lake"
	// Amazon Simple Queue Service (SQS)
	ProviderConfigIdSinkAwsSqs ProviderConfigId = "sink_aws_sqs"
	// Microsoft Azure Monitor Logs
	ProviderConfigIdSinkAzureMonitorLogs ProviderConfigId = "sink_azure_monitor_logs"
	// CrowdStrike Falcon® Next-Gen SIEM (HEC)
	ProviderConfigIdSinkCrowdstrikeHec ProviderConfigId = "sink_crowdstrike_hec"
	// Elasticsearch
	ProviderConfigIdSinkElasticsearch ProviderConfigId = "sink_elasticsearch"
	// Google Security Operations (Chronicle Compatibility)
	ProviderConfigIdSinkGoogleSecOps ProviderConfigId = "sink_google_sec_ops"
	// Google Security Operations
	ProviderConfigIdSinkGoogleSecurityOperations ProviderConfigId = "sink_google_security_operations"
	// Synqly Test Provider
	ProviderConfigIdSinkMock ProviderConfigId = "sink_mock_sink"
	// OpenSearch
	ProviderConfigIdSinkOpenSearch ProviderConfigId = "sink_opensearch"
	// Splunk Enterprise Security
	ProviderConfigIdSinkSplunk ProviderConfigId = "sink_splunk"
	// Amazon S3
	ProviderConfigIdStorageAwsS3 ProviderConfigId = "storage_aws_s3"
	// Microsoft Azure Blob Storage
	ProviderConfigIdStorageAzureBlob ProviderConfigId = "storage_azure_blob"
	// Google Cloud Storage
	ProviderConfigIdStorageGcs ProviderConfigId = "storage_gcs"
	// Synqly Test Provider
	ProviderConfigIdStorageMock ProviderConfigId = "storage_mock_storage"
	// Autotask Operations Cloud
	ProviderConfigIdTicketingAutotask ProviderConfigId = "ticketing_autotask"
	// Freshdesk
	ProviderConfigIdTicketingFreshdesk ProviderConfigId = "ticketing_freshdesk"
	// Atlassian Jira
	ProviderConfigIdTicketingJira ProviderConfigId = "ticketing_jira"
	// Synqly Test Provider
	ProviderConfigIdTicketingMock ProviderConfigId = "ticketing_mock_ticketing"
	// PagerDuty Operations Cloud
	ProviderConfigIdTicketingPagerDuty ProviderConfigId = "ticketing_pagerduty"
	// ServiceNow IT Service Management (ITSM)
	ProviderConfigIdTicketingServiceNow ProviderConfigId = "ticketing_servicenow"
	// ServiceNow Security Incident Response (SIR)
	ProviderConfigIdTicketingServiceNowSir ProviderConfigId = "ticketing_servicenow_sir"
	// Torq
	ProviderConfigIdTicketingTorq ProviderConfigId = "ticketing_torq"
	// Zendesk
	ProviderConfigIdTicketingZendesk ProviderConfigId = "ticketing_zendesk"
	// CrowdStrike Falcon® Spotlight
	ProviderConfigIdVulnerabilitiesCrowdStrike ProviderConfigId = "vulnerabilities_crowdstrike"
	// Nucleus Vulnerability Management
	ProviderConfigIdVulnerabilitiesNucleus ProviderConfigId = "vulnerabilities_nucleus"
	// Qualys Vulnerability Management, Detection & Response (VMDR)
	ProviderConfigIdVulnerabilitiesQualysCloud ProviderConfigId = "vulnerabilities_qualys_cloud"
	// [MOCK] Qualys Vulnerability Management, Detection & Response (VMDR)
	ProviderConfigIdVulnerabilitiesQualysCloudMock ProviderConfigId = "vulnerabilities_qualys_cloud_mock"
	// Rapid7 InsightVM
	ProviderConfigIdVulnerabilitiesRapid7InsightCloud ProviderConfigId = "vulnerabilities_rapid7_insight_cloud"
	// [MOCK] Rapid7 Insight Vulnerability Management Cloud
	ProviderConfigIdVulnerabilitiesRapid7InsightCloudMock ProviderConfigId = "vulnerabilities_rapid7_insight_cloud_mock"
	// Tanium Vulnerability Management
	ProviderConfigIdVulnerabilitiesTaniumCloud ProviderConfigId = "vulnerabilities_tanium_cloud"
	// [MOCK] Tsanium Vulnerability Management
	ProviderConfigIdVulnerabilitiesTaniumCloudMock ProviderConfigId = "vulnerabilities_tanium_cloud_mock"
	// Tenable Vulnerability Management
	ProviderConfigIdVulnerabilitiesTenableCloud ProviderConfigId = "vulnerabilities_tenable_cloud"
	// Any provider config type.
	ProviderConfigIdAll ProviderConfigId = "*"
)

func NewProviderConfigIdFromString(s string) (ProviderConfigId, error) {
	switch s {
	case "assets_armis_centrix":
		return ProviderConfigIdAssetsArmisCentrix, nil
	case "assets_armis_centrix_mock":
		return ProviderConfigIdAssetsArmisCentrixMock, nil
	case "assets_axonius":
		return ProviderConfigIdAssetsAxonius, nil
	case "assets_crowdstrike":
		return ProviderConfigIdAssetsCrowdStrike, nil
	case "assets_nozomi_vantage":
		return ProviderConfigIdAssetsNozomiVantage, nil
	case "assets_nozomi_vantage_mock":
		return ProviderConfigIdAssetsNozomiVantageMock, nil
	case "assets_qualys_cloud":
		return ProviderConfigIdAssetsQualysCloud, nil
	case "assets_qualys_cloud_mock":
		return ProviderConfigIdAssetsQualysCloudMock, nil
	case "assets_servicenow":
		return ProviderConfigIdAssetsServiceNow, nil
	case "assets_servicenow_mock":
		return ProviderConfigIdAssetsServiceNowMock, nil
	case "assets_sevco":
		return ProviderConfigIdAssetsSevco, nil
	case "assets_tanium_cloud":
		return ProviderConfigIdAssetsTaniumCloud, nil
	case "assets_tanium_cloud_mock":
		return ProviderConfigIdAssetsTaniumCloudMock, nil
	case "cloudsecurity_crowdstrike":
		return ProviderConfigIdCloudSecurityCrowdStrike, nil
	case "cloudsecurity_defender":
		return ProviderConfigIdCloudSecurityDefender, nil
	case "edr_crowdstrike":
		return ProviderConfigIdEdrCrowdStrike, nil
	case "edr_defender":
		return ProviderConfigIdEdrDefender, nil
	case "edr_malwarebytes":
		return ProviderConfigIdEdrMalwarebytes, nil
	case "edr_sentinelone":
		return ProviderConfigIdEdrSentinelOne, nil
	case "edr_sophos":
		return ProviderConfigIdEdrSophos, nil
	case "edr_tanium":
		return ProviderConfigIdEdrTanium, nil
	case "identity_entra_id":
		return ProviderConfigIdIdentityEntraId, nil
	case "identity_google":
		return ProviderConfigIdIdentityGoogle, nil
	case "identity_okta":
		return ProviderConfigIdIdentityOkta, nil
	case "identity_pingone":
		return ProviderConfigIdIdentityPingOne, nil
	case "notifications_jira":
		return ProviderConfigIdNotificationsJira, nil
	case "notifications_mock_notifications":
		return ProviderConfigIdNotificationsMock, nil
	case "notifications_slack_webhook":
		return ProviderConfigIdNotificationsSlackWebhook, nil
	case "notifications_slack":
		return ProviderConfigIdNotificationsSlack, nil
	case "notifications_teams":
		return ProviderConfigIdNotificationsTeams, nil
	case "siem_crowdstrike":
		return ProviderConfigIdSiemCrowdstrike, nil
	case "siem_elasticsearch":
		return ProviderConfigIdSiemElasticsearch, nil
	case "siem_google_chronicle":
		return ProviderConfigIdSiemGoogleChronicle, nil
	case "siem_google_security_operations":
		return ProviderConfigIdSiemGoogleSecurityOperations, nil
	case "siem_mock_siem":
		return ProviderConfigIdSiemMock, nil
	case "siem_opensearch":
		return ProviderConfigIdSiemOpenSearch, nil
	case "siem_q_radar":
		return ProviderConfigIdSiemQRadar, nil
	case "siem_rapid7_insightidr":
		return ProviderConfigIdSiemRapid7InsightIdr, nil
	case "siem_sentinel":
		return ProviderConfigIdSiemSentinel, nil
	case "siem_splunk":
		return ProviderConfigIdSiemSplunk, nil
	case "siem_sumo_logic":
		return ProviderConfigIdSiemSumoLogic, nil
	case "sink_aws_security_lake":
		return ProviderConfigIdSinkAwsSecurityLake, nil
	case "sink_aws_sqs":
		return ProviderConfigIdSinkAwsSqs, nil
	case "sink_azure_monitor_logs":
		return ProviderConfigIdSinkAzureMonitorLogs, nil
	case "sink_crowdstrike_hec":
		return ProviderConfigIdSinkCrowdstrikeHec, nil
	case "sink_elasticsearch":
		return ProviderConfigIdSinkElasticsearch, nil
	case "sink_google_sec_ops":
		return ProviderConfigIdSinkGoogleSecOps, nil
	case "sink_google_security_operations":
		return ProviderConfigIdSinkGoogleSecurityOperations, nil
	case "sink_mock_sink":
		return ProviderConfigIdSinkMock, nil
	case "sink_opensearch":
		return ProviderConfigIdSinkOpenSearch, nil
	case "sink_splunk":
		return ProviderConfigIdSinkSplunk, nil
	case "storage_aws_s3":
		return ProviderConfigIdStorageAwsS3, nil
	case "storage_azure_blob":
		return ProviderConfigIdStorageAzureBlob, nil
	case "storage_gcs":
		return ProviderConfigIdStorageGcs, nil
	case "storage_mock_storage":
		return ProviderConfigIdStorageMock, nil
	case "ticketing_autotask":
		return ProviderConfigIdTicketingAutotask, nil
	case "ticketing_freshdesk":
		return ProviderConfigIdTicketingFreshdesk, nil
	case "ticketing_jira":
		return ProviderConfigIdTicketingJira, nil
	case "ticketing_mock_ticketing":
		return ProviderConfigIdTicketingMock, nil
	case "ticketing_pagerduty":
		return ProviderConfigIdTicketingPagerDuty, nil
	case "ticketing_servicenow":
		return ProviderConfigIdTicketingServiceNow, nil
	case "ticketing_servicenow_sir":
		return ProviderConfigIdTicketingServiceNowSir, nil
	case "ticketing_torq":
		return ProviderConfigIdTicketingTorq, nil
	case "ticketing_zendesk":
		return ProviderConfigIdTicketingZendesk, nil
	case "vulnerabilities_crowdstrike":
		return ProviderConfigIdVulnerabilitiesCrowdStrike, nil
	case "vulnerabilities_nucleus":
		return ProviderConfigIdVulnerabilitiesNucleus, nil
	case "vulnerabilities_qualys_cloud":
		return ProviderConfigIdVulnerabilitiesQualysCloud, nil
	case "vulnerabilities_qualys_cloud_mock":
		return ProviderConfigIdVulnerabilitiesQualysCloudMock, nil
	case "vulnerabilities_rapid7_insight_cloud":
		return ProviderConfigIdVulnerabilitiesRapid7InsightCloud, nil
	case "vulnerabilities_rapid7_insight_cloud_mock":
		return ProviderConfigIdVulnerabilitiesRapid7InsightCloudMock, nil
	case "vulnerabilities_tanium_cloud":
		return ProviderConfigIdVulnerabilitiesTaniumCloud, nil
	case "vulnerabilities_tanium_cloud_mock":
		return ProviderConfigIdVulnerabilitiesTaniumCloudMock, nil
	case "vulnerabilities_tenable_cloud":
		return ProviderConfigIdVulnerabilitiesTenableCloud, nil
	case "*":
		return ProviderConfigIdAll, nil
	}
	var t ProviderConfigId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderConfigId) Ptr() *ProviderConfigId {
	return &p
}

type QRadarCredential struct {
	Type string
	// Authorized service token for QRadar Operations. [Guide to generate a token](https://www.ibm.com/docs/en/qradar-common?topic=app-creating-authorized-service-token-qradar-operations).
	Token *TokenCredential
	// Reference to existing Authorized Service Token.
	TokenId TokenCredentialId
}

func (q *QRadarCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	q.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", q)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		q.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		q.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (q QRadarCredential) MarshalJSON() ([]byte, error) {
	if q.Token != nil {
		return core.MarshalJSONWithExtraProperty(q.Token, "type", "token")
	}
	if q.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: q.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QRadarCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (q *QRadarCredential) Accept(visitor QRadarCredentialVisitor) error {
	if q.Token != nil {
		return visitor.VisitToken(q.Token)
	}
	if q.TokenId != "" {
		return visitor.VisitTokenId(q.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QualysCloudCredential struct {
	Type string
	// Username and password used to authenticate with Qualys Cloud.
	Basic *BasicCredential
	// Reference to existing Basic Credentials.
	BasicId BasicCredentialId
}

func (q *QualysCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	q.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", q)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		q.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		q.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (q QualysCloudCredential) MarshalJSON() ([]byte, error) {
	if q.Basic != nil {
		return core.MarshalJSONWithExtraProperty(q.Basic, "type", "basic")
	}
	if q.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: q.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QualysCloudCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (q *QualysCloudCredential) Accept(visitor QualysCloudCredentialVisitor) error {
	if q.Basic != nil {
		return visitor.VisitBasic(q.Basic)
	}
	if q.BasicId != "" {
		return visitor.VisitBasicId(q.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", q)
}

type Rapid7InsightCloudCredential struct {
	Type string
	// Configuration when creating new API Token.
	Token *TokenCredential
	// Reference to existing API Token.
	TokenId TokenCredentialId
}

func (r *Rapid7InsightCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (r Rapid7InsightCloudCredential) MarshalJSON() ([]byte, error) {
	if r.Token != nil {
		return core.MarshalJSONWithExtraProperty(r.Token, "type", "token")
	}
	if r.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: r.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type Rapid7InsightCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (r *Rapid7InsightCloudCredential) Accept(visitor Rapid7InsightCloudCredentialVisitor) error {
	if r.Token != nil {
		return visitor.VisitToken(r.Token)
	}
	if r.TokenId != "" {
		return visitor.VisitTokenId(r.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

// Configuration for CrowdStrike Falcon® Next-Gen SIEM.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/crowdstrike-siem-setup)
type SiemCrowdstrike struct {
	// The credential to use for the CrowdStrike Falcon NextGen SIEM tenant.
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// Token credential to use for connecting to the CrowdStrike HEC service. If not provided, sending events to CrowdStrike is disabled.
	HecCredential *CrowdstrikeHecCredential `json:"hec_credential,omitempty" url:"hec_credential,omitempty"`
	// The generated CrowdStrike HEC URL provided with your token.
	HecUrl *string `json:"hec_url,omitempty" url:"hec_url,omitempty"`
	// Base URL for the CrowdStrike Falcon® Next-Gen SIEM API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemCrowdstrike) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemCrowdstrike) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemCrowdstrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemCrowdstrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemCrowdstrike) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Elastic SIEM.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/elastic-setup)
type SiemElasticsearch struct {
	AuthOptions *ElasticsearchAuthOptions `json:"auth_options,omitempty" url:"auth_options,omitempty"`
	// The index or data stream to use when writing events. Defaults to the `index` setting if not set.
	CreateIndex *string                  `json:"create_index,omitempty" url:"create_index,omitempty"`
	Credential  *ElasticsearchCredential `json:"credential" url:"credential"`
	// The index, data stream, or index alias to read events from.
	Index *string `json:"index,omitempty" url:"index,omitempty"`
	// Base URL for the Kibana API.
	KibanaUrl *string `json:"kibana_url,omitempty" url:"kibana_url,omitempty"`
	// When true, skips verification of the Elasticsearch TLS certificate.
	SkipTlsVerify *bool `json:"skip_tls_verify,omitempty" url:"skip_tls_verify,omitempty"`
	// Base URL for the Elasticsearch API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemElasticsearch) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemElasticsearch) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemElasticsearch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemElasticsearch(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemElasticsearch) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Google Security Operations (formerly Google Chronicle) as a SIEM Provider connecting via the older Backstory and Malachite APIs.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-chronicle-setup)
type SiemGoogleChronicle struct {
	// The customer ID reported when writing events. This field is required if writing events.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// Credentials used for writing events. If not specified then writing events is disabled.
	IngestionCredential *GoogleChronicleCredential `json:"ingestion_credential,omitempty" url:"ingestion_credential,omitempty"`
	// Base URL for the Google SecOps Ingestion API.
	IngestionUrl *string `json:"ingestion_url,omitempty" url:"ingestion_url,omitempty"`
	// Credentials used for querying and reading events.
	SearchCredential *GoogleChronicleCredential `json:"search_credential" url:"search_credential"`
	// Base URL for the Google SecOps Search API.
	SearchUrl *string `json:"search_url,omitempty" url:"search_url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemGoogleChronicle) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemGoogleChronicle) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemGoogleChronicle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemGoogleChronicle(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemGoogleChronicle) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Google Security Operations (formerly Google Chronicle) as a SIEM Provider.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-security-operations-siem-setup)
type SiemGoogleSecurityOperations struct {
	// Credentials used for accessing the Google SecOps instance.
	Credential *GoogleServiceAccountCredential `json:"credential" url:"credential"`
	// The customer ID of the Google SecOps instance.
	CustomerId string `json:"customer_id" url:"customer_id"`
	// The project ID of the Google SecOps instance.
	ProjectId string `json:"project_id" url:"project_id"`
	// The region of the Google SecOps instance. Usually `us` or `eu`.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// The base URL for the Google SecOps API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemGoogleSecurityOperations) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemGoogleSecurityOperations) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemGoogleSecurityOperations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemGoogleSecurityOperations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemGoogleSecurityOperations) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory SIEM Provider. This provider is for testing purposes only and does not retain events pushed to it.
type SiemMock struct {
	// Name of the index where events are stored.
	Index *string `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemMock) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for OpenSearch search and analytics engine. Supports both managed and self-hosted OpenSearch deployments
type SiemOpenSearch struct {
	// The index or data stream to use when writing events. Defaults to the 'index' setting if not set.
	CreateIndex *string               `json:"create_index,omitempty" url:"create_index,omitempty"`
	Credential  *OpenSearchCredential `json:"credential" url:"credential"`
	// The index, data stream, or index alias to read events from.
	Index *string `json:"index,omitempty" url:"index,omitempty"`
	// When true, skips verification of the OpenSearch TLS certificate.
	SkipTlsVerify *bool `json:"skip_tls_verify,omitempty" url:"skip_tls_verify,omitempty"`
	// Base URL for the OpenSearch API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemOpenSearch) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemOpenSearch) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemOpenSearch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemOpenSearch(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemOpenSearch) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for IBM QRadar SIEM.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/qradar-setup)
type SiemQRadar struct {
	// Port used by QRadar to accept incoming HTTP Receiver events.
	CollectionPort int               `json:"collection_port" url:"collection_port"`
	Credential     *QRadarCredential `json:"credential" url:"credential"`
	// When true, skips verification of the QRadar TLS certificate.
	SkipTlsVerify *bool `json:"skip_tls_verify,omitempty" url:"skip_tls_verify,omitempty"`
	// Base URL for the QRadar API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemQRadar) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemQRadar) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemQRadar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemQRadar(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemQRadar) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Rapid7 InsightIDR.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/rapid7-idr-setup)
type SiemRapid7InsightIdr struct {
	Credential *Rapid7InsightCloudCredential `json:"credential" url:"credential"`
	// Base URL for the Rapid7 API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemRapid7InsightIdr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemRapid7InsightIdr) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemRapid7InsightIdr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemRapid7InsightIdr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemRapid7InsightIdr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Microsoft Sentinel SIEM Product.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/microsoft-sentinel-siem-setup)
type SiemSentinel struct {
	Credential *SentinelCredential `json:"credential" url:"credential"`
	// The default tables to use for queries. Supply this value if you would like to a subset of the default tables or non-ASIM data tables with Sentinel/Log Analytics queries.
	// If more than one table is specified, a union operator will join them to query all of the tables at once. Supply a single value with `*` if you would like to query all tables without the normalizing ASIM transformations.
	// **Note** that a single `*` entry will map to a `union *` query. Relying heavily on these queries is generally discouraged by Sentinel because they are slower and more resource intensive.
	DefaultTables []string `json:"default_tables,omitempty" url:"default_tables,omitempty"`
	// Either the logs ingestion API url for you Data Collection Rule or your Data Collection Endpoint URL. This value must be supplied to ingest data into Microsoft Sentinel. This should look something like https://mydcr-xxx-westus2.logs.z1.ingest.monitor.azure.com
	IngestUrl *string `json:"ingest_url,omitempty" url:"ingest_url,omitempty"`
	// Base URL for the Microsoft Azure Monitor Logs API. Should only be supplied if using an alternate Microsoft cloud, such as GovCloud.
	LogsUrl *string `json:"logs_url,omitempty" url:"logs_url,omitempty"`
	// Base URL for the Microsoft Azure Management API. Should only be supplied if using an alternate Microsoft cloud, such as GovCloud.
	ManagementUrl *string `json:"management_url,omitempty" url:"management_url,omitempty"`
	// Azure resource group name that contains the Microsoft Sentinel workspace.
	ResourceGroup string `json:"resource_group" url:"resource_group"`
	// Immutable ID of the Data Collection Rule. This value must be supplied to ingest data into Microsoft Sentinel.
	RuleId *string `json:"rule_id,omitempty" url:"rule_id,omitempty"`
	// Name of the Data Collection Rule stream. This value must be supplied to ingest data into Microsoft Sentinel.
	StreamName *string `json:"stream_name,omitempty" url:"stream_name,omitempty"`
	// Azure subscription ID that contains the Microsoft Sentinel workspace.
	SubscriptionId string `json:"subscription_id" url:"subscription_id"`
	// Azure Active Directory tenant ID that contains the Microsoft Sentinel workspace.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// ID of the Microsoft Sentinel Log Analytics workspace.
	WorkspaceId string `json:"workspace_id" url:"workspace_id"`
	// Name of the Microsoft Sentinel Log Analytics workspace.
	WorkspaceName string `json:"workspace_name" url:"workspace_name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemSentinel) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemSentinel) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemSentinel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemSentinel(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemSentinel) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Splunk Enterprise Security.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/splunk-setup)
type SiemSplunk struct {
	// Credential to use when connecting to the Splunk HEC service. If not provided, sending events to Splunk is disabled.
	HecCredential *SplunkHecToken `json:"hec_credential,omitempty" url:"hec_credential,omitempty"`
	// URL for the Splunk HEC endpoint. Must include the full path to the HEC endpoint.
	HecUrl *string `json:"hec_url,omitempty" url:"hec_url,omitempty"`
	// Splunk index to send events to. If not provided, will use the default index for the Splunk collector.
	Index *string `json:"index,omitempty" url:"index,omitempty"`
	// Credential used when authenticating with the Splunk Search Service.
	SearchServiceCredential *SplunkSearchCredential `json:"search_service_credential" url:"search_service_credential"`
	// URL used when connecting to the Splunk Search Service.
	SearchServiceUrl string `json:"search_service_url" url:"search_service_url"`
	// When true, skips verification of the Splunk TLS certificate.
	SkipTlsVerify *bool `json:"skip_tls_verify,omitempty" url:"skip_tls_verify,omitempty"`
	// Splunk source to send events to. If not provided the default source for the Splunk collector is used.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// Splunk source type to send events to. If not provided the default source type for the Splunk collector is used.
	SourceType *string `json:"source_type,omitempty" url:"source_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemSplunk) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemSplunk) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemSplunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemSplunk(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemSplunk) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Sumo Logic Cloud SIEM.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/sumo-logic-setup)
type SiemSumoLogic struct {
	// Automatically parse logs as JSON when running log queries.
	AutoParseLogs *bool `json:"auto_parse_logs,omitempty" url:"auto_parse_logs,omitempty"`
	// Secure Sumo Logic Collection URL for writing events. If not provided, sending events to Sumo Logic is disabled.
	CollectionUrl *SumoLogicCollectionUrl `json:"collection_url,omitempty" url:"collection_url,omitempty"`
	Credential    *SumoLogicCredential    `json:"credential" url:"credential"`
	// Only query for logs that have been processed into the Sumo Logic Cloud SIEM app.
	SiemLogsOnly *bool `json:"siem_logs_only,omitempty" url:"siem_logs_only,omitempty"`
	// Base URL for the Sumo Logic API.
	// [Sumo Logic endpoints by deployment and firewall security](https://help.sumologic.com/docs/api/getting-started/#sumo-logic-endpoints-by-deployment-and-firewall-security).
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemSumoLogic) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemSumoLogic) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemSumoLogic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemSumoLogic(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemSumoLogic) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SentinelCredential struct {
	Type string
	// Client credentials for authenticating with Microsoft Sentinel.
	// The application registration must have appropriate permissions to read
	// and write to Microsoft Sentinel. Required permissions:
	//
	// - `Microsoft.OperationalInsights/workspaces/read`
	// - `Microsoft.OperationalInsights/workspaces/write`
	// - `Microsoft.SecurityInsights/dataConnectors/*`
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (s *SentinelCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (s SentinelCredential) MarshalJSON() ([]byte, error) {
	if s.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(s.OAuthClient, "type", "o_auth_client")
	}
	if s.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: s.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SentinelCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (s *SentinelCredential) Accept(visitor SentinelCredentialVisitor) error {
	if s.OAuthClient != nil {
		return visitor.VisitOAuthClient(s.OAuthClient)
	}
	if s.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(s.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SentinelOneCredential struct {
	Type string
	// Configuration when creating new API Token.
	Token *TokenCredential
	// Reference to existing API Token.
	TokenId TokenCredentialId
}

func (s *SentinelOneCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SentinelOneCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SentinelOneCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SentinelOneCredential) Accept(visitor SentinelOneCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SentinelOneEdrEventsCredential struct {
	Type string
	// Configuration when creating new Token.
	Token *TokenCredential
	// Reference to existing Token.
	TokenId TokenCredentialId
}

func (s *SentinelOneEdrEventsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SentinelOneEdrEventsCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SentinelOneEdrEventsCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SentinelOneEdrEventsCredential) Accept(visitor SentinelOneEdrEventsCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type ServiceNowCredential struct {
	Type string
	// Username and secret used to authenticate with ServiceNow. The password can be a [generated token](https://docs.servicenow.com/bundle/vancouver-platform-administration/page/administer/users-and-groups/task/t_CreateAUser.html). The token receives the same permissions as the user that generated it, so they must have access to the necessary projects.
	Basic *BasicCredential
	// Reference to existing Basic Credentials.
	BasicId BasicCredentialId
	// Token used to authenticate with ServiceNow. This token will be used with the authentication header `x-sn-apikey`. To use token authentication, the version of ServiceNow must be `Washington D.C.` or later.
	Token *TokenCredential
	// Reference to existing Token.
	TokenId TokenCredentialId
}

func (s *ServiceNowCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.BasicId = valueUnmarshaler.BasicId
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s ServiceNowCredential) MarshalJSON() ([]byte, error) {
	if s.Basic != nil {
		return core.MarshalJSONWithExtraProperty(s.Basic, "type", "basic")
	}
	if s.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: s.BasicId,
		}
		return json.Marshal(marshaler)
	}
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type ServiceNowCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *ServiceNowCredential) Accept(visitor ServiceNowCredentialVisitor) error {
	if s.Basic != nil {
		return visitor.VisitBasic(s.Basic)
	}
	if s.BasicId != "" {
		return visitor.VisitBasicId(s.BasicId)
	}
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SevcoCredential struct {
	Type string
	// This credential must be an API Secret Key. Generate this key in the UI console. For more details, see the [Creating an API Key](https://docs.sev.co/docs/using-the-api#creating-an-api-key).
	Token *TokenCredential
	// Reference to existing Sevco API Secret Key.
	TokenId TokenCredentialId
}

func (s *SevcoCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SevcoCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SevcoCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SevcoCredential) Accept(visitor SevcoCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// Configuration for Amazon Simple Queue Service (SQS).
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/aws-sqs-sink-setup)
type SinkAwsSqs struct {
	// AWS Access Keys with write access to the configured SQS queue.
	Credential *AwsSqsCredential `json:"credential" url:"credential"`
	// Overrides the default AWS region. If not present, the region will be inferred from the URL.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// URL of the SQS queue where events are sent.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAwsSqs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAwsSqs) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAwsSqs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAwsSqs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkAwsSqs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Amazon Security Lake as a Sink provider. Events are written directly to an AWS S3 bucket in Apache Parquet format.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/amazon-security-lake-sink-setup)
type SinkAwsSecurityLake struct {
	// AWS Access Keys with write access to the configured S3 bucket.
	Credential *AwsSecurityLakeCredential `json:"credential" url:"credential"`
	// Override the default AWS region for this integration. If not present, the region will be inferred from the URL.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// URL of the S3 bucket where the Amazon Security Lake events are stored.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAwsSecurityLake) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAwsSecurityLake) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAwsSecurityLake
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAwsSecurityLake(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkAwsSecurityLake) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Azure Monitor Logs as a Sink Provider. Azure Monitor Logs is a feature of Azure Monitor that collects and organizes log and performance data from monitored resources.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/azure-monitor-logs)
type SinkAzureMonitorLogs struct {
	// Azure Client (Application) ID.
	ClientId string `json:"client_id" url:"client_id"`
	// Credential with access to the configured data collection endpoint.
	Credential *AzureMonitorLogsCredential `json:"credential" url:"credential"`
	// Data collection rule immutable ID.
	RuleId string `json:"rule_id" url:"rule_id"`
	// Name of the data collection rule stream.
	StreamName string `json:"stream_name" url:"stream_name"`
	// Azure Directory (tenant) ID.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// URL of the Azure data collection endpoint.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAzureMonitorLogs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAzureMonitorLogs) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAzureMonitorLogs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAzureMonitorLogs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkAzureMonitorLogs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for CrowdStrike Falcon® Next-Gen SIEM (HEC).
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/crowdstrike-sink-setup)
type SinkCrowdstrikeHec struct {
	Credential *CrowdstrikeHecCredential `json:"credential" url:"credential"`
	// HTTPS URL for the CrowdStrike HTTP Event Collector (HEC) API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkCrowdstrikeHec) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkCrowdstrikeHec) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkCrowdstrikeHec
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkCrowdstrikeHec(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkCrowdstrikeHec) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Elasticsearch.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/elastic-setup)
type SinkElasticsearch struct {
	AuthOptions *ElasticsearchAuthOptions `json:"auth_options,omitempty" url:"auth_options,omitempty"`
	// The index or data stream to use when writing events.
	CreateIndex string                   `json:"create_index" url:"create_index"`
	Credential  *ElasticsearchCredential `json:"credential" url:"credential"`
	// When true, skips verification of the Elasticsearch TLS certificate.
	SkipTlsVerify *bool `json:"skip_tls_verify,omitempty" url:"skip_tls_verify,omitempty"`
	// Base URL for the Elasticsearch API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkElasticsearch) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkElasticsearch) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkElasticsearch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkElasticsearch(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkElasticsearch) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Google Security Operations (formerly Google Chronicle) as a Sink Provider connecting via the older Malachite API.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-chronicle-setup)
type SinkGoogleSecOps struct {
	// Credentials used when writing events.
	Credential *GoogleChronicleCredential `json:"credential" url:"credential"`
	// The customer ID reported when writing events.
	CustomerId string `json:"customer_id" url:"customer_id"`
	// Base URL for the Google SecOps Ingestion API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkGoogleSecOps) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkGoogleSecOps) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkGoogleSecOps
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkGoogleSecOps(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkGoogleSecOps) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Google Security Operations (formerly Google Chronicle) as a Sink Provider.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-security-operations-sink-setup)
type SinkGoogleSecurityOperations struct {
	// Credentials used for accessing the Google SecOps instance.
	Credential *GoogleServiceAccountCredential `json:"credential" url:"credential"`
	// The customer ID of the Google SecOps instance
	CustomerId string `json:"customer_id" url:"customer_id"`
	// The project ID of the Google SecOps instance.
	ProjectId string `json:"project_id" url:"project_id"`
	// The region of the Google SecOps instance. Usually `us` or `eu`.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// The base URL for the Google SecOps API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkGoogleSecurityOperations) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkGoogleSecurityOperations) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkGoogleSecurityOperations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkGoogleSecurityOperations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkGoogleSecurityOperations) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory Sink Provider. This provider is for testing purposes only and does not retain events pushed to it.
type SinkMock struct {
	// Name of the destination where events are stored. This field is unused and only used to demonstrate Provider configuration.
	Destination *string `json:"destination,omitempty" url:"destination,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkMock) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for OpenSearch search and analytics engine. Supports both managed and self-hosted OpenSearch deployments
type SinkOpenSearch struct {
	// The index or data stream to use when writing events.
	CreateIndex string                `json:"create_index" url:"create_index"`
	Credential  *OpenSearchCredential `json:"credential" url:"credential"`
	// When true, skips verification of the OpenSearch TLS certificate.
	SkipTlsVerify *bool `json:"skip_tls_verify,omitempty" url:"skip_tls_verify,omitempty"`
	// Base URL for the OpenSearch API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkOpenSearch) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkOpenSearch) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkOpenSearch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkOpenSearch(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkOpenSearch) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Splunk as a Sink provider. Allows sending data to Splunk using an HTTP Event Collector (HEC).
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/splunk-setup)
type SinkSplunk struct {
	// Credential to use when connecting to the Splunk HEC service. If not provided, sending events to Splunk is disabled.
	HecCredential *SplunkHecToken `json:"hec_credential" url:"hec_credential"`
	// URL for the Splunk HEC endpoint. Must include the full path to the HEC endpoint.
	HecUrl string `json:"hec_url" url:"hec_url"`
	// Splunk index to send events to. If not provided, will use the default index for the Splunk collector.
	Index *string `json:"index,omitempty" url:"index,omitempty"`
	// When true, skips verification of the Splunk TLS certificate.
	SkipTlsVerify *bool `json:"skip_tls_verify,omitempty" url:"skip_tls_verify,omitempty"`
	// Splunk source to send events to. If not provided the default source for the Splunk collector is used.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// Splunk source type to send events to. If not provided the default source type for the Splunk collector is used.
	SourceType *string `json:"source_type,omitempty" url:"source_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkSplunk) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkSplunk) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkSplunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkSplunk(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkSplunk) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SlackCredential struct {
	Type string
	// Follow [this guide to generate a bot token](https://api.slack.com/concepts/token-types#bot). The token must have access to the configured channel.
	Token *TokenCredential
	// Reference to existing Bot Token.
	TokenId TokenCredentialId
}

func (s *SlackCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SlackCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SlackCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SlackCredential) Accept(visitor SlackCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SlackWebhookCredential struct {
	Type string
	// Slack Incoming Webhook URL. Use a Slack app with Incoming Webhooks enabled to generate the URL. See [configuration guide on Incoming Webhooks](https://api.slack.com/messaging/webhooks) for more detail.
	Secret *SecretCredential
	// Reference to existing Incoming Webhook URL.
	SecretId SecretCredentialId
}

func (s *SlackWebhookCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (s SlackWebhookCredential) MarshalJSON() ([]byte, error) {
	if s.Secret != nil {
		return core.MarshalJSONWithExtraProperty(s.Secret, "type", "secret")
	}
	if s.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: s.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SlackWebhookCredentialVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (s *SlackWebhookCredential) Accept(visitor SlackWebhookCredentialVisitor) error {
	if s.Secret != nil {
		return visitor.VisitSecret(s.Secret)
	}
	if s.SecretId != "" {
		return visitor.VisitSecretId(s.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SophosCredential struct {
	Type string
	// Configuration when creating new Client Credentials.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (s *SophosCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (s SophosCredential) MarshalJSON() ([]byte, error) {
	if s.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(s.OAuthClient, "type", "o_auth_client")
	}
	if s.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: s.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SophosCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (s *SophosCredential) Accept(visitor SophosCredentialVisitor) error {
	if s.OAuthClient != nil {
		return visitor.VisitOAuthClient(s.OAuthClient)
	}
	if s.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(s.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkHecToken struct {
	Type string
	// Token used when connecting to the Splunk HEC Service.
	Token *TokenCredential
	// Reference to existing HEC Token.
	TokenId TokenCredentialId
}

func (s *SplunkHecToken) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SplunkHecToken) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkHecTokenVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SplunkHecToken) Accept(visitor SplunkHecTokenVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkSearchCredential struct {
	Type string
	// Token used when connecting to the Splunk Search Service.
	Token *TokenCredential
	// Reference to existing Search Service Token.
	TokenId TokenCredentialId
}

func (s *SplunkSearchCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SplunkSearchCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkSearchCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SplunkSearchCredential) Accept(visitor SplunkSearchCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// Configuration for Amazon S3.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/aws-s3-storage-setup)
type StorageAwsS3 struct {
	// Name of the Amazon S3 bucket where files are stored.
	Bucket     string           `json:"bucket" url:"bucket"`
	Credential *AwsS3Credential `json:"credential" url:"credential"`
	// Endpoint used for connecting to Amazon S3 the external service. If not provided, the default Amazon S3 endpoint will be used.
	Endpoint *string `json:"endpoint,omitempty" url:"endpoint,omitempty"`
	// AWS region where the Amazon S3 bucket is located.
	Region string `json:"region" url:"region"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageAwsS3) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageAwsS3) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageAwsS3
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageAwsS3(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StorageAwsS3) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Azure Blob Storage as a Storage Provider
type StorageAzureBlob struct {
	// Name of the blob container where files are stored.
	Bucket     string               `json:"bucket" url:"bucket"`
	Credential *AzureBlobCredential `json:"credential" url:"credential"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageAzureBlob) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageAzureBlob) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageAzureBlob
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageAzureBlob(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StorageAzureBlob) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Google Cloud Storage for storing unstructured data
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/google-gcs-storage-setup)
type StorageGcs struct {
	// Name of the bucket where files are stored.
	Bucket     string         `json:"bucket" url:"bucket"`
	Credential *GcsCredential `json:"credential" url:"credential"`
	// Google Cloud region where the bucket is located.
	Region string `json:"region" url:"region"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageGcs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageGcs) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageGcs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageGcs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StorageGcs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory storage Provider. This provider is for testing purposes only and does not retain files pushed to it.
type StorageMock struct {
	// Name of the bucket where files are stored.
	Bucket string `json:"bucket" url:"bucket"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageMock) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StorageMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SumoLogicCollectionUrl struct {
	Type string
	// Sumo Logic HTTP collection URL used to write events.
	Secret *SecretCredential
	// Reference to existing Secret.
	SecretId SecretCredentialId
}

func (s *SumoLogicCollectionUrl) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (s SumoLogicCollectionUrl) MarshalJSON() ([]byte, error) {
	if s.Secret != nil {
		return core.MarshalJSONWithExtraProperty(s.Secret, "type", "secret")
	}
	if s.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: s.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCollectionUrlVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (s *SumoLogicCollectionUrl) Accept(visitor SumoLogicCollectionUrlVisitor) error {
	if s.Secret != nil {
		return visitor.VisitSecret(s.Secret)
	}
	if s.SecretId != "" {
		return visitor.VisitSecretId(s.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCredential struct {
	Type string
	// Access ID and Access Key used to authenticate with Sumo Logic.
	Basic *BasicCredential
	// Reference to existing Access Keys.
	BasicId BasicCredentialId
}

func (s *SumoLogicCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (s SumoLogicCredential) MarshalJSON() ([]byte, error) {
	if s.Basic != nil {
		return core.MarshalJSONWithExtraProperty(s.Basic, "type", "basic")
	}
	if s.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: s.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (s *SumoLogicCredential) Accept(visitor SumoLogicCredentialVisitor) error {
	if s.Basic != nil {
		return visitor.VisitBasic(s.Basic)
	}
	if s.BasicId != "" {
		return visitor.VisitBasicId(s.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type TaniumCloudCredential struct {
	Type string
	// Configuration when creating new API Token.
	Token *TokenCredential
	// Reference to existing API Token.
	TokenId TokenCredentialId
}

func (t *TaniumCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (t TaniumCloudCredential) MarshalJSON() ([]byte, error) {
	if t.Token != nil {
		return core.MarshalJSONWithExtraProperty(t.Token, "type", "token")
	}
	if t.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: t.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TaniumCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (t *TaniumCloudCredential) Accept(visitor TaniumCloudCredentialVisitor) error {
	if t.Token != nil {
		return visitor.VisitToken(t.Token)
	}
	if t.TokenId != "" {
		return visitor.VisitTokenId(t.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TeamsCredential struct {
	Type string
	// OAuth 2.0 Client Credentials for an Azure App Registration. The application must be configured with permissions to access Microsoft Power Automate with user delegation.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
	// Public Webhook URL used to authenticate with Teams.
	WebhookUrl *SecretCredential
	// Reference to existing Webhook URL.
	WebhookUrlId SecretCredentialId
}

func (t *TeamsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.OAuthClientId = valueUnmarshaler.OAuthClientId
	case "webhook_url":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.WebhookUrl = value
	case "webhook_url_id":
		var valueUnmarshaler struct {
			WebhookUrlId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.WebhookUrlId = valueUnmarshaler.WebhookUrlId
	}
	return nil
}

func (t TeamsCredential) MarshalJSON() ([]byte, error) {
	if t.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(t.OAuthClient, "type", "o_auth_client")
	}
	if t.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: t.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if t.WebhookUrl != nil {
		return core.MarshalJSONWithExtraProperty(t.WebhookUrl, "type", "webhook_url")
	}
	if t.WebhookUrlId != "" {
		var marshaler = struct {
			Type         string             `json:"type"`
			WebhookUrlId SecretCredentialId `json:"value"`
		}{
			Type:         "webhook_url_id",
			WebhookUrlId: t.WebhookUrlId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TeamsCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
	VisitWebhookUrl(*SecretCredential) error
	VisitWebhookUrlId(SecretCredentialId) error
}

func (t *TeamsCredential) Accept(visitor TeamsCredentialVisitor) error {
	if t.OAuthClient != nil {
		return visitor.VisitOAuthClient(t.OAuthClient)
	}
	if t.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(t.OAuthClientId)
	}
	if t.WebhookUrl != nil {
		return visitor.VisitWebhookUrl(t.WebhookUrl)
	}
	if t.WebhookUrlId != "" {
		return visitor.VisitWebhookUrlId(t.WebhookUrlId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TenableCloudCredential struct {
	Type string
	// Configuration when creating new API Keys.
	Token *TokenCredential
	// Reference to existing API Keys.
	TokenId TokenCredentialId
}

func (t *TenableCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (t TenableCloudCredential) MarshalJSON() ([]byte, error) {
	if t.Token != nil {
		return core.MarshalJSONWithExtraProperty(t.Token, "type", "token")
	}
	if t.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: t.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TenableCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (t *TenableCloudCredential) Accept(visitor TenableCloudCredentialVisitor) error {
	if t.Token != nil {
		return visitor.VisitToken(t.Token)
	}
	if t.TokenId != "" {
		return visitor.VisitTokenId(t.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

// Configuration for Autotask Operations Cloud.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/autotask-ticketing-setup)
type TicketingAutotask struct {
	ApiIntegrationCodeCredential *AutotaskApiIntegrationCodeCredential `json:"api_integration_code_credential" url:"api_integration_code_credential"`
	SecretCredential             *AutotaskSecretCredential             `json:"secret_credential" url:"secret_credential"`
	// User name of the API User created to authenticate with the Autotask API.
	UserName string `json:"user_name" url:"user_name"`
	// Zone for the Autotask API.
	ZonePath string `json:"zone_path" url:"zone_path"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingAutotask) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingAutotask) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingAutotask
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingAutotask(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingAutotask) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for Freshdesk.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/freshdesk-ticketing-setup)
type TicketingFreshdesk struct {
	Credential *FreshdeskCredential `json:"credential" url:"credential"`
	// Base URL to your Freshdesk tenant.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingFreshdesk) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingFreshdesk) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingFreshdesk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingFreshdesk(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingFreshdesk) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for Atlassian Jira.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/jira-ticketing-setup)
type TicketingJira struct {
	Credential *JiraCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Default Issue Type for the integration. If provided, the issue_type field becomes optional in ticket creation requests.
	DefaultIssueType *string `json:"default_issue_type,omitempty" url:"default_issue_type,omitempty"`
	// Default Project for the integration.
	DefaultProject *string `json:"default_project,omitempty" url:"default_project,omitempty"`
	// Base URL for the Jira API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingJira) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingJira) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingJira
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingJira(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingJira) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for the Synqly mock in-memory ticketing Provider. This provider is for testing purposes only. It retains tickets for a limited time and does not persist them for long-term usage.
type TicketingMock struct {
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Optional name of the mock provider. This value is unused.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingMock) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingMock) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingMock) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for PagerDuty Operations Cloud.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/pagerduty-ticketing-setup)
type TicketingPagerDuty struct {
	Credential *PagerDutyCredential `json:"credential" url:"credential"`
	// Base URL for the PagerDuty API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingPagerDuty) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingPagerDuty) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingPagerDuty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingPagerDuty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingPagerDuty) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for ServiceNow IT Service Management (ITSM).
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/servicenow-ticketing-setup)
type TicketingServiceNow struct {
	Credential *ServiceNowCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Default Project for the integration. This maps to the custom table for tickets. This table should be derived from Incident table. Defaults to the incident table if not specified.
	DefaultProject *string `json:"default_project,omitempty" url:"default_project,omitempty"`
	// Base URL for the ServiceNow API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingServiceNow) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingServiceNow) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingServiceNow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingServiceNow(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingServiceNow) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for ServiceNow Security Incident Response (SIR).
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/servicenow-ticketing-setup)
type TicketingServiceNowSir struct {
	Credential *ServiceNowCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Default Project for the integration. This maps to the custom table for tickets. This table should be derived from Security Incident table. Defaults to the security incident table if not specified.
	DefaultProject *string `json:"default_project,omitempty" url:"default_project,omitempty"`
	// Base URL for the ServiceNow API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingServiceNowSir) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingServiceNowSir) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingServiceNowSir
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingServiceNowSir(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingServiceNowSir) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for Torq.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/torq-ticketing-setup)
type TicketingTorq struct {
	Credential *TorqCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingTorq) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingTorq) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingTorq
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingTorq(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingTorq) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for Zendesk as a Ticketing Provider
type TicketingZendesk struct {
	Credential *ZendeskCredential `json:"credential" url:"credential"`
	// Base URL for your Zendesk tenant.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingZendesk) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingZendesk) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingZendesk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingZendesk(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingZendesk) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TorqCredential struct {
	Type string
	// Configuration when creating new Client Credentials.
	OAuthClient *OAuthClientCredential
	// Reference to existing Client Credentials.
	OAuthClientId OAuthClientCredentialId
}

func (t *TorqCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (t TorqCredential) MarshalJSON() ([]byte, error) {
	if t.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(t.OAuthClient, "type", "o_auth_client")
	}
	if t.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: t.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TorqCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (t *TorqCredential) Accept(visitor TorqCredentialVisitor) error {
	if t.OAuthClient != nil {
		return visitor.VisitOAuthClient(t.OAuthClient)
	}
	if t.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(t.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

type VulnerabilitiesQualysCloudDataset string

const (
	VulnerabilitiesQualysCloudDatasetBasicVer0 VulnerabilitiesQualysCloudDataset = "basic_v0"
)

func NewVulnerabilitiesQualysCloudDatasetFromString(s string) (VulnerabilitiesQualysCloudDataset, error) {
	switch s {
	case "basic_v0":
		return VulnerabilitiesQualysCloudDatasetBasicVer0, nil
	}
	var t VulnerabilitiesQualysCloudDataset
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VulnerabilitiesQualysCloudDataset) Ptr() *VulnerabilitiesQualysCloudDataset {
	return &v
}

type VulnerabilitiesRapid7InsightCloudDataset string

const (
	VulnerabilitiesRapid7InsightCloudDatasetBasicVer0 VulnerabilitiesRapid7InsightCloudDataset = "basic_v0"
)

func NewVulnerabilitiesRapid7InsightCloudDatasetFromString(s string) (VulnerabilitiesRapid7InsightCloudDataset, error) {
	switch s {
	case "basic_v0":
		return VulnerabilitiesRapid7InsightCloudDatasetBasicVer0, nil
	}
	var t VulnerabilitiesRapid7InsightCloudDataset
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VulnerabilitiesRapid7InsightCloudDataset) Ptr() *VulnerabilitiesRapid7InsightCloudDataset {
	return &v
}

type VulnerabilitiesTaniumCloudDataset string

const (
	VulnerabilitiesTaniumCloudDatasetBasicVer0 VulnerabilitiesTaniumCloudDataset = "basic_v0"
)

func NewVulnerabilitiesTaniumCloudDatasetFromString(s string) (VulnerabilitiesTaniumCloudDataset, error) {
	switch s {
	case "basic_v0":
		return VulnerabilitiesTaniumCloudDatasetBasicVer0, nil
	}
	var t VulnerabilitiesTaniumCloudDataset
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VulnerabilitiesTaniumCloudDataset) Ptr() *VulnerabilitiesTaniumCloudDataset {
	return &v
}

// Configuration for CrowdStrike Falcon® Spotlight.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/crowdstrike-vulns-setup)
type VulnerabilitiesCrowdStrike struct {
	// The credential to use for the CrowdStrike Falcon tenant.
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// Base URL for the CrowdStrike Falcon® Spotlight API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesCrowdStrike) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesCrowdStrike) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesCrowdStrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesCrowdStrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesCrowdStrike) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Nucleus Vulnerability Management.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/nucleus-vulns-setup)
type VulnerabilitiesNucleus struct {
	Credential *NucleusCredential `json:"credential" url:"credential"`
	// Numeric identifier for a Nucleus project.
	ProjectId string `json:"project_id" url:"project_id"`
	// Base URL for the Nucleus API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesNucleus) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesNucleus) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesNucleus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesNucleus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesNucleus) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Qualys Vulnerability Management, Detection & Response (VMDR).
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/qualys-vulns-setup)
type VulnerabilitiesQualysCloud struct {
	Credential *QualysCloudCredential `json:"credential" url:"credential"`
	// Base URL for the Qualys Cloud API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesQualysCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesQualysCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesQualysCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesQualysCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesQualysCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for a mocked Qualys Cloud Platform as a Vulnerabilities Provider
type VulnerabilitiesQualysCloudMock struct {
	Dataset VulnerabilitiesQualysCloudDataset `json:"dataset" url:"dataset"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesQualysCloudMock) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesQualysCloudMock) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesQualysCloudMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesQualysCloudMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesQualysCloudMock) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Rapid7 InsightVM.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/rapid7-vulns-setup)
type VulnerabilitiesRapid7InsightCloud struct {
	Credential *Rapid7InsightCloudCredential `json:"credential" url:"credential"`
	// Base URL for the Rapid7 InsightVM API.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesRapid7InsightCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesRapid7InsightCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesRapid7InsightCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesRapid7InsightCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesRapid7InsightCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for a mocked Rapid7 Insight Cloud as a Vulnerabilities Provider
type VulnerabilitiesRapid7InsightCloudMock struct {
	Dataset VulnerabilitiesRapid7InsightCloudDataset `json:"dataset" url:"dataset"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesRapid7InsightCloudMock) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesRapid7InsightCloudMock) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesRapid7InsightCloudMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesRapid7InsightCloudMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesRapid7InsightCloudMock) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Tanium Vulnerability Management.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/tanium-setup)
type VulnerabilitiesTaniumCloud struct {
	Credential *TaniumCloudCredential `json:"credential" url:"credential"`
	// Base URL for the Tanium Cloud API
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesTaniumCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesTaniumCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesTaniumCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesTaniumCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesTaniumCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for a mock Tanium Cloud as a Vulnerabilities Provider
type VulnerabilitiesTaniumCloudMock struct {
	Dataset VulnerabilitiesTaniumCloudDataset `json:"dataset" url:"dataset"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesTaniumCloudMock) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesTaniumCloudMock) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesTaniumCloudMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesTaniumCloudMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesTaniumCloudMock) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Tenable Vulnerability Management.
//
// [Configuration guide](https://docs.synqly.com/guides/provider-configuration/tenable-vulns-setup)
type VulnerabilitiesTenableCloud struct {
	Credential *TenableCloudCredential `json:"credential" url:"credential"`
	// Base URL for the Tenable Cloud API.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesTenableCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesTenableCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesTenableCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesTenableCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesTenableCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type ZendeskCredential struct {
	Type string
	// E-mail address and API Token for use with the Zendesk API. Use the e-mail address for the `username` field and API Token for the `secret` field. See [Zendesk API token generation documentation](https://developer.zendesk.com/api-reference/introduction/security-and-auth/#api-token) for more detail.
	Basic *BasicCredential
	// Reference to existing Basic Credentials.
	BasicId BasicCredentialId
}

func (z *ZendeskCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	z.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", z)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		z.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		z.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (z ZendeskCredential) MarshalJSON() ([]byte, error) {
	if z.Basic != nil {
		return core.MarshalJSONWithExtraProperty(z.Basic, "type", "basic")
	}
	if z.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: z.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", z)
}

type ZendeskCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (z *ZendeskCredential) Accept(visitor ZendeskCredentialVisitor) error {
	if z.Basic != nil {
		return visitor.VisitBasic(z.Basic)
	}
	if z.BasicId != "" {
		return visitor.VisitBasicId(z.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", z)
}

type AdhocRole struct {
	Resources     *Resources  `json:"resources" url:"resources"`
	PermissionSet Permissions `json:"permission_set" url:"permission_set"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdhocRole) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdhocRole) UnmarshalJSON(data []byte) error {
	type unmarshaler AdhocRole
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdhocRole(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AdhocRole) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Resources struct {
	Organizations *RoleOrganizations `json:"organizations,omitempty" url:"organizations,omitempty"`
	Accounts      *RoleAccounts      `json:"accounts,omitempty" url:"accounts,omitempty"`
	Integrations  *RoleIntegrations  `json:"integrations,omitempty" url:"integrations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Resources) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Resources) UnmarshalJSON(data []byte) error {
	type unmarshaler Resources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resources(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Resources) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleAccounts struct {
	// List of account ids that this role definition grants access to. Use "\*" to grant access to all account ids.
	Ids []AccountId `json:"ids" url:"ids"`
	// List of account labels this role definition grants access to. If both labels and environments are specified both must pass
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// Account environments this role definition grants access to. If both labels and environments are specified both must pass
	Environments []Environment `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleAccounts) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleAccounts) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleAccounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleAccounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RoleAccounts) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleIntegrations struct {
	// List of categories ids that this role definition grants access to. Use "\*" to grant access to all category ids.
	Categories []CategoryId `json:"categories" url:"categories"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleIntegrations) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleIntegrations) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleIntegrations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleIntegrations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RoleIntegrations) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Unique identifier for this Role
type RoleName = string

type RoleOrganizations struct {
	// List of organization ids that this role definition grants access to. Use "\*" to grant access to all organization ids.
	Ids []OrganizationId `json:"ids" url:"ids"`
	// List of organization labels this role definition grants access to.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleOrganizations) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleOrganizations) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleOrganizations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleOrganizations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RoleOrganizations) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type BuiltinRoles string

const (
	BuiltinRolesRootAdministrator BuiltinRoles = "root_administrator"
	BuiltinRolesAdministrator     BuiltinRoles = "administrator"
	BuiltinRolesViewer            BuiltinRoles = "viewer"
	BuiltinRolesMember            BuiltinRoles = "member"
)

func NewBuiltinRolesFromString(s string) (BuiltinRoles, error) {
	switch s {
	case "root_administrator":
		return BuiltinRolesRootAdministrator, nil
	case "administrator":
		return BuiltinRolesAdministrator, nil
	case "viewer":
		return BuiltinRolesViewer, nil
	case "member":
		return BuiltinRolesMember, nil
	}
	var t BuiltinRoles
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BuiltinRoles) Ptr() *BuiltinRoles {
	return &b
}

type RoleDefinition struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        RoleId    `json:"id" url:"id"`
	// Full name of role
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the resources included in the role and permissions granted on those resources. Includes details of when to use this role along with the intended personas.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Selects the resources the permission set applies to.
	Resources *Resources `json:"resources,omitempty" url:"resources,omitempty"`
	// Permission set for this role.
	PermissionSet Permissions `json:"permission_set" url:"permission_set"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleDefinition) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleDefinition) UnmarshalJSON(data []byte) error {
	type embed RoleDefinition
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RoleDefinition(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RoleDefinition) MarshalJSON() ([]byte, error) {
	type embed RoleDefinition
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (r *RoleDefinition) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type GetIntegrationTimeseriesResult = *GetStatusTimeseriesResult

// Status timeseries object
type GetStatusTimeseriesResult struct {
	// start time
	StartTime time.Time `json:"start_time" url:"start_time"`
	// end time
	EndTime time.Time `json:"end_time" url:"end_time"`
	// interval duration
	Interval string              `json:"interval" url:"interval"`
	Series   []*TimeseriesResult `json:"series" url:"series"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetStatusTimeseriesResult) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetStatusTimeseriesResult) UnmarshalJSON(data []byte) error {
	type embed GetStatusTimeseriesResult
	var unmarshaler = struct {
		embed
		StartTime *core.DateTime `json:"start_time"`
		EndTime   *core.DateTime `json:"end_time"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GetStatusTimeseriesResult(unmarshaler.embed)
	g.StartTime = unmarshaler.StartTime.Time()
	g.EndTime = unmarshaler.EndTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetStatusTimeseriesResult) MarshalJSON() ([]byte, error) {
	type embed GetStatusTimeseriesResult
	var marshaler = struct {
		embed
		StartTime *core.DateTime `json:"start_time"`
		EndTime   *core.DateTime `json:"end_time"`
	}{
		embed:     embed(*g),
		StartTime: core.NewDateTime(g.StartTime),
		EndTime:   core.NewDateTime(g.EndTime),
	}
	return json.Marshal(marshaler)
}

func (g *GetStatusTimeseriesResult) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Status object
type Status struct {
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// Account associated with this status. Use the expand=accounts parameter with the List API to expand the Account to the full object
	AccountId AccountId `json:"account_id" url:"account_id"`
	// When using the expand option on the List API, the full account object is included in the response
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// Integration associated with this status. Use the expand=integrations parameter with the List API to expand the Integration to the full object
	IntegrationId IntegrationId `json:"integration_id" url:"integration_id"`
	// When using the expand option on the List API, the full integration object is included in the response
	Integration *Integration `json:"integration,omitempty" url:"integration,omitempty"`
	// The current status of the notification.
	Status string `json:"status" url:"status"`
	// Request count
	Requests int64 `json:"requests" url:"requests"`
	// Failed count
	Failed int64 `json:"failed" url:"failed"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time" url:"cpu_time"`
	// Database operations count
	DbOps int64 `json:"db_ops" url:"db_ops"`
	// API operations count
	ApiOps int64 `json:"api_ops" url:"api_ops"`
	// API input byte count
	InBytes int64 `json:"in_bytes" url:"in_bytes"`
	// API output byte count
	OutBytes int64 `json:"out_bytes" url:"out_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Status) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Status) UnmarshalJSON(data []byte) error {
	type embed Status
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Status(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Status) MarshalJSON() ([]byte, error) {
	type embed Status
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
		UpdatedAt: core.NewDateTime(s.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Status) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Status event object
type StatusEvent struct {
	// Account owner
	AccountId AccountId `json:"account_id" url:"account_id"`
	// Integration object
	IntegrationId IntegrationId `json:"integration_id" url:"integration_id"`
	// Time created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The current status of the notification.
	Status string `json:"status" url:"status"`
	// Error message
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Request number
	Request int64 `json:"request" url:"request"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StatusEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StatusEvent) UnmarshalJSON(data []byte) error {
	type embed StatusEvent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = StatusEvent(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StatusEvent) MarshalJSON() ([]byte, error) {
	type embed StatusEvent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *StatusEvent) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TimeseriesOptions string

const (
	TimeseriesOptionsHour TimeseriesOptions = "hour"
)

func NewTimeseriesOptionsFromString(s string) (TimeseriesOptions, error) {
	switch s {
	case "hour":
		return TimeseriesOptionsHour, nil
	}
	var t TimeseriesOptions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeseriesOptions) Ptr() *TimeseriesOptions {
	return &t
}

// Status timeseries object
type TimeseriesResult struct {
	// Interval time
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Succeeded count
	Succeeded int64 `json:"succeeded" url:"succeeded"`
	// Failed count
	Failed int64 `json:"failed" url:"failed"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time" url:"cpu_time"`
	// API input byte count
	InBytes int64 `json:"in_bytes" url:"in_bytes"`
	// API output byte count
	OutBytes int64 `json:"out_bytes" url:"out_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeseriesResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeseriesResult) UnmarshalJSON(data []byte) error {
	type embed TimeseriesResult
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeseriesResult(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TimeseriesResult) MarshalJSON() ([]byte, error) {
	type embed TimeseriesResult
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TimeseriesResult) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Token struct {
	// Secret value for the token; used for authentication when making requests.
	Secret string `json:"secret" url:"secret"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires" url:"expires"`
	// Permissions granted to this token.
	Permissions *Permission `json:"permissions" url:"permissions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Token) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Token) UnmarshalJSON(data []byte) error {
	type embed Token
	var unmarshaler = struct {
		embed
		Expires *core.DateTime `json:"expires"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Token(unmarshaler.embed)
	t.Expires = unmarshaler.Expires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Token) MarshalJSON() ([]byte, error) {
	type embed Token
	var marshaler = struct {
		embed
		Expires *core.DateTime `json:"expires"`
	}{
		embed:   embed(*t),
		Expires: core.NewDateTime(t.Expires),
	}
	return json.Marshal(marshaler)
}

func (t *Token) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenOwnerType string

const (
	TokenOwnerTypeOrganization TokenOwnerType = "organization"
	TokenOwnerTypeIntegration  TokenOwnerType = "integration"
)

func NewTokenOwnerTypeFromString(s string) (TokenOwnerType, error) {
	switch s {
	case "organization":
		return TokenOwnerTypeOrganization, nil
	case "integration":
		return TokenOwnerTypeIntegration, nil
	}
	var t TokenOwnerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenOwnerType) Ptr() *TokenOwnerType {
	return &t
}

type TokenPair struct {
	// Access token contains the bearer secret
	Access *Token `json:"access" url:"access"`
	// Refresh token used for RefreshToken API
	Refresh *Token `json:"refresh" url:"refresh"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenPair) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenPair) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenPair
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenPair(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TokenPair) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type RefreshToken struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        TokenId   `json:"id" url:"id"`
	// Member Id
	MemberId *Id `json:"member_id,omitempty" url:"member_id,omitempty"`
	// ID of the entity that owns this token
	OwnerId Id `json:"owner_id" url:"owner_id"`
	// Type of the entity that owns this token
	OwnerType TokenOwnerType `json:"owner_type" url:"owner_type"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires" url:"expires"`
	// Token time-to-live
	TokenTtl string `json:"token_ttl" url:"token_ttl"`
	// Primary running access and refresh tokens
	Primary *TokenPair `json:"primary" url:"primary"`
	// Temporary secondary TokenPair created after a RefreshToken operation
	Secondary *TokenPair `json:"secondary,omitempty" url:"secondary,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefreshToken) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefreshToken) UnmarshalJSON(data []byte) error {
	type embed RefreshToken
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RefreshToken(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	r.Expires = unmarshaler.Expires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RefreshToken) MarshalJSON() ([]byte, error) {
	type embed RefreshToken
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
		Expires:   core.NewDateTime(r.Expires),
	}
	return json.Marshal(marshaler)
}

func (r *RefreshToken) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SynqlyIntegrationsTokenResponse struct {
	AccountId AccountId     `json:"account_id" url:"account_id"`
	Token     *RefreshToken `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SynqlyIntegrationsTokenResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SynqlyIntegrationsTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SynqlyIntegrationsTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SynqlyIntegrationsTokenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SynqlyIntegrationsTokenResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Usage struct {
	IntegrationId     Id      `json:"integration_id" url:"integration_id"`
	RequestsCount     float64 `json:"requests_count" url:"requests_count"`
	CpuTimeSeconds    float64 `json:"cpu_time_seconds" url:"cpu_time_seconds"`
	DbOperationsCount float64 `json:"db_operations_count" url:"db_operations_count"`
	IntOpsCount       float64 `json:"int_ops_count" url:"int_ops_count"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *Usage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Usage) UnmarshalJSON(data []byte) error {
	type unmarshaler Usage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Usage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = nil
	return nil
}

func (u *Usage) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
