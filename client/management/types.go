// This file was auto-generated by Fern from our API Definition.

package management

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/synqly/go-sdk/client/management/core"
	time "time"
)

// Unique identifier for this Account
type AccountId = Id

type Account struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        AccountId `json:"id" url:"id"`
	// Human friendly display name for this account.
	Fullname string `json:"fullname" url:"fullname"`
	// Organization that manages this Account.
	OrganizationId OrganizationId `json:"organization_id" url:"organization_id"`
	// Environment this account runs in.
	Environment Environment `json:"environment" url:"environment"`
	// User defined labels that apply to this account. These values can be used in role bindings to limit the scope of permissions.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type embed Account
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Account(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Account) MarshalJSON() ([]byte, error) {
	type embed Account
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Account) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type CreateAccountResponseResult struct {
	Account *Account `json:"account" url:"account"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAccountResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAccountResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAccountResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAccountResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateAccountResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Audit struct {
	Environment string `json:"environment" url:"environment"`
	// Time when the API request occurred.
	CreatedAt     time.Time      `json:"created_at" url:"created_at"`
	RemoteAddr    string         `json:"remote_addr" url:"remote_addr"`
	UserAgent     string         `json:"user_agent" url:"user_agent"`
	AuditType     AuditType      `json:"audit_type" url:"audit_type"`
	Method        HttpMethod     `json:"method" url:"method"`
	Path          string         `json:"path" url:"path"`
	Code          string         `json:"code" url:"code"`
	Body          interface{}    `json:"body,omitempty" url:"body,omitempty"`
	Response      *string        `json:"response,omitempty" url:"response,omitempty"`
	Status        *string        `json:"status,omitempty" url:"status,omitempty"`
	MemberId      *MemberId      `json:"member_id,omitempty" url:"member_id,omitempty"`
	AccountId     *AccountId     `json:"account_id,omitempty" url:"account_id,omitempty"`
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Audit) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Audit) UnmarshalJSON(data []byte) error {
	type embed Audit
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Audit(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Audit) MarshalJSON() ([]byte, error) {
	type embed Audit
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Audit) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuditType string

const (
	AuditTypeAlarm   AuditType = "ALARM"
	AuditTypeError   AuditType = "ERROR"
	AuditTypeApi     AuditType = "API"
	AuditTypeUnknown AuditType = "UNKNOWN"
)

func NewAuditTypeFromString(s string) (AuditType, error) {
	switch s {
	case "ALARM":
		return AuditTypeAlarm, nil
	case "ERROR":
		return AuditTypeError, nil
	case "API":
		return AuditTypeApi, nil
	case "UNKNOWN":
		return AuditTypeUnknown, nil
	}
	var t AuditType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuditType) Ptr() *AuditType {
	return &a
}

type HttpMethod string

const (
	HttpMethodDelete HttpMethod = "DELETE"
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "DELETE":
		return HttpMethodDelete, nil
	case "GET":
		return HttpMethodGet, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type AuthCode string

const (
	AuthCodeSuccess  AuthCode = "success"
	AuthCodeFailure  AuthCode = "failure"
	AuthCodeDisabled AuthCode = "disabled"
	AuthCodeExpired  AuthCode = "expired"
	AuthCodeInvited  AuthCode = "invited"
	AuthCodeLocked   AuthCode = "locked"
)

func NewAuthCodeFromString(s string) (AuthCode, error) {
	switch s {
	case "success":
		return AuthCodeSuccess, nil
	case "failure":
		return AuthCodeFailure, nil
	case "disabled":
		return AuthCodeDisabled, nil
	case "expired":
		return AuthCodeExpired, nil
	case "invited":
		return AuthCodeInvited, nil
	case "locked":
		return AuthCodeLocked, nil
	}
	var t AuthCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthCode) Ptr() *AuthCode {
	return &a
}

type ChangePasswordResponseResult struct {
	// Authentication result
	AuthCode AuthCode `json:"auth_code" url:"auth_code"`
	// Authentication failure message
	AuthMsg *string `json:"auth_msg,omitempty" url:"auth_msg,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChangePasswordResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChangePasswordResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ChangePasswordResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChangePasswordResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *ChangePasswordResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type LogonResponseResult struct {
	// Authentication result
	AuthCode AuthCode `json:"auth_code" url:"auth_code"`
	// Authentication failure message
	AuthMsg        *string       `json:"auth_msg,omitempty" url:"auth_msg,omitempty"`
	RefreshTokenId TokenId       `json:"refresh_token_id" url:"refresh_token_id"`
	Token          *TokenPair    `json:"token" url:"token"`
	Organization   *Organization `json:"organization" url:"organization"`
	Member         *Member       `json:"member" url:"member"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LogonResponseResult) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogonResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler LogonResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogonResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *LogonResponseResult) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A Bridge Group represents a connection between the Synqly Saas or Embedded service and a Bridge Agent. See 'Synqly Bridge Agent' guide in Synqly docs for additional information.
type BridgeGroup struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time     `json:"updated_at" url:"updated_at"`
	Id        BridgeGroupId `json:"id" url:"id"`
	// Full name of bridge
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the resources included in the bridge and permissions granted on those resources. Includes details of when to use this bridge along with the intended personas.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Labels applied to Bridges within the group. These labels can be used by integrations to select the groups of bridges capable of handling requests to the integration.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeGroup) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeGroup) UnmarshalJSON(data []byte) error {
	type embed BridgeGroup
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BridgeGroup(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeGroup) MarshalJSON() ([]byte, error) {
	type embed BridgeGroup
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BridgeGroup) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgeLocalConfig struct {
	// Version of the Bridge.
	Version string `json:"version" url:"version"`
	// List of IP addresses that the Bridge is allowed to connect to.
	AllowAddresses []string `json:"allow_addresses" url:"allow_addresses"`
	// Vault configuration for the Bridge.
	Vault map[string]string `json:"vault,omitempty" url:"vault,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeLocalConfig) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeLocalConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeLocalConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeLocalConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeLocalConfig) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgeLocalStats struct {
	Requests int64 `json:"requests" url:"requests"`
	Failures int64 `json:"failures" url:"failures"`
	InBytes  int64 `json:"in_bytes" url:"in_bytes"`
	OutBytes int64 `json:"out_bytes" url:"out_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeLocalStats) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeLocalStats) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeLocalStats
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeLocalStats(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeLocalStats) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgeStatus struct {
	// Local time on the Bridge when the status check was performed.
	CurrentTime time.Time `json:"current_time" url:"current_time"`
	// Round trip time for the status check.
	ResponseDuration string `json:"response_duration" url:"response_duration"`
	// Local configuration parameters for the Bridge.
	LocalConfig *BridgeLocalConfig `json:"local_config" url:"local_config"`
	// Local bridge statistics
	LocalStats *BridgeLocalStats `json:"local_stats" url:"local_stats"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeStatus) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeStatus) UnmarshalJSON(data []byte) error {
	type embed BridgeStatus
	var unmarshaler = struct {
		embed
		CurrentTime *core.DateTime `json:"current_time"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BridgeStatus(unmarshaler.embed)
	b.CurrentTime = unmarshaler.CurrentTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeStatus) MarshalJSON() ([]byte, error) {
	type embed BridgeStatus
	var marshaler = struct {
		embed
		CurrentTime *core.DateTime `json:"current_time"`
	}{
		embed:       embed(*b),
		CurrentTime: core.NewDateTime(b.CurrentTime),
	}
	return json.Marshal(marshaler)
}

func (b *BridgeStatus) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CreateBridgeResponseResult struct {
	Bridge *BridgeGroup `json:"bridge" url:"bridge"`
	// JWT for the Bridge Group to connect to Synqly. This must be saved in a file {bridgeId}.creds in the same directory as the bridge executable.
	Credential string `json:"credential" url:"credential"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateBridgeResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBridgeResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBridgeResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBridgeResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateBridgeResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Provides details of the Connector.
type Connector struct {
	// Unique identifier for the Connector.
	Id CategoryId `json:"id" url:"id"`
	// Name of the connector.
	Name CategoryId `json:"name" url:"name"`
	// Display name of the Connector.
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the Connector.
	Description string `json:"description" url:"description"`
	// List of Providers that implement the Connector.
	ProviderIds []ProviderId `json:"provider_ids" url:"provider_ids"`
	// List of capabilities for Providers that implement the Connector.
	Providers []*ProviderCapabilities `json:"providers,omitempty" url:"providers,omitempty"`
	// DEPRECATED – use `id` instead.
	Connector *CategoryId `json:"connector,omitempty" url:"connector,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Connector) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Connector) UnmarshalJSON(data []byte) error {
	type unmarshaler Connector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Connector(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Connector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectorOrId struct {
	CategoryId CategoryId
	Connector  *Connector
}

func (c *ConnectorOrId) UnmarshalJSON(data []byte) error {
	var valueCategoryId CategoryId
	if err := json.Unmarshal(data, &valueCategoryId); err == nil {
		c.CategoryId = valueCategoryId
		return nil
	}
	valueConnector := new(Connector)
	if err := json.Unmarshal(data, &valueConnector); err == nil {
		c.Connector = valueConnector
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, c)
}

func (c ConnectorOrId) MarshalJSON() ([]byte, error) {
	if c.CategoryId != "" {
		return json.Marshal(c.CategoryId)
	}
	if c.Connector != nil {
		return json.Marshal(c.Connector)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", c)
}

type ConnectorOrIdVisitor interface {
	VisitCategoryId(CategoryId) error
	VisitConnector(*Connector) error
}

func (c *ConnectorOrId) Accept(visitor ConnectorOrIdVisitor) error {
	if c.CategoryId != "" {
		return visitor.VisitCategoryId(c.CategoryId)
	}
	if c.Connector != nil {
		return visitor.VisitConnector(c.Connector)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", c)
}

type FilterOperation string

const (
	// Filter for exact matches.
	FilterOperationEquals FilterOperation = "eq"
	// Filter for non-matches.
	FilterOperationNotEquals FilterOperation = "neq"
	// Filter for values greater than the provided value.
	FilterOperationGreaterThan FilterOperation = "gt"
	// Filter for values less than the provided value.
	FilterOperationLessThan FilterOperation = "lt"
	// Filter for values greater than or equal to the provided value.
	FilterOperationGreaterThanOrEquals FilterOperation = "gte"
	// Filter for values less than or equal to the provided value.
	FilterOperationLessThanOrEquals FilterOperation = "lte"
	// Filter to match values in the provided comma-separated list.
	FilterOperationIn FilterOperation = "in"
	// Filter to match values that contain the provided value.
	FilterOperationLike FilterOperation = "like"
	// Filter to match values not in the provided comma-separated list.
	FilterOperationNotIn FilterOperation = "not in"
	// Filter to match values that do not contain the provided value.
	FilterOperationNotLike FilterOperation = "not like"
)

func NewFilterOperationFromString(s string) (FilterOperation, error) {
	switch s {
	case "eq":
		return FilterOperationEquals, nil
	case "neq":
		return FilterOperationNotEquals, nil
	case "gt":
		return FilterOperationGreaterThan, nil
	case "lt":
		return FilterOperationLessThan, nil
	case "gte":
		return FilterOperationGreaterThanOrEquals, nil
	case "lte":
		return FilterOperationLessThanOrEquals, nil
	case "in":
		return FilterOperationIn, nil
	case "like":
		return FilterOperationLike, nil
	case "not in":
		return FilterOperationNotIn, nil
	case "not like":
		return FilterOperationNotLike, nil
	}
	var t FilterOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterOperation) Ptr() *FilterOperation {
	return &f
}

type FilterType string

const (
	FilterTypeString   FilterType = "string"
	FilterTypeDatetime FilterType = "datetime"
	FilterTypeEnum     FilterType = "enum"
	FilterTypeBoolean  FilterType = "boolean"
	FilterTypeNumber   FilterType = "number"
)

func NewFilterTypeFromString(s string) (FilterType, error) {
	switch s {
	case "string":
		return FilterTypeString, nil
	case "datetime":
		return FilterTypeDatetime, nil
	case "enum":
		return FilterTypeEnum, nil
	case "boolean":
		return FilterTypeBoolean, nil
	case "number":
		return FilterTypeNumber, nil
	}
	var t FilterType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterType) Ptr() *FilterType {
	return &f
}

type ProviderCapabilities struct {
	// Unique identifier for the Provider.
	Id ProviderId `json:"id" url:"id"`
	// Name of the Provider.
	Name string `json:"name" url:"name"`
	// Display name of the Provider.
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the Provider.
	Description string `json:"description" url:"description"`
	// Id of the Connector that the Provider implements.
	ConnectorId CategoryId `json:"connector_id" url:"connector_id"`
	// Id of the Connector that the Provider implements – or, if
	// `expand=connector` is set – the details of the Connector. NOTE:
	// The current default behavior is to return the ID of the
	// Connector. This field will soon only be populated when
	// `expand=connector` is set in the APIs that support it. It is
	// recommended you use `connector_id` for a stable reference to the
	// Connector ID. This field will soon only be populated when
	// `expand=connector` is set in the APIs that support it.
	Connector *ConnectorOrId `json:"connector,omitempty" url:"connector,omitempty"`
	// Operations that the Provider implements.
	Operations []*ProviderOperations `json:"operations,omitempty" url:"operations,omitempty"`
	// Details on the specific configuration options for the Provider.
	ProviderConfig interface{} `json:"provider_config,omitempty" url:"provider_config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderCapabilities) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderCapabilities) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderCapabilities
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderCapabilities(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProviderCapabilities) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderFilter struct {
	// Name of the filter.
	Name string `json:"name" url:"name"`
	// Type of the value that this filter can apply to
	Type FilterType `json:"type" url:"type"`
	// List of operators that this filter supports.
	Operators []string `json:"operators" url:"operators"`
	// List of possible values for this filter.
	Values []string `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderFilter) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProviderFilter) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderOperations struct {
	// Unique identifier for the operation.
	Id string `json:"id" url:"id"`
	// Name of the operation.
	Name string `json:"name" url:"name"`
	// Display name of the operation.
	Fullname *string `json:"fullname,omitempty" url:"fullname,omitempty"`
	// Description of the operation.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// HTTP method used for the operation.
	RequestMethod *string `json:"request_method,omitempty" url:"request_method,omitempty"`
	// URI template path for the operation, including path parameters.
	RequestPath *string `json:"request_path,omitempty" url:"request_path,omitempty"`
	// Whether the operation is supported by the provider.
	Supported bool `json:"supported" url:"supported"`
	// List of fields in the request body that are required by the
	// provider for this operation. Due to limitations of the OpenAPI
	// format these fields may be marked as optional, even though they
	// are in fact required by this provider.
	RequiredFields []string `json:"required_fields,omitempty" url:"required_fields,omitempty"`
	// List of fields that may be returned in the response body. Any
	// fields not listed in this array are not supported by this
	// provider and will not be returned in the response body.
	SupportedResponseFields []string `json:"supported_response_fields,omitempty" url:"supported_response_fields,omitempty"`
	// Filters that can be applied to this operation.
	Filters []*ProviderFilter `json:"filters,omitempty" url:"filters,omitempty"`
	// This field is only available if the operation supports a request
	// body. Describes the request body and its schema.
	RequestBody *RequestBody `json:"request_body,omitempty" url:"request_body,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProviderOperations) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProviderOperations) UnmarshalJSON(data []byte) error {
	type unmarshaler ProviderOperations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProviderOperations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProviderOperations) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Describes the request body and its schema.
type RequestBody struct {
	// If true the request body is required, false otherwise.
	Required bool `json:"required" url:"required"`
	// The schema defining the type used for the request body. If
	// expanded will be a full JSON schema of the entire request body,
	// otherwise this will be a reference object. The reference object
	// has a single key `$ref`, which is a URI [RFC3986] identifying the
	// location of a component within the Engine OpenAPI specification.
	Schema map[string]interface{} `json:"schema" url:"schema"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RequestBody) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RequestBody) UnmarshalJSON(data []byte) error {
	type unmarshaler RequestBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RequestBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RequestBody) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Id of the Integrations category
type CategoryId string

const (
	CategoryIdAssets          CategoryId = "assets"
	CategoryIdEdr             CategoryId = "edr"
	CategoryIdIdentity        CategoryId = "identity"
	CategoryIdNotifications   CategoryId = "notifications"
	CategoryIdSiem            CategoryId = "siem"
	CategoryIdSink            CategoryId = "sink"
	CategoryIdStorage         CategoryId = "storage"
	CategoryIdTicketing       CategoryId = "ticketing"
	CategoryIdVulnerabilities CategoryId = "vulnerabilities"
)

func NewCategoryIdFromString(s string) (CategoryId, error) {
	switch s {
	case "assets":
		return CategoryIdAssets, nil
	case "edr":
		return CategoryIdEdr, nil
	case "identity":
		return CategoryIdIdentity, nil
	case "notifications":
		return CategoryIdNotifications, nil
	case "siem":
		return CategoryIdSiem, nil
	case "sink":
		return CategoryIdSink, nil
	case "storage":
		return CategoryIdStorage, nil
	case "ticketing":
		return CategoryIdTicketing, nil
	case "vulnerabilities":
		return CategoryIdVulnerabilities, nil
	}
	var t CategoryId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryId) Ptr() *CategoryId {
	return &c
}

type ProviderId = string

type Base struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Base) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Base) UnmarshalJSON(data []byte) error {
	type embed Base
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Base(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *Base) MarshalJSON() ([]byte, error) {
	type embed Base
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *Base) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ErrorBody struct {
	Status     int           `json:"status" url:"status"`
	Message    *string       `json:"message,omitempty" url:"message,omitempty"`
	Errors     []string      `json:"errors,omitempty" url:"errors,omitempty"`
	Parameters []*ErrorParam `json:"parameters,omitempty" url:"parameters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ErrorBody) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *ErrorBody) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorParam struct {
	Name  string `json:"name" url:"name"`
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ErrorParam) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorParam) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorParam
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorParam(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *ErrorParam) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Id = string

type PatchOp string

const (
	PatchOpAdd     PatchOp = "add"
	PatchOpCopy    PatchOp = "copy"
	PatchOpMove    PatchOp = "move"
	PatchOpRemove  PatchOp = "remove"
	PatchOpReplace PatchOp = "replace"
	PatchOpTest    PatchOp = "test"
)

func NewPatchOpFromString(s string) (PatchOp, error) {
	switch s {
	case "add":
		return PatchOpAdd, nil
	case "copy":
		return PatchOpCopy, nil
	case "move":
		return PatchOpMove, nil
	case "remove":
		return PatchOpRemove, nil
	case "replace":
		return PatchOpReplace, nil
	case "test":
		return PatchOpTest, nil
	}
	var t PatchOp
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PatchOp) Ptr() *PatchOp {
	return &p
}

// JSON patch to apply. A JSON patch is a list of patch operations. (see https://jsonpatch.com/)
type PatchOperation struct {
	// The operation to perform. Supported values are `add`, `copy`, `move`, `replace`, `remove`, and `test`.
	Op PatchOp `json:"op" url:"op"`
	// The path to the field to update. The path is a JSON Pointer.
	Path string `json:"path" url:"path"`
	// The path to the field to copy from. This is required for `copy` and `move` operations.
	From *string `json:"from,omitempty" url:"from,omitempty"`
	// The value to set the field to. This is required for `add`, `replace` and `test` operations.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PatchOperation) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchOperation) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchOperation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchOperation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *PatchOperation) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// AWS access key to authenticate with AWS. Access keys are long-term credentials for an IAM user and consist of an ID and secret. Follow [this guide to generate access and secret keys](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys). You may optionally provide a session token if you are using temporary credentials.
type AwsCredential struct {
	// ID portion of the AWS access key pair.
	AccessKeyId string `json:"access_key_id" url:"access_key_id"`
	// Secret portion of the AWS access key pair.
	SecretAccessKey string `json:"secret_access_key" url:"secret_access_key"`
	// A temporary session token. Session tokens are optional and are only necessary if you are using temporary credentials.
	Session *string `json:"session,omitempty" url:"session,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AwsCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AwsCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler AwsCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AwsCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AwsCredential) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Unique identifier for an AWS Credential
type AwsCredentialId = CredentialId

// Username and secret used to authenticate with an external service.
type BasicCredential struct {
	// Username value for authentication
	Username string `json:"username" url:"username"`
	// Secret value for authentication
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BasicCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BasicCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Unique identifier for a basic auth Credential
type BasicCredentialId = CredentialId

// AWS access key to authenticate with AWS. Access keys are long-term credentials for an IAM user and consist of an ID and secret. Follow [this guide to generate access and secret keys](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys). You may optionally provide a session token if you are using temporary credentials.
type BridgeAwsCredential struct {
	// ID portion of the AWS access key pair.
	AccessKeyId *BridgeLocalCredential `json:"access_key_id" url:"access_key_id"`
	// Secret portion of the AWS access key pair.
	SecretAccessKey *BridgeLocalCredential `json:"secret_access_key" url:"secret_access_key"`
	// A temporary session token. Session tokens are optional and are only necessary if you are using temporary credentials.
	Session *BridgeLocalCredential `json:"session,omitempty" url:"session,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeAwsCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeAwsCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeAwsCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeAwsCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeAwsCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Username and secret used to authenticate with an external service. These fields contain the keys to the local credential store.
type BridgeBasicCredential struct {
	// Username value for authentication
	Username *BridgeLocalCredential `json:"username" url:"username"`
	// Secret value for authentication
	Secret *BridgeLocalCredential `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeBasicCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeBasicCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeBasicCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeBasicCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeBasicCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Unique identifier for a bridge basic auth Credential
type BridgeBasicCredentialId = CredentialId

type BridgeCredential struct {
	Type              string
	BridgeAws         *BridgeAwsCredential
	BridgeToken       *BridgeTokenCredential
	BridgeBasic       *BridgeBasicCredential
	BridgeSecret      *BridgeSecretCredential
	BridgeOAuthClient *BridgeOAuthClientCredential
}

func (b *BridgeCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "bridge_aws":
		value := new(BridgeAwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.BridgeAws = value
	case "bridge_token":
		value := new(BridgeTokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.BridgeToken = value
	case "bridge_basic":
		value := new(BridgeBasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.BridgeBasic = value
	case "bridge_secret":
		value := new(BridgeSecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.BridgeSecret = value
	case "bridge_o_auth_client":
		value := new(BridgeOAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.BridgeOAuthClient = value
	}
	return nil
}

func (b BridgeCredential) MarshalJSON() ([]byte, error) {
	if b.BridgeAws != nil {
		return core.MarshalJSONWithExtraProperty(b.BridgeAws, "type", "bridge_aws")
	}
	if b.BridgeToken != nil {
		return core.MarshalJSONWithExtraProperty(b.BridgeToken, "type", "bridge_token")
	}
	if b.BridgeBasic != nil {
		return core.MarshalJSONWithExtraProperty(b.BridgeBasic, "type", "bridge_basic")
	}
	if b.BridgeSecret != nil {
		return core.MarshalJSONWithExtraProperty(b.BridgeSecret, "type", "bridge_secret")
	}
	if b.BridgeOAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(b.BridgeOAuthClient, "type", "bridge_o_auth_client")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BridgeCredentialVisitor interface {
	VisitBridgeAws(*BridgeAwsCredential) error
	VisitBridgeToken(*BridgeTokenCredential) error
	VisitBridgeBasic(*BridgeBasicCredential) error
	VisitBridgeSecret(*BridgeSecretCredential) error
	VisitBridgeOAuthClient(*BridgeOAuthClientCredential) error
}

func (b *BridgeCredential) Accept(visitor BridgeCredentialVisitor) error {
	if b.BridgeAws != nil {
		return visitor.VisitBridgeAws(b.BridgeAws)
	}
	if b.BridgeToken != nil {
		return visitor.VisitBridgeToken(b.BridgeToken)
	}
	if b.BridgeBasic != nil {
		return visitor.VisitBridgeBasic(b.BridgeBasic)
	}
	if b.BridgeSecret != nil {
		return visitor.VisitBridgeSecret(b.BridgeSecret)
	}
	if b.BridgeOAuthClient != nil {
		return visitor.VisitBridgeOAuthClient(b.BridgeOAuthClient)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BridgeEnvironment struct {
	// system environment variable to retrieve value from.
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeEnvironment) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeEnvironment) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeEnvironment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeEnvironment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeEnvironment) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgeLiteral struct {
	// literal value to use
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeLiteral) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeLiteral) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeLiteral
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeLiteral(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeLiteral) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BridgeLocalCredential struct {
	Type        string
	Literal     *BridgeLiteral
	Environment *BridgeEnvironment
	Vault       *VaultCredential
}

func (b *BridgeLocalCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "literal":
		value := new(BridgeLiteral)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Literal = value
	case "environment":
		value := new(BridgeEnvironment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Environment = value
	case "vault":
		value := new(VaultCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Vault = value
	}
	return nil
}

func (b BridgeLocalCredential) MarshalJSON() ([]byte, error) {
	if b.Literal != nil {
		return core.MarshalJSONWithExtraProperty(b.Literal, "type", "literal")
	}
	if b.Environment != nil {
		return core.MarshalJSONWithExtraProperty(b.Environment, "type", "environment")
	}
	if b.Vault != nil {
		return core.MarshalJSONWithExtraProperty(b.Vault, "type", "vault")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BridgeLocalCredentialVisitor interface {
	VisitLiteral(*BridgeLiteral) error
	VisitEnvironment(*BridgeEnvironment) error
	VisitVault(*VaultCredential) error
}

func (b *BridgeLocalCredential) Accept(visitor BridgeLocalCredentialVisitor) error {
	if b.Literal != nil {
		return visitor.VisitLiteral(b.Literal)
	}
	if b.Environment != nil {
		return visitor.VisitEnvironment(b.Environment)
	}
	if b.Vault != nil {
		return visitor.VisitVault(b.Vault)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

// A Client ID and secret used for authenticating with OAuth 2.0 compatible service using the client credentials grant. ClientId and ClientSecret contain the keys to the local credential store.
type BridgeOAuthClientCredential struct {
	// Optional URL for the OAuth 2.0 token exchange if it can not be constructed based on provider configuration
	TokenUrl *BridgeLocalCredential `json:"token_url,omitempty" url:"token_url,omitempty"`
	// The ID of the client application defined at the service provider
	ClientId *BridgeLocalCredential `json:"client_id" url:"client_id"`
	// Secret value for authentication
	ClientSecret *BridgeLocalCredential `json:"client_secret" url:"client_secret"`
	// Optional connection specific meta data such as a signing key ID or organization ID
	Extra *BridgeLocalCredential `json:"extra,omitempty" url:"extra,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeOAuthClientCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeOAuthClientCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeOAuthClientCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeOAuthClientCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeOAuthClientCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Unique identifier for an bridge OAuth client Credential
type BridgeOAuthClientCredentialId = CredentialId

// Secret value such as password or webhook url. Secret contain the key to the local credential store.
type BridgeSecretCredential struct {
	// Secret value
	Secret *BridgeLocalCredential `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeSecretCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeSecretCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeSecretCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeSecretCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeSecretCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Unique identifier for an bridge secret Credential
type BridgeSecretCredentialId = CredentialId

// Token used to authenticate with an external service. Secret contain the key to the local credential store.
type BridgeTokenCredential struct {
	// Secret value of the token.
	Secret *BridgeLocalCredential `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeTokenCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeTokenCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgeTokenCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgeTokenCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgeTokenCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Unique identifier for a bridge token Credential
type BridgeTokenCredentialId = CredentialId

type BridgeType string

const (
	BridgeTypeBridgeAws           BridgeType = "bridge_aws"
	BridgeTypeBridgeAwsId         BridgeType = "bridge_aws_id"
	BridgeTypeBridgeToken         BridgeType = "bridge_token"
	BridgeTypeBridgeTokenId       BridgeType = "bridge_token_id"
	BridgeTypeBridgeBasic         BridgeType = "bridge_basic"
	BridgeTypeBridgeBasicId       BridgeType = "bridge_basic_id"
	BridgeTypeBridgeSecret        BridgeType = "bridge_secret"
	BridgeTypeBridgeSecretId      BridgeType = "bridge_secret_id"
	BridgeTypeBridgeOAuthClient   BridgeType = "bridge_o_auth_client"
	BridgeTypeBridgeOAuthClientId BridgeType = "bridge_o_auth_client_id"
)

func NewBridgeTypeFromString(s string) (BridgeType, error) {
	switch s {
	case "bridge_aws":
		return BridgeTypeBridgeAws, nil
	case "bridge_aws_id":
		return BridgeTypeBridgeAwsId, nil
	case "bridge_token":
		return BridgeTypeBridgeToken, nil
	case "bridge_token_id":
		return BridgeTypeBridgeTokenId, nil
	case "bridge_basic":
		return BridgeTypeBridgeBasic, nil
	case "bridge_basic_id":
		return BridgeTypeBridgeBasicId, nil
	case "bridge_secret":
		return BridgeTypeBridgeSecret, nil
	case "bridge_secret_id":
		return BridgeTypeBridgeSecretId, nil
	case "bridge_o_auth_client":
		return BridgeTypeBridgeOAuthClient, nil
	case "bridge_o_auth_client_id":
		return BridgeTypeBridgeOAuthClientId, nil
	}
	var t BridgeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BridgeType) Ptr() *BridgeType {
	return &b
}

// Credential to access an integration. Each credential is owned by an Account, Integration, IntegrationPoint or OrganizationWebhook.
type Credential struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at" url:"updated_at"`
	Id        CredentialId `json:"id" url:"id"`
	// Account that manages this credential.
	AccountId *AccountId `json:"account_id,omitempty" url:"account_id,omitempty"`
	// Integration associated with this credential.
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`
	// Integration Point associated with this credential.
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// Organization Webhook associated with this credential.
	OrganizationWebhookId *WebhookId `json:"organization_webhook_id,omitempty" url:"organization_webhook_id,omitempty"`
	// One of `account` or `integration_point`.
	OwnerType OwnerType `json:"owner_type" url:"owner_type"`
	// Human friendly display name for this Credential
	Fullname string `json:"fullname" url:"fullname"`
	// Credential configuration
	Config *CredentialConfig `json:"config,omitempty" url:"config,omitempty"`
	// Time when this credential expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`
	// Field is set by the management process. Determines lifecycle and ownership of the credential.
	Managed ManagedType `json:"managed" url:"managed"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Credential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Credential) UnmarshalJSON(data []byte) error {
	type embed Credential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Credential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Credential) MarshalJSON() ([]byte, error) {
	type embed Credential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Expires:   core.NewOptionalDateTime(c.Expires),
	}
	return json.Marshal(marshaler)
}

func (c *Credential) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Base type for all credential types
type CredentialBase struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialBase) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialBase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CredentialBase) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialConfig struct {
	Type        string
	Aws         *AwsCredential
	Token       *TokenCredential
	Basic       *BasicCredential
	Secret      *SecretCredential
	OAuthClient *OAuthClientCredential
	Bridge      *BridgeCredential
}

func (c *CredentialConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Aws = value
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Token = value
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Basic = value
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Secret = value
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.OAuthClient = value
	case "bridge":
		var valueUnmarshaler struct {
			Bridge *BridgeCredential `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Bridge = valueUnmarshaler.Bridge
	}
	return nil
}

func (c CredentialConfig) MarshalJSON() ([]byte, error) {
	if c.Aws != nil {
		return core.MarshalJSONWithExtraProperty(c.Aws, "type", "aws")
	}
	if c.Token != nil {
		return core.MarshalJSONWithExtraProperty(c.Token, "type", "token")
	}
	if c.Basic != nil {
		return core.MarshalJSONWithExtraProperty(c.Basic, "type", "basic")
	}
	if c.Secret != nil {
		return core.MarshalJSONWithExtraProperty(c.Secret, "type", "secret")
	}
	if c.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(c.OAuthClient, "type", "o_auth_client")
	}
	if c.Bridge != nil {
		var marshaler = struct {
			Type   string            `json:"type"`
			Bridge *BridgeCredential `json:"value"`
		}{
			Type:   "bridge",
			Bridge: c.Bridge,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CredentialConfigVisitor interface {
	VisitAws(*AwsCredential) error
	VisitToken(*TokenCredential) error
	VisitBasic(*BasicCredential) error
	VisitSecret(*SecretCredential) error
	VisitOAuthClient(*OAuthClientCredential) error
	VisitBridge(*BridgeCredential) error
}

func (c *CredentialConfig) Accept(visitor CredentialConfigVisitor) error {
	if c.Aws != nil {
		return visitor.VisitAws(c.Aws)
	}
	if c.Token != nil {
		return visitor.VisitToken(c.Token)
	}
	if c.Basic != nil {
		return visitor.VisitBasic(c.Basic)
	}
	if c.Secret != nil {
		return visitor.VisitSecret(c.Secret)
	}
	if c.OAuthClient != nil {
		return visitor.VisitOAuthClient(c.OAuthClient)
	}
	if c.Bridge != nil {
		return visitor.VisitBridge(c.Bridge)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CredentialConfigNoSecret struct {
	Type string `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialConfigNoSecret) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialConfigNoSecret) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialConfigNoSecret
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialConfigNoSecret(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CredentialConfigNoSecret) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response object for a Credential
type CredentialResponse struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at" url:"updated_at"`
	Id        CredentialId `json:"id" url:"id"`
	// Account that manages this credential.
	AccountId *AccountId `json:"account_id,omitempty" url:"account_id,omitempty"`
	// Integration associated with this credential.
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`
	// Integration Point associated with this credential.
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// Integration Point associated with this credential.
	OrganizationWebhookId *WebhookId `json:"organization_webhook_id,omitempty" url:"organization_webhook_id,omitempty"`
	// One of `account` or `integration_point`.
	OwnerType OwnerType `json:"owner_type" url:"owner_type"`
	// Human friendly display name for this Credential. Defaults to the same value as the 'name' field if not specified.
	Fullname string                    `json:"fullname" url:"fullname"`
	Config   *CredentialConfigNoSecret `json:"config" url:"config"`
	// Time when this credential expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`
	// Field is set by the management process. Determines lifecycle and ownership of the credential.
	Managed ManagedType `json:"managed" url:"managed"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialResponse) UnmarshalJSON(data []byte) error {
	type embed CredentialResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CredentialResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CredentialResponse) MarshalJSON() ([]byte, error) {
	type embed CredentialResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Expires:   core.NewOptionalDateTime(c.Expires),
	}
	return json.Marshal(marshaler)
}

func (c *CredentialResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialType string

const (
	CredentialTypeAws         CredentialType = "aws"
	CredentialTypeToken       CredentialType = "token"
	CredentialTypeBasic       CredentialType = "basic"
	CredentialTypeSecret      CredentialType = "secret"
	CredentialTypeOAuthClient CredentialType = "o_auth_client"
	CredentialTypeBridge      CredentialType = "bridge"
)

func NewCredentialTypeFromString(s string) (CredentialType, error) {
	switch s {
	case "aws":
		return CredentialTypeAws, nil
	case "token":
		return CredentialTypeToken, nil
	case "basic":
		return CredentialTypeBasic, nil
	case "secret":
		return CredentialTypeSecret, nil
	case "o_auth_client":
		return CredentialTypeOAuthClient, nil
	case "bridge":
		return CredentialTypeBridge, nil
	}
	var t CredentialType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialType) Ptr() *CredentialType {
	return &c
}

type LocalType string

const (
	LocalTypeLiteral     LocalType = "literal"
	LocalTypeEnvironment LocalType = "environment"
	LocalTypeVault       LocalType = "vault"
)

func NewLocalTypeFromString(s string) (LocalType, error) {
	switch s {
	case "literal":
		return LocalTypeLiteral, nil
	case "environment":
		return LocalTypeEnvironment, nil
	case "vault":
		return LocalTypeVault, nil
	}
	var t LocalType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocalType) Ptr() *LocalType {
	return &l
}

type ManagedType string

const (
	ManagedTypeManaged   ManagedType = "Managed"
	ManagedTypeUnmanaged ManagedType = "Unmanaged"
)

func NewManagedTypeFromString(s string) (ManagedType, error) {
	switch s {
	case "Managed":
		return ManagedTypeManaged, nil
	case "Unmanaged":
		return ManagedTypeUnmanaged, nil
	}
	var t ManagedType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ManagedType) Ptr() *ManagedType {
	return &m
}

// A Client ID and secret used for authenticating with OAuth 2.0 compatible service using the client credentials grant.
type OAuthClientCredential struct {
	// Optional URL for the OAuth 2.0 token exchange if it can not be constructed based on provider configuration
	TokenUrl *string `json:"token_url,omitempty" url:"token_url,omitempty"`
	// The ID of the client application defined at the service provider
	ClientId string `json:"client_id" url:"client_id"`
	// Secret value for authentication
	ClientSecret string `json:"client_secret" url:"client_secret"`
	// Optional connection specific JSON map data such as a signing key ID or organization ID
	Extra map[string]interface{} `json:"extra,omitempty" url:"extra,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OAuthClientCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthClientCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthClientCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthClientCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OAuthClientCredential) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Unique identifier for an OAuth client Credential
type OAuthClientCredentialId = CredentialId

type OwnerType string

const (
	OwnerTypeAccount             OwnerType = "account"
	OwnerTypeIntegration         OwnerType = "integration"
	OwnerTypeIntegrationPoint    OwnerType = "integration_point"
	OwnerTypeOrganizationWebhook OwnerType = "organization_webhook"
)

func NewOwnerTypeFromString(s string) (OwnerType, error) {
	switch s {
	case "account":
		return OwnerTypeAccount, nil
	case "integration":
		return OwnerTypeIntegration, nil
	case "integration_point":
		return OwnerTypeIntegrationPoint, nil
	case "organization_webhook":
		return OwnerTypeOrganizationWebhook, nil
	}
	var t OwnerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OwnerType) Ptr() *OwnerType {
	return &o
}

// Secret value such as password or webhook url
type SecretCredential struct {
	// Secret value
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SecretCredential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecretCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler SecretCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecretCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SecretCredential) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Unique identifier for a secret Credential
type SecretCredentialId = CredentialId

// Token used to authenticate with an external service.
type TokenCredential struct {
	// Secret value of the token.
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TokenCredential) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Unique identifier for a token Credential
type TokenCredentialId = CredentialId

type VaultCredential struct {
	// path (including item) to secret store in vault secret storage.
	Path string `json:"path" url:"path"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VaultCredential) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VaultCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler VaultCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VaultCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VaultCredential) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Unique identifier for this Integration
type IntegrationId = Id

type IntegrationEnvironments struct {
	// List of allowed providers for test environment.
	Test []ProviderConfigId `json:"test,omitempty" url:"test,omitempty"`
	// List of allowed providers for production environment.
	Prod []ProviderConfigId `json:"prod,omitempty" url:"prod,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationEnvironments) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationEnvironments(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationEnvironments) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Enables creation, editing and deletion of Integrations.
type IntegrationPoint struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time          `json:"updated_at" url:"updated_at"`
	Id        IntegrationPointId `json:"id" url:"id"`
	// Name of integration point, will be shown to end-users in the Connect UI.
	Fullname *string `json:"fullname,omitempty" url:"fullname,omitempty"`
	// Optional description of the Integration Point. Will not be displayed to end-users of Connect UI.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Connector to use for the Integration Point.
	Connector CategoryId `json:"connector" url:"connector"`
	// Selects providers to use for account environments.
	Environments *IntegrationEnvironments `json:"environments" url:"environments"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationPoint) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationPoint) UnmarshalJSON(data []byte) error {
	type embed IntegrationPoint
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = IntegrationPoint(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationPoint) MarshalJSON() ([]byte, error) {
	type embed IntegrationPoint
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*i),
		CreatedAt: core.NewDateTime(i.CreatedAt),
		UpdatedAt: core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *IntegrationPoint) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type BridgeSelector struct {
	Type string
	// ID of a specific bridge group to use
	Id string
	// Labels the bridge group must have. If multiple labels are provided, the first bridge group that has any one of the labels will be selected.
	Labels []string
}

func (b *BridgeSelector) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "id":
		var valueUnmarshaler struct {
			Id string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		b.Id = valueUnmarshaler.Id
	case "labels":
		var valueUnmarshaler struct {
			Labels []string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		b.Labels = valueUnmarshaler.Labels
	}
	return nil
}

func (b BridgeSelector) MarshalJSON() ([]byte, error) {
	if b.Id != "" {
		var marshaler = struct {
			Type string `json:"type"`
			Id   string `json:"value"`
		}{
			Type: "id",
			Id:   b.Id,
		}
		return json.Marshal(marshaler)
	}
	if b.Labels != nil {
		var marshaler = struct {
			Type   string   `json:"type"`
			Labels []string `json:"value"`
		}{
			Type:   "labels",
			Labels: b.Labels,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BridgeSelectorVisitor interface {
	VisitId(string) error
	VisitLabels([]string) error
}

func (b *BridgeSelector) Accept(visitor BridgeSelectorVisitor) error {
	if b.Id != "" {
		return visitor.VisitId(b.Id)
	}
	if b.Labels != nil {
		return visitor.VisitLabels(b.Labels)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

type CreateIntegrationResponseResult struct {
	CredentialsCreated []*CredentialResponse `json:"credentials_created,omitempty" url:"credentials_created,omitempty"`
	Integration        *Integration          `json:"integration" url:"integration"`
	Token              *TokenPair            `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateIntegrationResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateIntegrationResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateIntegrationResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateIntegrationResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateIntegrationResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Connects an Account to an external service
type Integration struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time     `json:"updated_at" url:"updated_at"`
	Id        IntegrationId `json:"id" url:"id"`
	// Human friendly display name for this integration.
	Fullname string `json:"fullname" url:"fullname"`
	// Integration refresh token id
	RefreshTokenId TokenId `json:"refresh_token_id" url:"refresh_token_id"`
	// Account associated with this integration. Use the expand=accounts parameter with the List and ListAccount APIs to expand the Account to the full object
	AccountId AccountId `json:"account_id" url:"account_id"`
	// When using the expand option on the List or ListAccount APIs, the full account object is included in the response
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// Id of the Connector Category for this Integration.
	Category CategoryId `json:"category" url:"category"`
	// Provider configuration for this Integration.
	ProviderConfig *ProviderConfig `json:"provider_config" url:"provider_config"`
	// Human friendly display name for the provider.
	ProviderFullname string `json:"provider_fullname" url:"provider_fullname"`
	// Type of the provider for this Integration.
	ProviderType string `json:"provider_type" url:"provider_type"`
	// Integration Point associated with this integration. Use the expand=integration_points parameter with the List and ListAccount APIs to expand the Integration Point to the full object
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// When using the expand option on the List or ListAccount APIs, the full integration_point object is included in the response
	IntegrationPoint *IntegrationPoint `json:"integration_point,omitempty" url:"integration_point,omitempty"`
	// Use a Bridge to connect to the provider.
	BridgeSelector *BridgeSelector `json:"bridge_selector,omitempty" url:"bridge_selector,omitempty"`
	// Webhook configuration for this integration. Some providers support webhooks, and will allow end users providers to send events to a server for new or updated data.
	WebhookConfig *WebhookConfig `json:"webhook_config,omitempty" url:"webhook_config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Integration) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Integration) UnmarshalJSON(data []byte) error {
	type embed Integration
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Integration(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *Integration) MarshalJSON() ([]byte, error) {
	type embed Integration
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*i),
		CreatedAt: core.NewDateTime(i.CreatedAt),
		UpdatedAt: core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *Integration) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type WebhookConfig struct {
	// List of webhooks for an integration. If the provider supports webhooks, they will be sent to the servers provided in this list.
	Items []*WebhookItem `json:"items" url:"items"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhookConfig) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *WebhookConfig) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookEvent string

const (
	WebhookEventTicketCreated        WebhookEvent = "TicketCreated"
	WebhookEventTicketUpdated        WebhookEvent = "TicketUpdated"
	WebhookEventTicketDeleted        WebhookEvent = "TicketDeleted"
	WebhookEventTicketCommentCreated WebhookEvent = "TicketCommentCreated"
	WebhookEventTicketCommentDeleted WebhookEvent = "TicketCommentDeleted"
)

func NewWebhookEventFromString(s string) (WebhookEvent, error) {
	switch s {
	case "TicketCreated":
		return WebhookEventTicketCreated, nil
	case "TicketUpdated":
		return WebhookEventTicketUpdated, nil
	case "TicketDeleted":
		return WebhookEventTicketDeleted, nil
	case "TicketCommentCreated":
		return WebhookEventTicketCommentCreated, nil
	case "TicketCommentDeleted":
		return WebhookEventTicketCommentDeleted, nil
	}
	var t WebhookEvent
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookEvent) Ptr() *WebhookEvent {
	return &w
}

type WebhookItem struct {
	// Webhook URL. Events from providers will be sent to this URL.
	WebhookUrl string `json:"webhook_url" url:"webhook_url"`
	// If specified, only events matching this list will be sent to `webhook_url`. If no filters are specified, all events sent from providers will be forwarded to `webhook_url`.
	EventFilter []WebhookEvent `json:"event_filter,omitempty" url:"event_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhookItem) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookItem) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *WebhookItem) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type CreateMemberResponseResult struct {
	Member *Member `json:"member" url:"member"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateMemberResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMemberResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateMemberResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateMemberResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateMemberResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Member struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        MemberId  `json:"id" url:"id"`
	State     State     `json:"state" url:"state"`
	// Last logon time
	LastLogon time.Time `json:"last_logon" url:"last_logon"`
	// User's full display name.
	Fullname string `json:"fullname" url:"fullname"`
	// User's nickname
	Nickname *string `json:"nickname,omitempty" url:"nickname,omitempty"`
	// Url of user's picture
	Picture    *string   `json:"picture,omitempty" url:"picture,omitempty"`
	Ttl        string    `json:"ttl" url:"ttl"`
	TokenTtl   string    `json:"token_ttl" url:"token_ttl"`
	Expires    time.Time `json:"expires" url:"expires"`
	PinExpires time.Time `json:"pin_expires" url:"pin_expires"`
	// Roles granted to this member. Tokens inherit this access.
	RoleBinding []RoleName `json:"role_binding" url:"role_binding"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Member) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Member) UnmarshalJSON(data []byte) error {
	type embed Member
	var unmarshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"created_at"`
		UpdatedAt  *core.DateTime `json:"updated_at"`
		LastLogon  *core.DateTime `json:"last_logon"`
		Expires    *core.DateTime `json:"expires"`
		PinExpires *core.DateTime `json:"pin_expires"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Member(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	m.LastLogon = unmarshaler.LastLogon.Time()
	m.Expires = unmarshaler.Expires.Time()
	m.PinExpires = unmarshaler.PinExpires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *Member) MarshalJSON() ([]byte, error) {
	type embed Member
	var marshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"created_at"`
		UpdatedAt  *core.DateTime `json:"updated_at"`
		LastLogon  *core.DateTime `json:"last_logon"`
		Expires    *core.DateTime `json:"expires"`
		PinExpires *core.DateTime `json:"pin_expires"`
	}{
		embed:      embed(*m),
		CreatedAt:  core.NewDateTime(m.CreatedAt),
		UpdatedAt:  core.NewDateTime(m.UpdatedAt),
		LastLogon:  core.NewDateTime(m.LastLogon),
		Expires:    core.NewDateTime(m.Expires),
		PinExpires: core.NewDateTime(m.PinExpires),
	}
	return json.Marshal(marshaler)
}

func (m *Member) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MemberOptions struct {
	// Optional member time-to-live duration. After a member expires, system requires a change password to re-enable member. Minimum 1 day, Maximum 1 year, Default 180 days.
	Ttl string `json:"ttl" url:"ttl"`
	// Options: "expired" will force change password on first logon.
	Options []Options `json:"options" url:"options"`
	// Optional token time-to-live duration. Tokens are created for this member with this duration as their TTL. Minimum 10 miniutes, Maximum 1 week, Defaults 1 hour.
	TokenTtl string `json:"token_ttl" url:"token_ttl"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MemberOptions) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MemberOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler MemberOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MemberOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MemberOptions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Options string

const (
	OptionsDisabled  Options = "disabled"
	OptionsExpired   Options = "expired"
	OptionsForgotten Options = "forgotten"
	OptionsInvited   Options = "invited"
	OptionsLocked    Options = "locked"
)

func NewOptionsFromString(s string) (Options, error) {
	switch s {
	case "disabled":
		return OptionsDisabled, nil
	case "expired":
		return OptionsExpired, nil
	case "forgotten":
		return OptionsForgotten, nil
	case "invited":
		return OptionsInvited, nil
	case "locked":
		return OptionsLocked, nil
	}
	var t Options
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Options) Ptr() *Options {
	return &o
}

type State string

const (
	StateDisabled  State = "disabled"
	StateEnabled   State = "enabled"
	StateForgotten State = "forgotten"
	StateInvited   State = "invited"
	StateLocked    State = "locked"
)

func NewStateFromString(s string) (State, error) {
	switch s {
	case "disabled":
		return StateDisabled, nil
	case "enabled":
		return StateEnabled, nil
	case "forgotten":
		return StateForgotten, nil
	case "invited":
		return StateInvited, nil
	case "locked":
		return StateLocked, nil
	}
	var t State
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s State) Ptr() *State {
	return &s
}

type CreateOrganizationResponseResult struct {
	Member       *Member       `json:"member,omitempty" url:"member,omitempty"`
	Organization *Organization `json:"organization" url:"organization"`
	Token        *TokenPair    `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrganizationResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrganizationResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrganizationResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrganizationResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateOrganizationResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Environment string

const (
	EnvironmentTest Environment = "test"
	EnvironmentProd Environment = "prod"
)

func NewEnvironmentFromString(s string) (Environment, error) {
	switch s {
	case "test":
		return EnvironmentTest, nil
	case "prod":
		return EnvironmentProd, nil
	}
	var t Environment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e Environment) Ptr() *Environment {
	return &e
}

type GetOrganizationResponse struct {
	Result *Organization `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetOrganizationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOrganizationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrganizationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrganizationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetOrganizationResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Organization struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time      `json:"updated_at" url:"updated_at"`
	Id        OrganizationId `json:"id" url:"id"`
	// Organization refresh token id
	RefreshTokenId TokenId `json:"refresh_token_id" url:"refresh_token_id"`
	// Organization type: root or standard
	OrganizationType OrganizationType `json:"organization_type" url:"organization_type"`
	// Human friendly display name for this Organization
	Fullname string `json:"fullname" url:"fullname"`
	// Organization email address
	Contact *string `json:"contact,omitempty" url:"contact,omitempty"`
	// Reply-to email address, used for SMTP emails. Defaults to no-reply@synqly.com
	ReplyTo *string `json:"reply_to,omitempty" url:"reply_to,omitempty"`
	// Picture URL of the organization
	Picture *string `json:"picture,omitempty" url:"picture,omitempty"`
	// Organization options
	Options *OrganizationOptions `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Organization) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Organization) UnmarshalJSON(data []byte) error {
	type embed Organization
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Organization(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Organization) MarshalJSON() ([]byte, error) {
	type embed Organization
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *Organization) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationOptions struct {
	// Duration new member invitations will be valid. Default: 168h (7 days), minimum 24h, maximum 168h (7 days).
	InviteDuration *string `json:"invite_duration,omitempty" url:"invite_duration,omitempty"`
	// Duration forgotten password invitations will be valid. Default: 24h, minimum 24h, maximum 168h (7 days).
	ForgotDuration *string `json:"forgot_duration,omitempty" url:"forgot_duration,omitempty"`
	// Duration before member password expires, part of required password rotation. Default: 4320h (180 days), minimum: 24h, maximum: 8760h (365 days).
	PasswordDuration *string `json:"password_duration,omitempty" url:"password_duration,omitempty"`
	// Minimum password length. Default: 8, minimum 8, maximum 72.
	MinimumPasswordLength *int `json:"minimum_password_length,omitempty" url:"minimum_password_length,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationOptions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationOptions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationType string

const (
	OrganizationTypeRoot     OrganizationType = "root"
	OrganizationTypeStandard OrganizationType = "standard"
)

func NewOrganizationTypeFromString(s string) (OrganizationType, error) {
	switch s {
	case "root":
		return OrganizationTypeRoot, nil
	case "standard":
		return OrganizationTypeStandard, nil
	}
	var t OrganizationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrganizationType) Ptr() *OrganizationType {
	return &o
}

type WebhookFilter string

const (
	WebhookFilterAll               WebhookFilter = "all"
	WebhookFilterAccountCreate     WebhookFilter = "account_create"
	WebhookFilterAccountDelete     WebhookFilter = "account_delete"
	WebhookFilterAccountUpdate     WebhookFilter = "account_update"
	WebhookFilterIntegrationCreate WebhookFilter = "integration_create"
	WebhookFilterIntegrationDelete WebhookFilter = "integration_delete"
	WebhookFilterIntegrationUpdate WebhookFilter = "integration_update"
)

func NewWebhookFilterFromString(s string) (WebhookFilter, error) {
	switch s {
	case "all":
		return WebhookFilterAll, nil
	case "account_create":
		return WebhookFilterAccountCreate, nil
	case "account_delete":
		return WebhookFilterAccountDelete, nil
	case "account_update":
		return WebhookFilterAccountUpdate, nil
	case "integration_create":
		return WebhookFilterIntegrationCreate, nil
	case "integration_delete":
		return WebhookFilterIntegrationDelete, nil
	case "integration_update":
		return WebhookFilterIntegrationUpdate, nil
	}
	var t WebhookFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookFilter) Ptr() *WebhookFilter {
	return &w
}

// Response payload for webhook events. This payload is sent to the webhook URL when an event occurs.
type OrganizationWebhookPayload struct {
	// The event that triggered the webhook
	Event WebhookFilter `json:"event" url:"event"`
	// The account that the event occurred in
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// The integration that the event occurred in
	Integration *Integration `json:"integration,omitempty" url:"integration,omitempty"`
	// A unique identifier for this webhook event
	Nonce string `json:"nonce" url:"nonce"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhookPayload) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhookPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationWebhookPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationWebhookPayload(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationWebhookPayload) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationWebhook struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        WebhookId `json:"id" url:"id"`
	// Human friendly slug for this webhook
	Fullname string `json:"fullname" url:"fullname"`
	// Environment that the webhook is configured for. Only events associated with this environment will trigger the webhook.
	Environment Environment `json:"environment" url:"environment"`
	// Specifies which Webhooks to send.
	Filters []WebhookFilter `json:"filters" url:"filters"`
	// URL that webhooks will be sent to
	Url string `json:"url" url:"url"`
	// Credential contain secret
	CredentialId CredentialId `json:"credential_id" url:"credential_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhook) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhook) UnmarshalJSON(data []byte) error {
	type embed OrganizationWebhook
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OrganizationWebhook(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationWebhook) MarshalJSON() ([]byte, error) {
	type embed OrganizationWebhook
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *OrganizationWebhook) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationWebhookSecret struct {
	// Secret used for signing webhooks. This value is used to verify the authenticity of the webhook payload.
	Value string `json:"value" url:"value"`
	// Time when this secret expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhookSecret) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhookSecret) UnmarshalJSON(data []byte) error {
	type embed OrganizationWebhookSecret
	var unmarshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OrganizationWebhookSecret(unmarshaler.embed)
	o.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationWebhookSecret) MarshalJSON() ([]byte, error) {
	type embed OrganizationWebhookSecret
	var marshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed:   embed(*o),
		Expires: core.NewOptionalDateTime(o.Expires),
	}
	return json.Marshal(marshaler)
}

func (o *OrganizationWebhookSecret) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type Permission struct {
	// Roles granted to this token.
	RoleBinding []RoleName `json:"role_binding,omitempty" url:"role_binding,omitempty"`
	// Adhoc role granted to this token.
	AdhocRole *AdhocRole `json:"adhoc_role,omitempty" url:"adhoc_role,omitempty"`
	// ID of the resource that this permission grants access to.
	ResourceId Id `json:"resource_id" url:"resource_id"`
	// Type of the resource that this permission grants access to. Must be one of the following: "organization, "integration"
	ResourceType string `json:"resource_type" url:"resource_type"`
	// Token parentId
	ParentId Id `json:"parent_id" url:"parent_id"`
	// Token Id
	Id Id `json:"id" url:"id"`
	// Token organizationId
	OrganizationId Id `json:"organization_id" url:"organization_id"`
	// Token root organizationId
	RootOrganizationId *Id `json:"root_organization_id,omitempty" url:"root_organization_id,omitempty"`
	// Token memberId
	MemberId Id `json:"member_id" url:"member_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Permission) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Permission) UnmarshalJSON(data []byte) error {
	type unmarshaler Permission
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Permission(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Permission) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type AccountsActions string

const (
	AccountsActionsList   AccountsActions = "list"
	AccountsActionsCreate AccountsActions = "create"
	AccountsActionsGet    AccountsActions = "get"
	AccountsActionsUpdate AccountsActions = "update"
	AccountsActionsPatch  AccountsActions = "patch"
	AccountsActionsDelete AccountsActions = "delete"
	AccountsActionsAll    AccountsActions = "*"
)

func NewAccountsActionsFromString(s string) (AccountsActions, error) {
	switch s {
	case "list":
		return AccountsActionsList, nil
	case "create":
		return AccountsActionsCreate, nil
	case "get":
		return AccountsActionsGet, nil
	case "update":
		return AccountsActionsUpdate, nil
	case "patch":
		return AccountsActionsPatch, nil
	case "delete":
		return AccountsActionsDelete, nil
	case "*":
		return AccountsActionsAll, nil
	}
	var t AccountsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountsActions) Ptr() *AccountsActions {
	return &a
}

// Permissions for the accounts API
type AccountsPermissions struct {
	Actions []AccountsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AccountsPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AccountsPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AlarmPoliciesActions string

const (
	AlarmPoliciesActionsGet    AlarmPoliciesActions = "get"
	AlarmPoliciesActionsUpdate AlarmPoliciesActions = "update"
	AlarmPoliciesActionsPatch  AlarmPoliciesActions = "patch"
	AlarmPoliciesActionsAll    AlarmPoliciesActions = "*"
)

func NewAlarmPoliciesActionsFromString(s string) (AlarmPoliciesActions, error) {
	switch s {
	case "get":
		return AlarmPoliciesActionsGet, nil
	case "update":
		return AlarmPoliciesActionsUpdate, nil
	case "patch":
		return AlarmPoliciesActionsPatch, nil
	case "*":
		return AlarmPoliciesActionsAll, nil
	}
	var t AlarmPoliciesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AlarmPoliciesActions) Ptr() *AlarmPoliciesActions {
	return &a
}

// Permissions for the alarm policy API
type AlarmPoliciesPermissions struct {
	Actions []AlarmPoliciesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AlarmPoliciesPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AlarmPoliciesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AlarmPoliciesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlarmPoliciesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AlarmPoliciesPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AlarmsActions string

const (
	AlarmsActionsList     AlarmsActions = "list"
	AlarmsActionsGet      AlarmsActions = "get"
	AlarmsActionsMode     AlarmsActions = "mode"
	AlarmsActionsPriority AlarmsActions = "priority"
	AlarmsActionsClear    AlarmsActions = "clear"
	AlarmsActionsAll      AlarmsActions = "*"
)

func NewAlarmsActionsFromString(s string) (AlarmsActions, error) {
	switch s {
	case "list":
		return AlarmsActionsList, nil
	case "get":
		return AlarmsActionsGet, nil
	case "mode":
		return AlarmsActionsMode, nil
	case "priority":
		return AlarmsActionsPriority, nil
	case "clear":
		return AlarmsActionsClear, nil
	case "*":
		return AlarmsActionsAll, nil
	}
	var t AlarmsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AlarmsActions) Ptr() *AlarmsActions {
	return &a
}

// Permissions for the alarms API
type AlarmsPermissions struct {
	Actions []AlarmsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AlarmsPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AlarmsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AlarmsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AlarmsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AlarmsPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiPermissionMap struct {
	All               *ReadWritePermissions         `json:"all,omitempty" url:"all,omitempty"`
	Accounts          *AccountsPermissions          `json:"accounts,omitempty" url:"accounts,omitempty"`
	Alarms            *AlarmsPermissions            `json:"alarms,omitempty" url:"alarms,omitempty"`
	AlarmPolicies     *AlarmPoliciesPermissions     `json:"alarm_policies,omitempty" url:"alarm_policies,omitempty"`
	Audit             *AuditPermissions             `json:"audit,omitempty" url:"audit,omitempty"`
	Auth              *AuthPermissions              `json:"auth,omitempty" url:"auth,omitempty"`
	Bridges           *BridgesPermissions           `json:"bridges,omitempty" url:"bridges,omitempty"`
	Credentials       *CredentialsPermissions       `json:"credentials,omitempty" url:"credentials,omitempty"`
	Integrations      *IntegrationsPermissions      `json:"integrations,omitempty" url:"integrations,omitempty"`
	IntegrationPoints *IntegrationPointsPermissions `json:"integration_points,omitempty" url:"integration_points,omitempty"`
	Members           *MembersPermissions           `json:"members,omitempty" url:"members,omitempty"`
	Organizations     *OrganizationPermissions      `json:"organizations,omitempty" url:"organizations,omitempty"`
	PermissionSet     *PermissionSetPermissions     `json:"permission_set,omitempty" url:"permission_set,omitempty"`
	Roles             *RolesPermissions             `json:"roles,omitempty" url:"roles,omitempty"`
	Status            *StatusPermissions            `json:"status,omitempty" url:"status,omitempty"`
	Suborgs           *SubOrgsPermissions           `json:"suborgs,omitempty" url:"suborgs,omitempty"`
	Tokens            *TokensPermissions            `json:"tokens,omitempty" url:"tokens,omitempty"`
	Transforms        *TransformsPermissions        `json:"transforms,omitempty" url:"transforms,omitempty"`
	Webhooks          *WebhooksPermissions          `json:"webhooks,omitempty" url:"webhooks,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiPermissionMap) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiPermissionMap) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiPermissionMap
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiPermissionMap(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *ApiPermissionMap) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuditActions string

const (
	AuditActionsList AuditActions = "list"
	AuditActionsAll  AuditActions = "*"
)

func NewAuditActionsFromString(s string) (AuditActions, error) {
	switch s {
	case "list":
		return AuditActionsList, nil
	case "*":
		return AuditActionsAll, nil
	}
	var t AuditActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuditActions) Ptr() *AuditActions {
	return &a
}

// Permissions for the audit API
type AuditPermissions struct {
	Actions []AuditActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AuditPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AuditPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AuditPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuditPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AuditPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuthActions string

const (
	AuthActionsLogon          AuthActions = "logon"
	AuthActionsChangePassword AuthActions = "change_password"
	AuthActionsLogoff         AuthActions = "logoff"
	AuthActionsAll            AuthActions = "*"
)

func NewAuthActionsFromString(s string) (AuthActions, error) {
	switch s {
	case "logon":
		return AuthActionsLogon, nil
	case "change_password":
		return AuthActionsChangePassword, nil
	case "logoff":
		return AuthActionsLogoff, nil
	case "*":
		return AuthActionsAll, nil
	}
	var t AuthActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthActions) Ptr() *AuthActions {
	return &a
}

// Permissions for the auth logon/logoff API
type AuthPermissions struct {
	Actions []AuthActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AuthPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AuthPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AuthPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BridgesActions string

const (
	BridgesActionsList   BridgesActions = "list"
	BridgesActionsCreate BridgesActions = "create"
	BridgesActionsGet    BridgesActions = "get"
	BridgesActionsUpdate BridgesActions = "update"
	BridgesActionsPatch  BridgesActions = "patch"
	BridgesActionsDelete BridgesActions = "delete"
	BridgesActionsStatus BridgesActions = "status"
	BridgesActionsAll    BridgesActions = "*"
)

func NewBridgesActionsFromString(s string) (BridgesActions, error) {
	switch s {
	case "list":
		return BridgesActionsList, nil
	case "create":
		return BridgesActionsCreate, nil
	case "get":
		return BridgesActionsGet, nil
	case "update":
		return BridgesActionsUpdate, nil
	case "patch":
		return BridgesActionsPatch, nil
	case "delete":
		return BridgesActionsDelete, nil
	case "status":
		return BridgesActionsStatus, nil
	case "*":
		return BridgesActionsAll, nil
	}
	var t BridgesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BridgesActions) Ptr() *BridgesActions {
	return &b
}

// Permissions for the bridge API
type BridgesPermissions struct {
	Actions []BridgesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgesPermissions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BridgesPermissions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CredentialsActions string

const (
	CredentialsActionsList   CredentialsActions = "list"
	CredentialsActionsCreate CredentialsActions = "create"
	CredentialsActionsGet    CredentialsActions = "get"
	CredentialsActionsUpdate CredentialsActions = "update"
	CredentialsActionsPatch  CredentialsActions = "patch"
	CredentialsActionsDelete CredentialsActions = "delete"
	CredentialsActionsLookup CredentialsActions = "lookup"
	CredentialsActionsAll    CredentialsActions = "*"
)

func NewCredentialsActionsFromString(s string) (CredentialsActions, error) {
	switch s {
	case "list":
		return CredentialsActionsList, nil
	case "create":
		return CredentialsActionsCreate, nil
	case "get":
		return CredentialsActionsGet, nil
	case "update":
		return CredentialsActionsUpdate, nil
	case "patch":
		return CredentialsActionsPatch, nil
	case "delete":
		return CredentialsActionsDelete, nil
	case "lookup":
		return CredentialsActionsLookup, nil
	case "*":
		return CredentialsActionsAll, nil
	}
	var t CredentialsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialsActions) Ptr() *CredentialsActions {
	return &c
}

// Permissions for the credentials API
type CredentialsPermissions struct {
	Actions []CredentialsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialsPermissions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CredentialsPermissions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type IntegrationPointsActions string

const (
	IntegrationPointsActionsList   IntegrationPointsActions = "list"
	IntegrationPointsActionsCreate IntegrationPointsActions = "create"
	IntegrationPointsActionsGet    IntegrationPointsActions = "get"
	IntegrationPointsActionsUpdate IntegrationPointsActions = "update"
	IntegrationPointsActionsPatch  IntegrationPointsActions = "patch"
	IntegrationPointsActionsDelete IntegrationPointsActions = "delete"
	IntegrationPointsActionsAll    IntegrationPointsActions = "*"
)

func NewIntegrationPointsActionsFromString(s string) (IntegrationPointsActions, error) {
	switch s {
	case "list":
		return IntegrationPointsActionsList, nil
	case "create":
		return IntegrationPointsActionsCreate, nil
	case "get":
		return IntegrationPointsActionsGet, nil
	case "update":
		return IntegrationPointsActionsUpdate, nil
	case "patch":
		return IntegrationPointsActionsPatch, nil
	case "delete":
		return IntegrationPointsActionsDelete, nil
	case "*":
		return IntegrationPointsActionsAll, nil
	}
	var t IntegrationPointsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationPointsActions) Ptr() *IntegrationPointsActions {
	return &i
}

// Permissions for the integrations points API
type IntegrationPointsPermissions struct {
	Actions []IntegrationPointsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationPointsPermissions) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationPointsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationPointsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationPointsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationPointsPermissions) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IntegrationsActions string

const (
	IntegrationsActionsList        IntegrationsActions = "list"
	IntegrationsActionsCreate      IntegrationsActions = "create"
	IntegrationsActionsGet         IntegrationsActions = "get"
	IntegrationsActionsUpdate      IntegrationsActions = "update"
	IntegrationsActionsPatch       IntegrationsActions = "patch"
	IntegrationsActionsDelete      IntegrationsActions = "delete"
	IntegrationsActionsListAccount IntegrationsActions = "list_account"
	IntegrationsActionsVerify      IntegrationsActions = "verify"
	IntegrationsActionsAll         IntegrationsActions = "*"
)

func NewIntegrationsActionsFromString(s string) (IntegrationsActions, error) {
	switch s {
	case "list":
		return IntegrationsActionsList, nil
	case "create":
		return IntegrationsActionsCreate, nil
	case "get":
		return IntegrationsActionsGet, nil
	case "update":
		return IntegrationsActionsUpdate, nil
	case "patch":
		return IntegrationsActionsPatch, nil
	case "delete":
		return IntegrationsActionsDelete, nil
	case "list_account":
		return IntegrationsActionsListAccount, nil
	case "verify":
		return IntegrationsActionsVerify, nil
	case "*":
		return IntegrationsActionsAll, nil
	}
	var t IntegrationsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationsActions) Ptr() *IntegrationsActions {
	return &i
}

// Permissions for the integrations API
type IntegrationsPermissions struct {
	Actions []IntegrationsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationsPermissions) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationsPermissions) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MembersActions string

const (
	MembersActionsList   MembersActions = "list"
	MembersActionsCreate MembersActions = "create"
	MembersActionsGet    MembersActions = "get"
	MembersActionsUpdate MembersActions = "update"
	MembersActionsPatch  MembersActions = "patch"
	MembersActionsDelete MembersActions = "delete"
	MembersActionsAll    MembersActions = "*"
)

func NewMembersActionsFromString(s string) (MembersActions, error) {
	switch s {
	case "list":
		return MembersActionsList, nil
	case "create":
		return MembersActionsCreate, nil
	case "get":
		return MembersActionsGet, nil
	case "update":
		return MembersActionsUpdate, nil
	case "patch":
		return MembersActionsPatch, nil
	case "delete":
		return MembersActionsDelete, nil
	case "*":
		return MembersActionsAll, nil
	}
	var t MembersActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MembersActions) Ptr() *MembersActions {
	return &m
}

// Permissions for the members API
type MembersPermissions struct {
	Actions []MembersActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MembersPermissions) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MembersPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler MembersPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MembersPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MembersPermissions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OrganizationActions string

const (
	OrganizationActionsGet    OrganizationActions = "get"
	OrganizationActionsUpdate OrganizationActions = "update"
	OrganizationActionsPatch  OrganizationActions = "patch"
	OrganizationActionsAll    OrganizationActions = "*"
)

func NewOrganizationActionsFromString(s string) (OrganizationActions, error) {
	switch s {
	case "get":
		return OrganizationActionsGet, nil
	case "update":
		return OrganizationActionsUpdate, nil
	case "patch":
		return OrganizationActionsPatch, nil
	case "*":
		return OrganizationActionsAll, nil
	}
	var t OrganizationActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrganizationActions) Ptr() *OrganizationActions {
	return &o
}

// Permissions for the organization API
type OrganizationPermissions struct {
	Actions []OrganizationActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationPermissions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OrganizationPermissions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PermissionSet struct {
	Name Permissions `json:"name" url:"name"`
	// Description of when the permission set should be used and what permissions are granted by the permission set.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Resources that can be used with this permission set
	ResourceRestrictions []ResourceRestrictions `json:"resource_restrictions,omitempty" url:"resource_restrictions,omitempty"`
	// API permissions granted by the permission set.
	Permissions *ApiPermissionMap `json:"permissions" url:"permissions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PermissionSet) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PermissionSet) UnmarshalJSON(data []byte) error {
	type unmarshaler PermissionSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PermissionSet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *PermissionSet) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PermissionSetActions string

const (
	PermissionSetActionsList PermissionSetActions = "list"
	PermissionSetActionsGet  PermissionSetActions = "get"
	PermissionSetActionsAll  PermissionSetActions = "*"
)

func NewPermissionSetActionsFromString(s string) (PermissionSetActions, error) {
	switch s {
	case "list":
		return PermissionSetActionsList, nil
	case "get":
		return PermissionSetActionsGet, nil
	case "*":
		return PermissionSetActionsAll, nil
	}
	var t PermissionSetActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PermissionSetActions) Ptr() *PermissionSetActions {
	return &p
}

// Permissions for the permissionset API
type PermissionSetPermissions struct {
	Actions []PermissionSetActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PermissionSetPermissions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PermissionSetPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler PermissionSetPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PermissionSetPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *PermissionSetPermissions) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ReadWriteActions string

const (
	ReadWriteActionsRead      ReadWriteActions = "read"
	ReadWriteActionsReadWrite ReadWriteActions = "*"
)

func NewReadWriteActionsFromString(s string) (ReadWriteActions, error) {
	switch s {
	case "read":
		return ReadWriteActionsRead, nil
	case "*":
		return ReadWriteActionsReadWrite, nil
	}
	var t ReadWriteActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReadWriteActions) Ptr() *ReadWriteActions {
	return &r
}

// Permissions for all accounts
type ReadWritePermissions struct {
	Actions []ReadWriteActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReadWritePermissions) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReadWritePermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler ReadWritePermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReadWritePermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *ReadWritePermissions) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResourceRestrictions string

const (
	ResourceRestrictionsAccounts     ResourceRestrictions = "accounts"
	ResourceRestrictionsIntegrations ResourceRestrictions = "integrations"
)

func NewResourceRestrictionsFromString(s string) (ResourceRestrictions, error) {
	switch s {
	case "accounts":
		return ResourceRestrictionsAccounts, nil
	case "integrations":
		return ResourceRestrictionsIntegrations, nil
	}
	var t ResourceRestrictions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResourceRestrictions) Ptr() *ResourceRestrictions {
	return &r
}

type RolesActions string

const (
	RolesActionsList   RolesActions = "list"
	RolesActionsCreate RolesActions = "create"
	RolesActionsGet    RolesActions = "get"
	RolesActionsUpdate RolesActions = "update"
	RolesActionsPatch  RolesActions = "patch"
	RolesActionsDelete RolesActions = "delete"
	RolesActionsAll    RolesActions = "*"
)

func NewRolesActionsFromString(s string) (RolesActions, error) {
	switch s {
	case "list":
		return RolesActionsList, nil
	case "create":
		return RolesActionsCreate, nil
	case "get":
		return RolesActionsGet, nil
	case "update":
		return RolesActionsUpdate, nil
	case "patch":
		return RolesActionsPatch, nil
	case "delete":
		return RolesActionsDelete, nil
	case "*":
		return RolesActionsAll, nil
	}
	var t RolesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RolesActions) Ptr() *RolesActions {
	return &r
}

// Permissions for the roles API
type RolesPermissions struct {
	Actions []RolesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RolesPermissions) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RolesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler RolesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RolesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RolesPermissions) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type StatusActions string

const (
	StatusActionsList                  StatusActions = "list"
	StatusActionsGet                   StatusActions = "get"
	StatusActionsReset                 StatusActions = "reset"
	StatusActionsListEvents            StatusActions = "list_events"
	StatusActionsTimeseries            StatusActions = "timeseries"
	StatusActionsIntegrationTimeseries StatusActions = "integration_timeseries"
	StatusActionsAll                   StatusActions = "*"
)

func NewStatusActionsFromString(s string) (StatusActions, error) {
	switch s {
	case "list":
		return StatusActionsList, nil
	case "get":
		return StatusActionsGet, nil
	case "reset":
		return StatusActionsReset, nil
	case "list_events":
		return StatusActionsListEvents, nil
	case "timeseries":
		return StatusActionsTimeseries, nil
	case "integration_timeseries":
		return StatusActionsIntegrationTimeseries, nil
	case "*":
		return StatusActionsAll, nil
	}
	var t StatusActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusActions) Ptr() *StatusActions {
	return &s
}

// Permissions for the status API
type StatusPermissions struct {
	Actions []StatusActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StatusPermissions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StatusPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler StatusPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StatusPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StatusPermissions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubOrgsActions string

const (
	SubOrgsActionsList   SubOrgsActions = "list"
	SubOrgsActionsCreate SubOrgsActions = "create"
	SubOrgsActionsGet    SubOrgsActions = "get"
	SubOrgsActionsDelete SubOrgsActions = "delete"
	SubOrgsActionsAll    SubOrgsActions = "*"
)

func NewSubOrgsActionsFromString(s string) (SubOrgsActions, error) {
	switch s {
	case "list":
		return SubOrgsActionsList, nil
	case "create":
		return SubOrgsActionsCreate, nil
	case "get":
		return SubOrgsActionsGet, nil
	case "delete":
		return SubOrgsActionsDelete, nil
	case "*":
		return SubOrgsActionsAll, nil
	}
	var t SubOrgsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubOrgsActions) Ptr() *SubOrgsActions {
	return &s
}

// Permissions for the roles API
type SubOrgsPermissions struct {
	Actions []SubOrgsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubOrgsPermissions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubOrgsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler SubOrgsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubOrgsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SubOrgsPermissions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TokensActions string

const (
	TokensActionsList                     TokensActions = "list"
	TokensActionsCreate                   TokensActions = "create"
	TokensActionsCreateIntegration        TokensActions = "create_integration"
	TokensActionsCreateSynqlyIntegrations TokensActions = "create_synqly_integrations"
	TokensActionsDelete                   TokensActions = "delete"
	TokensActionsGet                      TokensActions = "get"
	TokensActionsReset                    TokensActions = "reset"
	TokensActionsRefresh                  TokensActions = "refresh"
	TokensActionsRemoveSecondary          TokensActions = "remove_secondary"
	TokensActionsAll                      TokensActions = "*"
)

func NewTokensActionsFromString(s string) (TokensActions, error) {
	switch s {
	case "list":
		return TokensActionsList, nil
	case "create":
		return TokensActionsCreate, nil
	case "create_integration":
		return TokensActionsCreateIntegration, nil
	case "create_synqly_integrations":
		return TokensActionsCreateSynqlyIntegrations, nil
	case "delete":
		return TokensActionsDelete, nil
	case "get":
		return TokensActionsGet, nil
	case "reset":
		return TokensActionsReset, nil
	case "refresh":
		return TokensActionsRefresh, nil
	case "remove_secondary":
		return TokensActionsRemoveSecondary, nil
	case "*":
		return TokensActionsAll, nil
	}
	var t TokensActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokensActions) Ptr() *TokensActions {
	return &t
}

// Permissions for the tokens API
type TokensPermissions struct {
	Actions []TokensActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokensPermissions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokensPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokensPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokensPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TokensPermissions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransformsActions string

const (
	TransformsActionsList   TransformsActions = "list"
	TransformsActionsCreate TransformsActions = "create"
	TransformsActionsGet    TransformsActions = "get"
	TransformsActionsUpdate TransformsActions = "update"
	TransformsActionsPatch  TransformsActions = "patch"
	TransformsActionsDelete TransformsActions = "delete"
	TransformsActionsAll    TransformsActions = "*"
)

func NewTransformsActionsFromString(s string) (TransformsActions, error) {
	switch s {
	case "list":
		return TransformsActionsList, nil
	case "create":
		return TransformsActionsCreate, nil
	case "get":
		return TransformsActionsGet, nil
	case "update":
		return TransformsActionsUpdate, nil
	case "patch":
		return TransformsActionsPatch, nil
	case "delete":
		return TransformsActionsDelete, nil
	case "*":
		return TransformsActionsAll, nil
	}
	var t TransformsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformsActions) Ptr() *TransformsActions {
	return &t
}

// Permissions for the transforms API
type TransformsPermissions struct {
	Actions []TransformsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransformsPermissions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TransformsPermissions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type WebhooksActions string

const (
	WebhooksActionsList   WebhooksActions = "list"
	WebhooksActionsCreate WebhooksActions = "create"
	WebhooksActionsGet    WebhooksActions = "get"
	WebhooksActionsUpdate WebhooksActions = "update"
	WebhooksActionsPatch  WebhooksActions = "patch"
	WebhooksActionsDelete WebhooksActions = "delete"
	WebhooksActionsAll    WebhooksActions = "*"
)

func NewWebhooksActionsFromString(s string) (WebhooksActions, error) {
	switch s {
	case "list":
		return WebhooksActionsList, nil
	case "create":
		return WebhooksActionsCreate, nil
	case "get":
		return WebhooksActionsGet, nil
	case "update":
		return WebhooksActionsUpdate, nil
	case "patch":
		return WebhooksActionsPatch, nil
	case "delete":
		return WebhooksActionsDelete, nil
	case "*":
		return WebhooksActionsAll, nil
	}
	var t WebhooksActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhooksActions) Ptr() *WebhooksActions {
	return &w
}

// Permissions for the webhooks API
type WebhooksPermissions struct {
	Actions []WebhooksActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhooksPermissions) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhooksPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhooksPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhooksPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *WebhooksPermissions) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type ArmisCredential struct {
	Type string
	// This credential must be an API Secret Key. Generate this key in the UI console by navigating to "Settings", then "API Management".
	Token *TokenCredential
	// ID of an existing credential that stores an Armis Centrix API Secret Key.
	TokenId TokenCredentialId
}

func (a *ArmisCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a ArmisCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type ArmisCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *ArmisCredential) Accept(visitor ArmisCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

// Configuration for the Armis Centrix Assets Provider
type AssetsArmisCentrix struct {
	Credential *ArmisCredential `json:"credential" url:"credential"`
	// URL for the Armis Centrix API. This should be the base URL for the API, without any path components. For example, "https://tenant.armis.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsArmisCentrix) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsArmisCentrix) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsArmisCentrix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsArmisCentrix(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsArmisCentrix) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for the Nozomi Vantage provider
type AssetsNozomiVantage struct {
	Credential *NozomiVantageCredential `json:"credential" url:"credential"`
	// URL for the Nozomi Vantage API. This should be the base URL for the API, without any path components. For example, "https://tenant.us1.vantage.nozominetworks.io".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsNozomiVantage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsNozomiVantage) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsNozomiVantage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsNozomiVantage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsNozomiVantage) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for ServiceNow as an Assets Provider
type AssetsServiceNow struct {
	Credential *ServiceNowCredential `json:"credential" url:"credential"`
	// URL for the ServiceNow API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.service-now.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsServiceNow) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsServiceNow) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsServiceNow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsServiceNow(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AssetsServiceNow) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AwsS3Credential struct {
	Type string
	// AWS access key to authenticate with AWS. Access keys are long-term credentials for an IAM user and consist of an ID and secret. This token pair must have read and write access to the configured AWS S3 bucket. You may optionally provide a session token if you are using temporary credentials.
	Aws *AwsCredential
	// ID of a credential that stores an AWS access key for the AWS S3 bucket.
	AwsId AwsCredentialId
}

func (a *AwsS3Credential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsS3Credential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsS3CredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsS3Credential) Accept(visitor AwsS3CredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSqsCredential struct {
	Type string
	// AWS access key to authenticate with AWS. Access keys are long-term credentials for an IAM user and consist of an ID and secret. This token pair must have write access to the configured SQS queue. You may optionally provide a session token if you are using temporary credentials.
	Aws *AwsCredential
	// ID of a credential that stores an AWS access key for the SQS queue.
	AwsId AwsCredentialId
}

func (a *AwsSqsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsSqsCredential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSqsCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsSqsCredential) Accept(visitor AwsSqsCredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSecurityLakeCredential struct {
	Type string
	// AWS access key to authenticate with AWS. Access keys are long-term credentials for an IAM user and consist of an ID and secret. This token pair must have write access to the configured S3 bucket. You may optionally provide a session token if you are using temporary credentials.
	Aws *AwsCredential
	// ID of a credential that stores an AWS access key for the AWS Security Lake S3 bucket.
	AwsId AwsCredentialId
}

func (a *AwsSecurityLakeCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsSecurityLakeCredential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSecurityLakeCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsSecurityLakeCredential) Accept(visitor AwsSecurityLakeCredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureBlobCredential struct {
	Type string
	// Azure token for authentication. Follow [this guide to generate an API token](https://learn.microsoft.com/en-us/entra/identity-platform/howto-create-service-principal-portal). The token must have access to the configured blob container.
	Token *TokenCredential
	// ID of a credential that stores an Azure token for authentication.
	TokenId TokenCredentialId
}

func (a *AzureBlobCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a AzureBlobCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureBlobCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *AzureBlobCredential) Accept(visitor AzureBlobCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureMonitorLogsCredential struct {
	Type string
	// Azure token for authentication. Follow [this guide to generate an API token](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal). The token must have access to the configured data collection endpoint.
	Token *TokenCredential
	// ID of a credential that stores an Azure token for authentication.
	TokenId TokenCredentialId
}

func (a *AzureMonitorLogsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a AzureMonitorLogsCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureMonitorLogsCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *AzureMonitorLogsCredential) Accept(visitor AzureMonitorLogsCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type CrowdStrikeCredential struct {
	Type string
	// Docs for setting up oAuth
	OAuthClient *OAuthClientCredential
	// ID of a credential that stores a CrowdStrike oAuth client ID.
	OAuthClientId OAuthClientCredentialId
}

func (c *CrowdStrikeCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (c CrowdStrikeCredential) MarshalJSON() ([]byte, error) {
	if c.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(c.OAuthClient, "type", "o_auth_client")
	}
	if c.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: c.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CrowdStrikeCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (c *CrowdStrikeCredential) Accept(visitor CrowdStrikeCredentialVisitor) error {
	if c.OAuthClient != nil {
		return visitor.VisitOAuthClient(c.OAuthClient)
	}
	if c.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(c.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

// Supported credential types for Crowdstrike HEC
type CrowdstrikeHecCredential struct {
	Type string
	// Crowdstrike HEC api-key
	Token *TokenCredential
	// ID of a credential that stores a Crowdstrike HEC authentication api-key.
	TokenId TokenCredentialId
}

func (c *CrowdstrikeHecCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (c CrowdstrikeHecCredential) MarshalJSON() ([]byte, error) {
	if c.Token != nil {
		return core.MarshalJSONWithExtraProperty(c.Token, "type", "token")
	}
	if c.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: c.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CrowdstrikeHecCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (c *CrowdstrikeHecCredential) Accept(visitor CrowdstrikeHecCredentialVisitor) error {
	if c.Token != nil {
		return visitor.VisitToken(c.Token)
	}
	if c.TokenId != "" {
		return visitor.VisitTokenId(c.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CustomFieldMapping struct {
	// Name for the custom field that you will use in the `custom_fields` field in ticket objects within Synqly.
	Name string `json:"name" url:"name"`
	// ID of the project this field mapping is associated with. ID of "\*" is used to apply to all projects.
	ProjectId string `json:"project_id" url:"project_id"`
	// Path to or name of the custom field in the provider.
	ProviderFieldPath string `json:"provider_field_path" url:"provider_field_path"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomFieldMapping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomFieldMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomFieldMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomFieldMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CustomFieldMapping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DefenderCredential struct {
	Type string
	// Docs for setting up oAuth
	OAuthClient *OAuthClientCredential
	// ID of a credential that stores a Defender oAuth client ID.
	OAuthClientId OAuthClientCredentialId
}

func (d *DefenderCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", d)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		d.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (d DefenderCredential) MarshalJSON() ([]byte, error) {
	if d.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(d.OAuthClient, "type", "o_auth_client")
	}
	if d.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: d.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", d)
}

type DefenderCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (d *DefenderCredential) Accept(visitor DefenderCredentialVisitor) error {
	if d.OAuthClient != nil {
		return visitor.VisitOAuthClient(d.OAuthClient)
	}
	if d.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(d.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", d)
}

// Configuration for the CrowdStrike EDR Provider
type EdrCrowdStrike struct {
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// The root domain where your CrowdStrike Falcon tenant is located.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrCrowdStrike) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrCrowdStrike) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrCrowdStrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrCrowdStrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrCrowdStrike) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for the Microsoft Defender EDR Provider
type EdrDefender struct {
	Credential *DefenderCredential `json:"credential" url:"credential"`
	// TenantId for the Microsoft Defender Management Console.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// URL for the Microsoft Defender Management Console.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrDefender) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrDefender) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrDefender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrDefender(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrDefender) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for the SentinelOne EDR Provider
type EdrSentinelOne struct {
	Credential *SentinelOneCredential `json:"credential" url:"credential"`
	// URL for the SentinelOne Management API. This should be the base URL for the API, without any path components. For example, "https://your_management_url".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrSentinelOne) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrSentinelOne) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrSentinelOne
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrSentinelOne(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrSentinelOne) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for the Sophos EDR Provider
type EdrSophos struct {
	Credential *SophosCredential `json:"credential" url:"credential"`
	// Optional root domain where your Sophos tenant is located.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrSophos) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrSophos) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrSophos
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrSophos(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EdrSophos) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Options used to control how requests are made to elasticsearch when different authentication types are used.
type ElasticsearchAuthOptions struct {
	// When you have the correct permissions, this allows API requests to get made as a specific user, with all of their roles and permissions. When populated, this option will send the 'es-security-runas-user' header with every request made to the Elasticsearch API.
	RunAs *string `json:"run_as,omitempty" url:"run_as,omitempty"`
	// Some auth cases, notably JWT auth can be configured to require sending a shared secret in the `ES-Client-Authentication` header. When this secret is populated, it will get added as the shared secret for every request made to Elasticsearch.
	SharedSecret *ElasticsearchSharedSecret `json:"shared_secret,omitempty" url:"shared_secret,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ElasticsearchAuthOptions) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElasticsearchAuthOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ElasticsearchAuthOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElasticsearchAuthOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *ElasticsearchAuthOptions) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElasticsearchBridgeCredentials struct {
	Type string
	// Optional basic auth credential used for connecting to the Elasticsearch service through a synqly bridge agent with local credentials.
	BridgeBasic *BridgeBasicCredential
	// Optional id of a basic auth credential used for connecting to the Elasticsearch service through a synqly bridge agent with local credentials.
	BridgeBasicId BridgeBasicCredentialId
	// "Optional OAuth JWT credential used for connecting to the Elasticsearch service through a synqly bridge agent with local credentails."
	BridgeOAuthClient *BridgeOAuthClientCredential
	// "Optional ID of a OAuth JWT credential used for connecting to the Elasticsearch service through a synqly bridge agent with local credentails."
	BridgeOAuthClientId BridgeOAuthClientCredentialId
	// Optional credential used for connecting to the Elasticsearch service through a synqly bridge agent with local credentials.
	BridgeToken *BridgeTokenCredential
	// Optional id of a credential used for connecting to the Elasticsearch service through a synqly bridge agent with local credentials.
	BridgeTokenId BridgeTokenCredentialId
}

func (e *ElasticsearchBridgeCredentials) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "bridge_basic":
		value := new(BridgeBasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.BridgeBasic = value
	case "bridge_basic_id":
		var valueUnmarshaler struct {
			BridgeBasicId BridgeBasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.BridgeBasicId = valueUnmarshaler.BridgeBasicId
	case "bridge_o_auth_client":
		value := new(BridgeOAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.BridgeOAuthClient = value
	case "bridge_o_auth_client_id":
		var valueUnmarshaler struct {
			BridgeOAuthClientId BridgeOAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.BridgeOAuthClientId = valueUnmarshaler.BridgeOAuthClientId
	case "bridge_token":
		value := new(BridgeTokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.BridgeToken = value
	case "bridge_token_id":
		var valueUnmarshaler struct {
			BridgeTokenId BridgeTokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.BridgeTokenId = valueUnmarshaler.BridgeTokenId
	}
	return nil
}

func (e ElasticsearchBridgeCredentials) MarshalJSON() ([]byte, error) {
	if e.BridgeBasic != nil {
		return core.MarshalJSONWithExtraProperty(e.BridgeBasic, "type", "bridge_basic")
	}
	if e.BridgeBasicId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			BridgeBasicId BridgeBasicCredentialId `json:"value"`
		}{
			Type:          "bridge_basic_id",
			BridgeBasicId: e.BridgeBasicId,
		}
		return json.Marshal(marshaler)
	}
	if e.BridgeOAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(e.BridgeOAuthClient, "type", "bridge_o_auth_client")
	}
	if e.BridgeOAuthClientId != "" {
		var marshaler = struct {
			Type                string                        `json:"type"`
			BridgeOAuthClientId BridgeOAuthClientCredentialId `json:"value"`
		}{
			Type:                "bridge_o_auth_client_id",
			BridgeOAuthClientId: e.BridgeOAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if e.BridgeToken != nil {
		return core.MarshalJSONWithExtraProperty(e.BridgeToken, "type", "bridge_token")
	}
	if e.BridgeTokenId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			BridgeTokenId BridgeTokenCredentialId `json:"value"`
		}{
			Type:          "bridge_token_id",
			BridgeTokenId: e.BridgeTokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchBridgeCredentialsVisitor interface {
	VisitBridgeBasic(*BridgeBasicCredential) error
	VisitBridgeBasicId(BridgeBasicCredentialId) error
	VisitBridgeOAuthClient(*BridgeOAuthClientCredential) error
	VisitBridgeOAuthClientId(BridgeOAuthClientCredentialId) error
	VisitBridgeToken(*BridgeTokenCredential) error
	VisitBridgeTokenId(BridgeTokenCredentialId) error
}

func (e *ElasticsearchBridgeCredentials) Accept(visitor ElasticsearchBridgeCredentialsVisitor) error {
	if e.BridgeBasic != nil {
		return visitor.VisitBridgeBasic(e.BridgeBasic)
	}
	if e.BridgeBasicId != "" {
		return visitor.VisitBridgeBasicId(e.BridgeBasicId)
	}
	if e.BridgeOAuthClient != nil {
		return visitor.VisitBridgeOAuthClient(e.BridgeOAuthClient)
	}
	if e.BridgeOAuthClientId != "" {
		return visitor.VisitBridgeOAuthClientId(e.BridgeOAuthClientId)
	}
	if e.BridgeToken != nil {
		return visitor.VisitBridgeToken(e.BridgeToken)
	}
	if e.BridgeTokenId != "" {
		return visitor.VisitBridgeTokenId(e.BridgeTokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchBridgeSharedSecret struct {
	Type string
	// Optional credential used for connecting to the Elasticsearch service through a synqly bridge agent with local credentials.
	BridgeSecret *BridgeSecretCredential
	// Optional id of a credential used for connecting to the Elasticsearch service through a synqly bridge agent with local credentials.
	BridgeSecretId BridgeSecretCredentialId
}

func (e *ElasticsearchBridgeSharedSecret) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "bridge_secret":
		value := new(BridgeSecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.BridgeSecret = value
	case "bridge_secret_id":
		var valueUnmarshaler struct {
			BridgeSecretId BridgeSecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.BridgeSecretId = valueUnmarshaler.BridgeSecretId
	}
	return nil
}

func (e ElasticsearchBridgeSharedSecret) MarshalJSON() ([]byte, error) {
	if e.BridgeSecret != nil {
		return core.MarshalJSONWithExtraProperty(e.BridgeSecret, "type", "bridge_secret")
	}
	if e.BridgeSecretId != "" {
		var marshaler = struct {
			Type           string                   `json:"type"`
			BridgeSecretId BridgeSecretCredentialId `json:"value"`
		}{
			Type:           "bridge_secret_id",
			BridgeSecretId: e.BridgeSecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchBridgeSharedSecretVisitor interface {
	VisitBridgeSecret(*BridgeSecretCredential) error
	VisitBridgeSecretId(BridgeSecretCredentialId) error
}

func (e *ElasticsearchBridgeSharedSecret) Accept(visitor ElasticsearchBridgeSharedSecretVisitor) error {
	if e.BridgeSecret != nil {
		return visitor.VisitBridgeSecret(e.BridgeSecret)
	}
	if e.BridgeSecretId != "" {
		return visitor.VisitBridgeSecretId(e.BridgeSecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchCredential struct {
	Type string
	// Basic authentication credentials for Elasticsearch. When possible use an API key or oAuth credentials instead
	Basic *BasicCredential
	// ID of a credential that stores basic authentication credentials for Elasticsearch.
	BasicId BasicCredentialId
	// Bridge Agent local credentials
	Bridge *ElasticsearchBridgeCredentials
	// Configuration with credentials and connection data for an IdP that has been configured for use as a [JWT realm in Elasticsearch](https://www.elastic.co/guide/en/elasticsearch/reference/8.15/jwt-auth-realm.html). There are also [specific instructions for Elastic Cloud](https://www.elastic.co/guide/en/cloud/current/ec-securing-clusters-JWT.html). This configuration requires a token URL for the 3rd party identity provider. If you need to send specific scopes during the client credentials OAuth flow, specify them in the 'extra' configuration as a list of strings under the 'scopes' key.
	OAuthClient *OAuthClientCredential
	// The ID of a credential that stores the secrets and connection data for an IdP that has been configured for use as a JWT realm in Elasticsearch.
	OAuthClientId OAuthClientCredentialId
	// Elasticsearch API Key. Follow [this guide to generate an API Key](https://www.elastic.co/guide/en/kibana/current/api-keys.html). The API Key must have sufficient permissions to the target index.
	Token *TokenCredential
	// ID of a credential that stores an Elasticsearch API Key.
	TokenId TokenCredentialId
}

func (e *ElasticsearchCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.BasicId = valueUnmarshaler.BasicId
	case "bridge":
		var valueUnmarshaler struct {
			Bridge *ElasticsearchBridgeCredentials `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Bridge = valueUnmarshaler.Bridge
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.OAuthClientId = valueUnmarshaler.OAuthClientId
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (e ElasticsearchCredential) MarshalJSON() ([]byte, error) {
	if e.Basic != nil {
		return core.MarshalJSONWithExtraProperty(e.Basic, "type", "basic")
	}
	if e.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: e.BasicId,
		}
		return json.Marshal(marshaler)
	}
	if e.Bridge != nil {
		var marshaler = struct {
			Type   string                          `json:"type"`
			Bridge *ElasticsearchBridgeCredentials `json:"value"`
		}{
			Type:   "bridge",
			Bridge: e.Bridge,
		}
		return json.Marshal(marshaler)
	}
	if e.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(e.OAuthClient, "type", "o_auth_client")
	}
	if e.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: e.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if e.Token != nil {
		return core.MarshalJSONWithExtraProperty(e.Token, "type", "token")
	}
	if e.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: e.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
	VisitBridge(*ElasticsearchBridgeCredentials) error
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (e *ElasticsearchCredential) Accept(visitor ElasticsearchCredentialVisitor) error {
	if e.Basic != nil {
		return visitor.VisitBasic(e.Basic)
	}
	if e.BasicId != "" {
		return visitor.VisitBasicId(e.BasicId)
	}
	if e.Bridge != nil {
		return visitor.VisitBridge(e.Bridge)
	}
	if e.OAuthClient != nil {
		return visitor.VisitOAuthClient(e.OAuthClient)
	}
	if e.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(e.OAuthClientId)
	}
	if e.Token != nil {
		return visitor.VisitToken(e.Token)
	}
	if e.TokenId != "" {
		return visitor.VisitTokenId(e.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchSharedSecret struct {
	Type string
	// Bridge Agent shared secret local credentials
	Bridge *ElasticsearchBridgeSharedSecret
	// Shared secret used to populate the `ES-Client-Authentication` header during Elasticsearch requests.
	Secret *SecretCredential
	// ID of a credential that stores a shared secret.
	SecretId SecretCredentialId
}

func (e *ElasticsearchSharedSecret) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "bridge":
		var valueUnmarshaler struct {
			Bridge *ElasticsearchBridgeSharedSecret `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.Bridge = valueUnmarshaler.Bridge
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (e ElasticsearchSharedSecret) MarshalJSON() ([]byte, error) {
	if e.Bridge != nil {
		var marshaler = struct {
			Type   string                           `json:"type"`
			Bridge *ElasticsearchBridgeSharedSecret `json:"value"`
		}{
			Type:   "bridge",
			Bridge: e.Bridge,
		}
		return json.Marshal(marshaler)
	}
	if e.Secret != nil {
		return core.MarshalJSONWithExtraProperty(e.Secret, "type", "secret")
	}
	if e.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: e.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchSharedSecretVisitor interface {
	VisitBridge(*ElasticsearchBridgeSharedSecret) error
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (e *ElasticsearchSharedSecret) Accept(visitor ElasticsearchSharedSecretVisitor) error {
	if e.Bridge != nil {
		return visitor.VisitBridge(e.Bridge)
	}
	if e.Secret != nil {
		return visitor.VisitSecret(e.Secret)
	}
	if e.SecretId != "" {
		return visitor.VisitSecretId(e.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EntraIdCredential struct {
	Type string
	// Azure OAuth 2.0 Client ID and Client Secret for a Synqly Identity Connector API service principal. Follow [this guide to generate an API token](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal). The application must be configured with permissions to access the user, group, and audit log graph APIs.
	OAuthClient *OAuthClientCredential
	// The ID of a credential that stores the Azure OAuth 2.0 values for a Synqly Identity Connector API service principal.
	OAuthClientId OAuthClientCredentialId
}

func (e *EntraIdCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (e EntraIdCredential) MarshalJSON() ([]byte, error) {
	if e.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(e.OAuthClient, "type", "o_auth_client")
	}
	if e.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: e.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EntraIdCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (e *EntraIdCredential) Accept(visitor EntraIdCredentialVisitor) error {
	if e.OAuthClient != nil {
		return visitor.VisitOAuthClient(e.OAuthClient)
	}
	if e.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(e.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type GcsCredential struct {
	Type string
	// AWS-type credential that stores [Hash-based message authentication code (HMAC) keys](https://cloud.google.com/storage/docs/authentication/hmackeys) with write access to the GCS bucket.
	Aws *AwsCredential
	// ID of a credential that stores HMAC access keys for the GCS bucket.
	AwsId AwsCredentialId
}

func (g *GcsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (g GcsCredential) MarshalJSON() ([]byte, error) {
	if g.Aws != nil {
		return core.MarshalJSONWithExtraProperty(g.Aws, "type", "aws")
	}
	if g.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: g.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GcsCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (g *GcsCredential) Accept(visitor GcsCredentialVisitor) error {
	if g.Aws != nil {
		return visitor.VisitAws(g.Aws)
	}
	if g.AwsId != "" {
		return visitor.VisitAwsId(g.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleChronicleCredential struct {
	Type string
	// OAuth 2.0 Token URL, Client ID, and Client Secret for a Synqly Siem Connector API service application.
	OAuthClient *OAuthClientCredential
	// The ID of a credential that stores the OAuth 2.0 values for a Synqly Siem Connector API service application.
	OAuthClientId OAuthClientCredentialId
}

func (g *GoogleChronicleCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (g GoogleChronicleCredential) MarshalJSON() ([]byte, error) {
	if g.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(g.OAuthClient, "type", "o_auth_client")
	}
	if g.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: g.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleChronicleCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (g *GoogleChronicleCredential) Accept(visitor GoogleChronicleCredentialVisitor) error {
	if g.OAuthClient != nil {
		return visitor.VisitOAuthClient(g.OAuthClient)
	}
	if g.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(g.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleCredential struct {
	Type string
	// OAuth 2.0 Token URL, Client ID, and Client Secret for a Synqly Identity Connector API service application.
	OAuthClient *OAuthClientCredential
	// The ID of a credential that stores the OAuth 2.0 values for a Synqly Identity Connector API service application.
	OAuthClientId OAuthClientCredentialId
}

func (g *GoogleCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (g GoogleCredential) MarshalJSON() ([]byte, error) {
	if g.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(g.OAuthClient, "type", "o_auth_client")
	}
	if g.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: g.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GoogleCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (g *GoogleCredential) Accept(visitor GoogleCredentialVisitor) error {
	if g.OAuthClient != nil {
		return visitor.VisitOAuthClient(g.OAuthClient)
	}
	if g.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(g.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

// Configuration for the Microsoft Entra ID Identity Provider
type IdentityEntraId struct {
	Credential *EntraIdCredential `json:"credential" url:"credential"`
	// Azure Directory (tenant) ID.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// Optional URL override for the Microsoft Graph API. This should be the base URL for the API without any path components.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityEntraId) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityEntraId) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityEntraId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityEntraId(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IdentityEntraId) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for the Google Identity Provider
type IdentityGoogle struct {
	// The client email associated with the service account key. Typically this will be of the form `<service-account-name>@<project-id>.iam.gserviceaccount.com`.
	ClientEmail string            `json:"client_email" url:"client_email"`
	Credential  *GoogleCredential `json:"credential" url:"credential"`
	// The email address of the user that the service account is impersonating for domain-wide delegation. For more information, see [this Google support article](https://support.google.com/a/answer/162106).
	Delegate string `json:"delegate" url:"delegate"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityGoogle) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityGoogle) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityGoogle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityGoogle(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IdentityGoogle) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for the Okta Identity Provider
type IdentityOkta struct {
	Credential *OktaCredential `json:"credential" url:"credential"`
	// URL for the Okta API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.okta.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityOkta) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityOkta) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityOkta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityOkta(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IdentityOkta) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for the PingOne Identity Platform
type IdentityPingOne struct {
	// The URL base for making authentication requests to PingOne.
	AuthUrl string `json:"auth_url" url:"auth_url"`
	// The client ID for the application set up as a worker.
	ClientId   string             `json:"client_id" url:"client_id"`
	Credential *PingOneCredential `json:"credential" url:"credential"`
	// The organization ID that the client app is a part of.
	OrganizationId string `json:"organization_id" url:"organization_id"`
	// URL for the PingOne API. This should be the base URL for the API, without any path components.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityPingOne) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityPingOne) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityPingOne
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityPingOne(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IdentityPingOne) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JiraCredential struct {
	Type string
	// Username and password used to authenticate with Jira. The password can be a token that is generated following [this guide to generate an API token](https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/). The token receives the same permissions as the user that generates it, so must have access to the projects you want to use.
	Basic *BasicCredential
	// ID of a credential that stores a username and password used to authenticate with Jira.
	BasicId BasicCredentialId
}

func (j *JiraCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", j)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		j.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (j JiraCredential) MarshalJSON() ([]byte, error) {
	if j.Basic != nil {
		return core.MarshalJSONWithExtraProperty(j.Basic, "type", "basic")
	}
	if j.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: j.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", j)
}

type JiraCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (j *JiraCredential) Accept(visitor JiraCredentialVisitor) error {
	if j.Basic != nil {
		return visitor.VisitBasic(j.Basic)
	}
	if j.BasicId != "" {
		return visitor.VisitBasicId(j.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", j)
}

// Configuration for Jira as a Notification Provider
type NotificationsJira struct {
	Credential *JiraCredential `json:"credential" url:"credential"`
	// URL for the Jira API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.atlassian.net".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsJira) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsJira) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsJira
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsJira(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsJira) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for the Mock in-memory notification handler. This provider is for testing purposes only.
type NotificationsMock struct {
	// The channel to send notifications to.
	Channel *string `json:"channel,omitempty" url:"channel,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsMock) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsMock) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsMock) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for the Slack Notification Provider
type NotificationsSlack struct {
	// The channel to send notifications to. Should be the ID of the desired channel.
	Channel    string           `json:"channel" url:"channel"`
	Credential *SlackCredential `json:"credential" url:"credential"`
	// Optional URL override for the Slack API. This should include the full path to the API endpoint.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsSlack) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsSlack) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsSlack
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsSlack(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsSlack) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for sending messages to Microsoft Teams. This provider can be configured as a public webhook or with OAuth.
type NotificationsTeams struct {
	// The ID of the channel to send messages to.
	ChannelId  string           `json:"channel_id" url:"channel_id"`
	Credential *TeamsCredential `json:"credential" url:"credential"`
	// The URL of the endpoint to send messages to. Only specified here if OAuth. For public, please refer to TeamsCredential.
	Endpoint *string `json:"endpoint,omitempty" url:"endpoint,omitempty"`
	// The ID of the team to send messages to.
	TeamId string `json:"team_id" url:"team_id"`
	// Azure Directory (tenant) ID. Only if OAuth is used.
	TenantId *string `json:"tenant_id,omitempty" url:"tenant_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsTeams) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsTeams) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsTeams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsTeams(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NotificationsTeams) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NozomiVantageCredential struct {
	Type string
	// This is your API key name and secret value of your Nozomi Vantage API token. The token name
	// is supplied as the 'username' while the token secret value is supplied as the 'secret'.
	Basic *BasicCredential
	// ID of an existing Synqly credential that stores an Nozomi Vantage API token name and secret.
	BasicId BasicCredentialId
}

func (n *NozomiVantageCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		n.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (n NozomiVantageCredential) MarshalJSON() ([]byte, error) {
	if n.Basic != nil {
		return core.MarshalJSONWithExtraProperty(n.Basic, "type", "basic")
	}
	if n.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: n.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NozomiVantageCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (n *NozomiVantageCredential) Accept(visitor NozomiVantageCredentialVisitor) error {
	if n.Basic != nil {
		return visitor.VisitBasic(n.Basic)
	}
	if n.BasicId != "" {
		return visitor.VisitBasicId(n.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

// Supported credential types for Nucleus
type NucleusCredential struct {
	Type string
	// The Nucleus API key can be generated and copied from the **User Profile** settings, accessible via the avatar in the top-right corner.
	Token *TokenCredential
	// ID of a credential that stores a Nucleus authentication token.
	TokenId TokenCredentialId
}

func (n *NucleusCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		n.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (n NucleusCredential) MarshalJSON() ([]byte, error) {
	if n.Token != nil {
		return core.MarshalJSONWithExtraProperty(n.Token, "type", "token")
	}
	if n.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: n.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NucleusCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (n *NucleusCredential) Accept(visitor NucleusCredentialVisitor) error {
	if n.Token != nil {
		return visitor.VisitToken(n.Token)
	}
	if n.TokenId != "" {
		return visitor.VisitTokenId(n.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

type OktaCredential struct {
	Type string
	// OAuth 2.0 Token URL, Client ID, and Client Secret for a Synqly Identity Connector API service application.
	OAuthClient *OAuthClientCredential
	// The ID of a credential that stores the OAuth 2.0 values for a Synqly Identity Connector API service application.
	OAuthClientId OAuthClientCredentialId
	// Token to authenticate with Okta. Follow [this guide to generate an API token](https://developer.okta.com/docs/guides/create-an-api-token). The token must have access to list records in the system audit log. (Not for production use. Use `o_auth_client` instead)
	Token *TokenCredential
	// ID of a credential that stores a token used to authenticate with Okta. (Not for production use. Use `o_auth_client` instead)
	TokenId TokenCredentialId
}

func (o *OktaCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", o)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		o.OAuthClientId = valueUnmarshaler.OAuthClientId
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		o.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (o OktaCredential) MarshalJSON() ([]byte, error) {
	if o.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(o.OAuthClient, "type", "o_auth_client")
	}
	if o.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: o.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if o.Token != nil {
		return core.MarshalJSONWithExtraProperty(o.Token, "type", "token")
	}
	if o.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: o.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", o)
}

type OktaCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (o *OktaCredential) Accept(visitor OktaCredentialVisitor) error {
	if o.OAuthClient != nil {
		return visitor.VisitOAuthClient(o.OAuthClient)
	}
	if o.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(o.OAuthClientId)
	}
	if o.Token != nil {
		return visitor.VisitToken(o.Token)
	}
	if o.TokenId != "" {
		return visitor.VisitTokenId(o.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", o)
}

type PagerDutyCredential struct {
	Type string
	// PagerDuty authentication token. Follow [this guide to generate an REST API token](https://support.pagerduty.com/docs/api-access-keys#rest-api-keys).
	Token *TokenCredential
	// ID of a credential that stores a PagerDuty authentication token.
	TokenId TokenCredentialId
}

func (p *PagerDutyCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (p PagerDutyCredential) MarshalJSON() ([]byte, error) {
	if p.Token != nil {
		return core.MarshalJSONWithExtraProperty(p.Token, "type", "token")
	}
	if p.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: p.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PagerDutyCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (p *PagerDutyCredential) Accept(visitor PagerDutyCredentialVisitor) error {
	if p.Token != nil {
		return visitor.VisitToken(p.Token)
	}
	if p.TokenId != "" {
		return visitor.VisitTokenId(p.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PingOneCredential struct {
	Type string
	// Client application secret for a worker app. See [these instructions](https://apidocs.pingidentity.com/pingone/tutorial/v1/api/#create-an-admin-worker-app-connection) for help creating a worker application.
	Token *TokenCredential
	// ID of an existing credential that stores a PingOne client application secret.
	TokenId TokenCredentialId
}

func (p *PingOneCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (p PingOneCredential) MarshalJSON() ([]byte, error) {
	if p.Token != nil {
		return core.MarshalJSONWithExtraProperty(p.Token, "type", "token")
	}
	if p.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: p.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PingOneCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (p *PingOneCredential) Accept(visitor PingOneCredentialVisitor) error {
	if p.Token != nil {
		return visitor.VisitToken(p.Token)
	}
	if p.TokenId != "" {
		return visitor.VisitTokenId(p.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type ProviderConfig struct {
	Type                              string
	AssetsArmisCentrix                *AssetsArmisCentrix
	AssetsNozomiVantage               *AssetsNozomiVantage
	AssetsServicenow                  *AssetsServiceNow
	EdrCrowdstrike                    *EdrCrowdStrike
	EdrDefender                       *EdrDefender
	EdrSentinelone                    *EdrSentinelOne
	EdrSophos                         *EdrSophos
	IdentityEntraId                   *IdentityEntraId
	IdentityGoogle                    *IdentityGoogle
	IdentityOkta                      *IdentityOkta
	IdentityPingone                   *IdentityPingOne
	NotificationsJira                 *NotificationsJira
	NotificationsMockNotifications    *NotificationsMock
	NotificationsSlack                *NotificationsSlack
	NotificationsTeams                *NotificationsTeams
	SiemElasticsearch                 *SiemElasticsearch
	SiemGoogleChronicle               *SiemGoogleChronicle
	SiemMockSiem                      *SiemMock
	SiemQRadar                        *SiemQRadar
	SiemRapid7Insightidr              *SiemRapid7InsightIdr
	SiemSplunk                        *SiemSplunk
	SiemSumoLogic                     *SiemSumoLogic
	SinkAwsSecurityLake               *SinkAwsSecurityLake
	SinkAwsSqs                        *SinkAwsSqs
	SinkAzureMonitorLogs              *SinkAzureMonitorLogs
	SinkCrowdstrikeHec                *SinkCrowdstrikeHec
	SinkMockSink                      *SinkMock
	StorageAwsS3                      *StorageAwsS3
	StorageAzureBlob                  *StorageAzureBlob
	StorageGcs                        *StorageGcs
	StorageMockStorage                *StorageMock
	TicketingJira                     *TicketingJira
	TicketingMockTicketing            *TicketingMock
	TicketingPagerduty                *TicketingPagerDuty
	TicketingServicenow               *TicketingServiceNow
	TicketingTorq                     *TicketingTorq
	VulnerabilitiesCrowdstrike        *VulnerabilitiesCrowdStrike
	VulnerabilitiesNucleus            *VulnerabilitiesNucleus
	VulnerabilitiesQualysCloud        *VulnerabilitiesQualysCloud
	VulnerabilitiesRapid7InsightCloud *VulnerabilitiesRapid7InsightCloud
	VulnerabilitiesTaniumCloud        *VulnerabilitiesTaniumCloud
	VulnerabilitiesTenableCloud       *VulnerabilitiesTenableCloud
}

func (p *ProviderConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "assets_armis_centrix":
		value := new(AssetsArmisCentrix)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsArmisCentrix = value
	case "assets_nozomi_vantage":
		value := new(AssetsNozomiVantage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsNozomiVantage = value
	case "assets_servicenow":
		value := new(AssetsServiceNow)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsServicenow = value
	case "edr_crowdstrike":
		value := new(EdrCrowdStrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrCrowdstrike = value
	case "edr_defender":
		value := new(EdrDefender)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrDefender = value
	case "edr_sentinelone":
		value := new(EdrSentinelOne)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrSentinelone = value
	case "edr_sophos":
		value := new(EdrSophos)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrSophos = value
	case "identity_entra_id":
		value := new(IdentityEntraId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityEntraId = value
	case "identity_google":
		value := new(IdentityGoogle)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityGoogle = value
	case "identity_okta":
		value := new(IdentityOkta)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityOkta = value
	case "identity_pingone":
		value := new(IdentityPingOne)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityPingone = value
	case "notifications_jira":
		value := new(NotificationsJira)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsJira = value
	case "notifications_mock_notifications":
		value := new(NotificationsMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsMockNotifications = value
	case "notifications_slack":
		value := new(NotificationsSlack)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsSlack = value
	case "notifications_teams":
		value := new(NotificationsTeams)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsTeams = value
	case "siem_elasticsearch":
		value := new(SiemElasticsearch)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemElasticsearch = value
	case "siem_google_chronicle":
		value := new(SiemGoogleChronicle)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemGoogleChronicle = value
	case "siem_mock_siem":
		value := new(SiemMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemMockSiem = value
	case "siem_q_radar":
		value := new(SiemQRadar)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemQRadar = value
	case "siem_rapid7_insightidr":
		value := new(SiemRapid7InsightIdr)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemRapid7Insightidr = value
	case "siem_splunk":
		value := new(SiemSplunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemSplunk = value
	case "siem_sumo_logic":
		value := new(SiemSumoLogic)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemSumoLogic = value
	case "sink_aws_security_lake":
		value := new(SinkAwsSecurityLake)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAwsSecurityLake = value
	case "sink_aws_sqs":
		value := new(SinkAwsSqs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAwsSqs = value
	case "sink_azure_monitor_logs":
		value := new(SinkAzureMonitorLogs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAzureMonitorLogs = value
	case "sink_crowdstrike_hec":
		value := new(SinkCrowdstrikeHec)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkCrowdstrikeHec = value
	case "sink_mock_sink":
		value := new(SinkMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkMockSink = value
	case "storage_aws_s3":
		value := new(StorageAwsS3)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageAwsS3 = value
	case "storage_azure_blob":
		value := new(StorageAzureBlob)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageAzureBlob = value
	case "storage_gcs":
		value := new(StorageGcs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageGcs = value
	case "storage_mock_storage":
		value := new(StorageMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageMockStorage = value
	case "ticketing_jira":
		value := new(TicketingJira)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingJira = value
	case "ticketing_mock_ticketing":
		value := new(TicketingMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingMockTicketing = value
	case "ticketing_pagerduty":
		value := new(TicketingPagerDuty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingPagerduty = value
	case "ticketing_servicenow":
		value := new(TicketingServiceNow)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingServicenow = value
	case "ticketing_torq":
		value := new(TicketingTorq)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingTorq = value
	case "vulnerabilities_crowdstrike":
		value := new(VulnerabilitiesCrowdStrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesCrowdstrike = value
	case "vulnerabilities_nucleus":
		value := new(VulnerabilitiesNucleus)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesNucleus = value
	case "vulnerabilities_qualys_cloud":
		value := new(VulnerabilitiesQualysCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesQualysCloud = value
	case "vulnerabilities_rapid7_insight_cloud":
		value := new(VulnerabilitiesRapid7InsightCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesRapid7InsightCloud = value
	case "vulnerabilities_tanium_cloud":
		value := new(VulnerabilitiesTaniumCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesTaniumCloud = value
	case "vulnerabilities_tenable_cloud":
		value := new(VulnerabilitiesTenableCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesTenableCloud = value
	}
	return nil
}

func (p ProviderConfig) MarshalJSON() ([]byte, error) {
	if p.AssetsArmisCentrix != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsArmisCentrix, "type", "assets_armis_centrix")
	}
	if p.AssetsNozomiVantage != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsNozomiVantage, "type", "assets_nozomi_vantage")
	}
	if p.AssetsServicenow != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsServicenow, "type", "assets_servicenow")
	}
	if p.EdrCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrCrowdstrike, "type", "edr_crowdstrike")
	}
	if p.EdrDefender != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrDefender, "type", "edr_defender")
	}
	if p.EdrSentinelone != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrSentinelone, "type", "edr_sentinelone")
	}
	if p.EdrSophos != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrSophos, "type", "edr_sophos")
	}
	if p.IdentityEntraId != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityEntraId, "type", "identity_entra_id")
	}
	if p.IdentityGoogle != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityGoogle, "type", "identity_google")
	}
	if p.IdentityOkta != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityOkta, "type", "identity_okta")
	}
	if p.IdentityPingone != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityPingone, "type", "identity_pingone")
	}
	if p.NotificationsJira != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsJira, "type", "notifications_jira")
	}
	if p.NotificationsMockNotifications != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsMockNotifications, "type", "notifications_mock_notifications")
	}
	if p.NotificationsSlack != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsSlack, "type", "notifications_slack")
	}
	if p.NotificationsTeams != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsTeams, "type", "notifications_teams")
	}
	if p.SiemElasticsearch != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemElasticsearch, "type", "siem_elasticsearch")
	}
	if p.SiemGoogleChronicle != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemGoogleChronicle, "type", "siem_google_chronicle")
	}
	if p.SiemMockSiem != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemMockSiem, "type", "siem_mock_siem")
	}
	if p.SiemQRadar != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemQRadar, "type", "siem_q_radar")
	}
	if p.SiemRapid7Insightidr != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemRapid7Insightidr, "type", "siem_rapid7_insightidr")
	}
	if p.SiemSplunk != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemSplunk, "type", "siem_splunk")
	}
	if p.SiemSumoLogic != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemSumoLogic, "type", "siem_sumo_logic")
	}
	if p.SinkAwsSecurityLake != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAwsSecurityLake, "type", "sink_aws_security_lake")
	}
	if p.SinkAwsSqs != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAwsSqs, "type", "sink_aws_sqs")
	}
	if p.SinkAzureMonitorLogs != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAzureMonitorLogs, "type", "sink_azure_monitor_logs")
	}
	if p.SinkCrowdstrikeHec != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkCrowdstrikeHec, "type", "sink_crowdstrike_hec")
	}
	if p.SinkMockSink != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkMockSink, "type", "sink_mock_sink")
	}
	if p.StorageAwsS3 != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageAwsS3, "type", "storage_aws_s3")
	}
	if p.StorageAzureBlob != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageAzureBlob, "type", "storage_azure_blob")
	}
	if p.StorageGcs != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageGcs, "type", "storage_gcs")
	}
	if p.StorageMockStorage != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageMockStorage, "type", "storage_mock_storage")
	}
	if p.TicketingJira != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingJira, "type", "ticketing_jira")
	}
	if p.TicketingMockTicketing != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingMockTicketing, "type", "ticketing_mock_ticketing")
	}
	if p.TicketingPagerduty != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingPagerduty, "type", "ticketing_pagerduty")
	}
	if p.TicketingServicenow != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingServicenow, "type", "ticketing_servicenow")
	}
	if p.TicketingTorq != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingTorq, "type", "ticketing_torq")
	}
	if p.VulnerabilitiesCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesCrowdstrike, "type", "vulnerabilities_crowdstrike")
	}
	if p.VulnerabilitiesNucleus != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesNucleus, "type", "vulnerabilities_nucleus")
	}
	if p.VulnerabilitiesQualysCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesQualysCloud, "type", "vulnerabilities_qualys_cloud")
	}
	if p.VulnerabilitiesRapid7InsightCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesRapid7InsightCloud, "type", "vulnerabilities_rapid7_insight_cloud")
	}
	if p.VulnerabilitiesTaniumCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesTaniumCloud, "type", "vulnerabilities_tanium_cloud")
	}
	if p.VulnerabilitiesTenableCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesTenableCloud, "type", "vulnerabilities_tenable_cloud")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type ProviderConfigVisitor interface {
	VisitAssetsArmisCentrix(*AssetsArmisCentrix) error
	VisitAssetsNozomiVantage(*AssetsNozomiVantage) error
	VisitAssetsServicenow(*AssetsServiceNow) error
	VisitEdrCrowdstrike(*EdrCrowdStrike) error
	VisitEdrDefender(*EdrDefender) error
	VisitEdrSentinelone(*EdrSentinelOne) error
	VisitEdrSophos(*EdrSophos) error
	VisitIdentityEntraId(*IdentityEntraId) error
	VisitIdentityGoogle(*IdentityGoogle) error
	VisitIdentityOkta(*IdentityOkta) error
	VisitIdentityPingone(*IdentityPingOne) error
	VisitNotificationsJira(*NotificationsJira) error
	VisitNotificationsMockNotifications(*NotificationsMock) error
	VisitNotificationsSlack(*NotificationsSlack) error
	VisitNotificationsTeams(*NotificationsTeams) error
	VisitSiemElasticsearch(*SiemElasticsearch) error
	VisitSiemGoogleChronicle(*SiemGoogleChronicle) error
	VisitSiemMockSiem(*SiemMock) error
	VisitSiemQRadar(*SiemQRadar) error
	VisitSiemRapid7Insightidr(*SiemRapid7InsightIdr) error
	VisitSiemSplunk(*SiemSplunk) error
	VisitSiemSumoLogic(*SiemSumoLogic) error
	VisitSinkAwsSecurityLake(*SinkAwsSecurityLake) error
	VisitSinkAwsSqs(*SinkAwsSqs) error
	VisitSinkAzureMonitorLogs(*SinkAzureMonitorLogs) error
	VisitSinkCrowdstrikeHec(*SinkCrowdstrikeHec) error
	VisitSinkMockSink(*SinkMock) error
	VisitStorageAwsS3(*StorageAwsS3) error
	VisitStorageAzureBlob(*StorageAzureBlob) error
	VisitStorageGcs(*StorageGcs) error
	VisitStorageMockStorage(*StorageMock) error
	VisitTicketingJira(*TicketingJira) error
	VisitTicketingMockTicketing(*TicketingMock) error
	VisitTicketingPagerduty(*TicketingPagerDuty) error
	VisitTicketingServicenow(*TicketingServiceNow) error
	VisitTicketingTorq(*TicketingTorq) error
	VisitVulnerabilitiesCrowdstrike(*VulnerabilitiesCrowdStrike) error
	VisitVulnerabilitiesNucleus(*VulnerabilitiesNucleus) error
	VisitVulnerabilitiesQualysCloud(*VulnerabilitiesQualysCloud) error
	VisitVulnerabilitiesRapid7InsightCloud(*VulnerabilitiesRapid7InsightCloud) error
	VisitVulnerabilitiesTaniumCloud(*VulnerabilitiesTaniumCloud) error
	VisitVulnerabilitiesTenableCloud(*VulnerabilitiesTenableCloud) error
}

func (p *ProviderConfig) Accept(visitor ProviderConfigVisitor) error {
	if p.AssetsArmisCentrix != nil {
		return visitor.VisitAssetsArmisCentrix(p.AssetsArmisCentrix)
	}
	if p.AssetsNozomiVantage != nil {
		return visitor.VisitAssetsNozomiVantage(p.AssetsNozomiVantage)
	}
	if p.AssetsServicenow != nil {
		return visitor.VisitAssetsServicenow(p.AssetsServicenow)
	}
	if p.EdrCrowdstrike != nil {
		return visitor.VisitEdrCrowdstrike(p.EdrCrowdstrike)
	}
	if p.EdrDefender != nil {
		return visitor.VisitEdrDefender(p.EdrDefender)
	}
	if p.EdrSentinelone != nil {
		return visitor.VisitEdrSentinelone(p.EdrSentinelone)
	}
	if p.EdrSophos != nil {
		return visitor.VisitEdrSophos(p.EdrSophos)
	}
	if p.IdentityEntraId != nil {
		return visitor.VisitIdentityEntraId(p.IdentityEntraId)
	}
	if p.IdentityGoogle != nil {
		return visitor.VisitIdentityGoogle(p.IdentityGoogle)
	}
	if p.IdentityOkta != nil {
		return visitor.VisitIdentityOkta(p.IdentityOkta)
	}
	if p.IdentityPingone != nil {
		return visitor.VisitIdentityPingone(p.IdentityPingone)
	}
	if p.NotificationsJira != nil {
		return visitor.VisitNotificationsJira(p.NotificationsJira)
	}
	if p.NotificationsMockNotifications != nil {
		return visitor.VisitNotificationsMockNotifications(p.NotificationsMockNotifications)
	}
	if p.NotificationsSlack != nil {
		return visitor.VisitNotificationsSlack(p.NotificationsSlack)
	}
	if p.NotificationsTeams != nil {
		return visitor.VisitNotificationsTeams(p.NotificationsTeams)
	}
	if p.SiemElasticsearch != nil {
		return visitor.VisitSiemElasticsearch(p.SiemElasticsearch)
	}
	if p.SiemGoogleChronicle != nil {
		return visitor.VisitSiemGoogleChronicle(p.SiemGoogleChronicle)
	}
	if p.SiemMockSiem != nil {
		return visitor.VisitSiemMockSiem(p.SiemMockSiem)
	}
	if p.SiemQRadar != nil {
		return visitor.VisitSiemQRadar(p.SiemQRadar)
	}
	if p.SiemRapid7Insightidr != nil {
		return visitor.VisitSiemRapid7Insightidr(p.SiemRapid7Insightidr)
	}
	if p.SiemSplunk != nil {
		return visitor.VisitSiemSplunk(p.SiemSplunk)
	}
	if p.SiemSumoLogic != nil {
		return visitor.VisitSiemSumoLogic(p.SiemSumoLogic)
	}
	if p.SinkAwsSecurityLake != nil {
		return visitor.VisitSinkAwsSecurityLake(p.SinkAwsSecurityLake)
	}
	if p.SinkAwsSqs != nil {
		return visitor.VisitSinkAwsSqs(p.SinkAwsSqs)
	}
	if p.SinkAzureMonitorLogs != nil {
		return visitor.VisitSinkAzureMonitorLogs(p.SinkAzureMonitorLogs)
	}
	if p.SinkCrowdstrikeHec != nil {
		return visitor.VisitSinkCrowdstrikeHec(p.SinkCrowdstrikeHec)
	}
	if p.SinkMockSink != nil {
		return visitor.VisitSinkMockSink(p.SinkMockSink)
	}
	if p.StorageAwsS3 != nil {
		return visitor.VisitStorageAwsS3(p.StorageAwsS3)
	}
	if p.StorageAzureBlob != nil {
		return visitor.VisitStorageAzureBlob(p.StorageAzureBlob)
	}
	if p.StorageGcs != nil {
		return visitor.VisitStorageGcs(p.StorageGcs)
	}
	if p.StorageMockStorage != nil {
		return visitor.VisitStorageMockStorage(p.StorageMockStorage)
	}
	if p.TicketingJira != nil {
		return visitor.VisitTicketingJira(p.TicketingJira)
	}
	if p.TicketingMockTicketing != nil {
		return visitor.VisitTicketingMockTicketing(p.TicketingMockTicketing)
	}
	if p.TicketingPagerduty != nil {
		return visitor.VisitTicketingPagerduty(p.TicketingPagerduty)
	}
	if p.TicketingServicenow != nil {
		return visitor.VisitTicketingServicenow(p.TicketingServicenow)
	}
	if p.TicketingTorq != nil {
		return visitor.VisitTicketingTorq(p.TicketingTorq)
	}
	if p.VulnerabilitiesCrowdstrike != nil {
		return visitor.VisitVulnerabilitiesCrowdstrike(p.VulnerabilitiesCrowdstrike)
	}
	if p.VulnerabilitiesNucleus != nil {
		return visitor.VisitVulnerabilitiesNucleus(p.VulnerabilitiesNucleus)
	}
	if p.VulnerabilitiesQualysCloud != nil {
		return visitor.VisitVulnerabilitiesQualysCloud(p.VulnerabilitiesQualysCloud)
	}
	if p.VulnerabilitiesRapid7InsightCloud != nil {
		return visitor.VisitVulnerabilitiesRapid7InsightCloud(p.VulnerabilitiesRapid7InsightCloud)
	}
	if p.VulnerabilitiesTaniumCloud != nil {
		return visitor.VisitVulnerabilitiesTaniumCloud(p.VulnerabilitiesTaniumCloud)
	}
	if p.VulnerabilitiesTenableCloud != nil {
		return visitor.VisitVulnerabilitiesTenableCloud(p.VulnerabilitiesTenableCloud)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

// List of supported providers.
type ProviderConfigId string

const (
	// Armis Centrix™ for Asset Management and Security
	ProviderConfigIdAssetsArmisCentrix ProviderConfigId = "assets_armis_centrix"
	// Nozomi Vantage
	ProviderConfigIdAssetsNozomiVantage ProviderConfigId = "assets_nozomi_vantage"
	// ServiceNow Configuration Management Database (CMDB)
	ProviderConfigIdAssetsServiceNow ProviderConfigId = "assets_servicenow"
	// CrowdStrike Falcon® Insight EDR
	ProviderConfigIdEdrCrowdStrike ProviderConfigId = "edr_crowdstrike"
	// Microsoft Defender for Endpoint
	ProviderConfigIdEdrDefender ProviderConfigId = "edr_defender"
	// SentinelOne Singularity™ Endpoint
	ProviderConfigIdEdrSentinelOne ProviderConfigId = "edr_sentinelone"
	// Sophos EDR
	ProviderConfigIdEdrSophos ProviderConfigId = "edr_sophos"
	// Microsoft Entra ID
	ProviderConfigIdIdentityEntraId ProviderConfigId = "identity_entra_id"
	// Google Workspace
	ProviderConfigIdIdentityGoogle ProviderConfigId = "identity_google"
	// Okta Identity
	ProviderConfigIdIdentityOkta ProviderConfigId = "identity_okta"
	// PingOne Cloud Platform
	ProviderConfigIdIdentityPingOne ProviderConfigId = "identity_pingone"
	// Atlassian Jira
	ProviderConfigIdNotificationsJira ProviderConfigId = "notifications_jira"
	// Notifications Test
	ProviderConfigIdNotificationsMock ProviderConfigId = "notifications_mock_notifications"
	// Slack
	ProviderConfigIdNotificationsSlack ProviderConfigId = "notifications_slack"
	// Microsoft Teams
	ProviderConfigIdNotificationsTeams ProviderConfigId = "notifications_teams"
	// Elastic SIEM
	ProviderConfigIdSiemElasticsearch ProviderConfigId = "siem_elasticsearch"
	// Google Chronicle
	ProviderConfigIdSiemGoogleChronicle ProviderConfigId = "siem_google_chronicle"
	// SIEM Test
	ProviderConfigIdSiemMock ProviderConfigId = "siem_mock_siem"
	// QRadar
	ProviderConfigIdSiemQRadar ProviderConfigId = "siem_q_radar"
	// Rapid7 InsightIDR
	ProviderConfigIdSiemRapid7InsightIdr ProviderConfigId = "siem_rapid7_insightidr"
	// Splunk Enterprise Security
	ProviderConfigIdSiemSplunk ProviderConfigId = "siem_splunk"
	// Sumo Logic Cloud SIEM
	ProviderConfigIdSiemSumoLogic ProviderConfigId = "siem_sumo_logic"
	// AWS Security Lake
	ProviderConfigIdSinkAwsSecurityLake ProviderConfigId = "sink_aws_security_lake"
	// AWS Simple Queue Service
	ProviderConfigIdSinkAwsSqs ProviderConfigId = "sink_aws_sqs"
	// Microsoft Azure Monitor Logs
	ProviderConfigIdSinkAzureMonitorLogs ProviderConfigId = "sink_azure_monitor_logs"
	// Crowdstrike HEC
	ProviderConfigIdSinkCrowdstrikeHec ProviderConfigId = "sink_crowdstrike_hec"
	// Sink Test
	ProviderConfigIdSinkMock ProviderConfigId = "sink_mock_sink"
	// AWS S3
	ProviderConfigIdStorageAwsS3 ProviderConfigId = "storage_aws_s3"
	// Microsoft Azure Blob Storage
	ProviderConfigIdStorageAzureBlob ProviderConfigId = "storage_azure_blob"
	// Google Cloud Storage
	ProviderConfigIdStorageGcs ProviderConfigId = "storage_gcs"
	// Storage Test
	ProviderConfigIdStorageMock ProviderConfigId = "storage_mock_storage"
	// Atlassian Jira
	ProviderConfigIdTicketingJira ProviderConfigId = "ticketing_jira"
	// Ticketing Test
	ProviderConfigIdTicketingMock ProviderConfigId = "ticketing_mock_ticketing"
	// PagerDuty Operations Cloud
	ProviderConfigIdTicketingPagerDuty ProviderConfigId = "ticketing_pagerduty"
	// ServiceNow IT Service Management (ITSM)
	ProviderConfigIdTicketingServiceNow ProviderConfigId = "ticketing_servicenow"
	// Torq
	ProviderConfigIdTicketingTorq ProviderConfigId = "ticketing_torq"
	// CrowdStrike Falcon Spotlight
	ProviderConfigIdVulnerabilitiesCrowdStrike ProviderConfigId = "vulnerabilities_crowdstrike"
	// Nucleus Vulnerability Management
	ProviderConfigIdVulnerabilitiesNucleus ProviderConfigId = "vulnerabilities_nucleus"
	// Qualys Vulnerability Management, Detection & Response (VMDR)
	ProviderConfigIdVulnerabilitiesQualysCloud ProviderConfigId = "vulnerabilities_qualys_cloud"
	// Rapid7 Insight Vulnerability Management Cloud
	ProviderConfigIdVulnerabilitiesRapid7InsightCloud ProviderConfigId = "vulnerabilities_rapid7_insight_cloud"
	// Tanium Vulnerability Management
	ProviderConfigIdVulnerabilitiesTaniumCloud ProviderConfigId = "vulnerabilities_tanium_cloud"
	// Tenable Vulnerability Management
	ProviderConfigIdVulnerabilitiesTenableCloud ProviderConfigId = "vulnerabilities_tenable_cloud"
	// Any provider config type.
	ProviderConfigIdAll ProviderConfigId = "*"
)

func NewProviderConfigIdFromString(s string) (ProviderConfigId, error) {
	switch s {
	case "assets_armis_centrix":
		return ProviderConfigIdAssetsArmisCentrix, nil
	case "assets_nozomi_vantage":
		return ProviderConfigIdAssetsNozomiVantage, nil
	case "assets_servicenow":
		return ProviderConfigIdAssetsServiceNow, nil
	case "edr_crowdstrike":
		return ProviderConfigIdEdrCrowdStrike, nil
	case "edr_defender":
		return ProviderConfigIdEdrDefender, nil
	case "edr_sentinelone":
		return ProviderConfigIdEdrSentinelOne, nil
	case "edr_sophos":
		return ProviderConfigIdEdrSophos, nil
	case "identity_entra_id":
		return ProviderConfigIdIdentityEntraId, nil
	case "identity_google":
		return ProviderConfigIdIdentityGoogle, nil
	case "identity_okta":
		return ProviderConfigIdIdentityOkta, nil
	case "identity_pingone":
		return ProviderConfigIdIdentityPingOne, nil
	case "notifications_jira":
		return ProviderConfigIdNotificationsJira, nil
	case "notifications_mock_notifications":
		return ProviderConfigIdNotificationsMock, nil
	case "notifications_slack":
		return ProviderConfigIdNotificationsSlack, nil
	case "notifications_teams":
		return ProviderConfigIdNotificationsTeams, nil
	case "siem_elasticsearch":
		return ProviderConfigIdSiemElasticsearch, nil
	case "siem_google_chronicle":
		return ProviderConfigIdSiemGoogleChronicle, nil
	case "siem_mock_siem":
		return ProviderConfigIdSiemMock, nil
	case "siem_q_radar":
		return ProviderConfigIdSiemQRadar, nil
	case "siem_rapid7_insightidr":
		return ProviderConfigIdSiemRapid7InsightIdr, nil
	case "siem_splunk":
		return ProviderConfigIdSiemSplunk, nil
	case "siem_sumo_logic":
		return ProviderConfigIdSiemSumoLogic, nil
	case "sink_aws_security_lake":
		return ProviderConfigIdSinkAwsSecurityLake, nil
	case "sink_aws_sqs":
		return ProviderConfigIdSinkAwsSqs, nil
	case "sink_azure_monitor_logs":
		return ProviderConfigIdSinkAzureMonitorLogs, nil
	case "sink_crowdstrike_hec":
		return ProviderConfigIdSinkCrowdstrikeHec, nil
	case "sink_mock_sink":
		return ProviderConfigIdSinkMock, nil
	case "storage_aws_s3":
		return ProviderConfigIdStorageAwsS3, nil
	case "storage_azure_blob":
		return ProviderConfigIdStorageAzureBlob, nil
	case "storage_gcs":
		return ProviderConfigIdStorageGcs, nil
	case "storage_mock_storage":
		return ProviderConfigIdStorageMock, nil
	case "ticketing_jira":
		return ProviderConfigIdTicketingJira, nil
	case "ticketing_mock_ticketing":
		return ProviderConfigIdTicketingMock, nil
	case "ticketing_pagerduty":
		return ProviderConfigIdTicketingPagerDuty, nil
	case "ticketing_servicenow":
		return ProviderConfigIdTicketingServiceNow, nil
	case "ticketing_torq":
		return ProviderConfigIdTicketingTorq, nil
	case "vulnerabilities_crowdstrike":
		return ProviderConfigIdVulnerabilitiesCrowdStrike, nil
	case "vulnerabilities_nucleus":
		return ProviderConfigIdVulnerabilitiesNucleus, nil
	case "vulnerabilities_qualys_cloud":
		return ProviderConfigIdVulnerabilitiesQualysCloud, nil
	case "vulnerabilities_rapid7_insight_cloud":
		return ProviderConfigIdVulnerabilitiesRapid7InsightCloud, nil
	case "vulnerabilities_tanium_cloud":
		return ProviderConfigIdVulnerabilitiesTaniumCloud, nil
	case "vulnerabilities_tenable_cloud":
		return ProviderConfigIdVulnerabilitiesTenableCloud, nil
	case "*":
		return ProviderConfigIdAll, nil
	}
	var t ProviderConfigId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderConfigId) Ptr() *ProviderConfigId {
	return &p
}

type QRadarCredential struct {
	Type string
	// QRadar authorized service token. Follow [this guide to generate a token](https://www.ibm.com/docs/en/qradar-common?topic=app-creating-authorized-service-token-qradar-operations).
	Token *TokenCredential
	// ID of a Synqly Credential that stores an authorized service token.
	TokenId TokenCredentialId
}

func (q *QRadarCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	q.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", q)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		q.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		q.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (q QRadarCredential) MarshalJSON() ([]byte, error) {
	if q.Token != nil {
		return core.MarshalJSONWithExtraProperty(q.Token, "type", "token")
	}
	if q.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: q.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QRadarCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (q *QRadarCredential) Accept(visitor QRadarCredentialVisitor) error {
	if q.Token != nil {
		return visitor.VisitToken(q.Token)
	}
	if q.TokenId != "" {
		return visitor.VisitTokenId(q.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QualysCloudCredential struct {
	Type string
	// Qualys Cloud username and password used to authenticate with Qualys Cloud.
	Basic *BasicCredential
	// ID of a credential that stores a Qualys Cloud username and password.
	BasicId BasicCredentialId
}

func (q *QualysCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	q.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", q)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		q.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		q.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (q QualysCloudCredential) MarshalJSON() ([]byte, error) {
	if q.Basic != nil {
		return core.MarshalJSONWithExtraProperty(q.Basic, "type", "basic")
	}
	if q.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: q.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QualysCloudCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (q *QualysCloudCredential) Accept(visitor QualysCloudCredentialVisitor) error {
	if q.Basic != nil {
		return visitor.VisitBasic(q.Basic)
	}
	if q.BasicId != "" {
		return visitor.VisitBasicId(q.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", q)
}

type Rapid7InsightCloudCredential struct {
	Type string
	// Rapid7 Insight Cloud authentication token. Follow [this guide to generate an API token](https://docs.rapid7.com/insight/managing-platform-api-keys/).
	Token *TokenCredential
	// ID of a credential that stores a Rapid7 Insight Cloud authentication token.
	TokenId TokenCredentialId
}

func (r *Rapid7InsightCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (r Rapid7InsightCloudCredential) MarshalJSON() ([]byte, error) {
	if r.Token != nil {
		return core.MarshalJSONWithExtraProperty(r.Token, "type", "token")
	}
	if r.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: r.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type Rapid7InsightCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (r *Rapid7InsightCloudCredential) Accept(visitor Rapid7InsightCloudCredentialVisitor) error {
	if r.Token != nil {
		return visitor.VisitToken(r.Token)
	}
	if r.TokenId != "" {
		return visitor.VisitTokenId(r.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

// Configuration for Elasticsearch search and analytics engine. Supports both managed and self-hosted Elasticsearch deployments
type SiemElasticsearch struct {
	AuthOptions *ElasticsearchAuthOptions `json:"auth_options,omitempty" url:"auth_options,omitempty"`
	// Optional. The index or data stream to use when writing events. Defaults to the 'index' setting if not set.
	CreateIndex *string                  `json:"create_index,omitempty" url:"create_index,omitempty"`
	Credential  *ElasticsearchCredential `json:"credential" url:"credential"`
	// Optional. The index, data stream, or index alias to read events from.
	Index *string `json:"index,omitempty" url:"index,omitempty"`
	// If true, skips verification of the Elasticsearch server's TLS certificate.
	SkipTlsVerify *bool `json:"skip_tls_verify,omitempty" url:"skip_tls_verify,omitempty"`
	// URL for the Elasticsearch API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.elastic.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemElasticsearch) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemElasticsearch) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemElasticsearch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemElasticsearch(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemElasticsearch) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Google Chronicle as a SIEM Provider.
type SiemGoogleChronicle struct {
	// Optional ingestion credential. Without this credential the provider will not be able to ingest events.
	IngestionCredential *GoogleChronicleCredential `json:"ingestion_credential,omitempty" url:"ingestion_credential,omitempty"`
	// (Optional) Ingestion URL for the Google Chronicle instance. This should be the base event ingestion URL, without any path components. Default "https://malachiteingestion-pa.googleapis.com"
	IngestionUrl     *string                    `json:"ingestion_url,omitempty" url:"ingestion_url,omitempty"`
	SearchCredential *GoogleChronicleCredential `json:"search_credential" url:"search_credential"`
	// Search URL for the Google Chronicle instance. This should be the base event search URL, without any path components. Default "https://backstory.googleapis.com".
	SearchUrl *string `json:"search_url,omitempty" url:"search_url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemGoogleChronicle) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemGoogleChronicle) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemGoogleChronicle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemGoogleChronicle(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemGoogleChronicle) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory SIEM handler. This provider is for testing purposes only and does not retain events pushed to it.
type SiemMock struct {
	// Name of the index where events are stored.
	Index *string `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemMock) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for IBM QRadar as a SIEM Provider.
type SiemQRadar struct {
	// The QRadar HTTP Receiver URL, stored as a secret. This URL has a special port in QRadar and is stored in a credential to protect that information. See https://www.youtube.com/watch?v=UEBLVVNpyfg for a demonstration of setting up and mapping and HTTP Receiver in QRadar.
	CollectionPort int               `json:"collection_port" url:"collection_port"`
	Credential     *QRadarCredential `json:"credential" url:"credential"`
	// If true, skips verification of the QRadar server's TLS certificate.
	SkipTlsVerify bool `json:"skip_tls_verify" url:"skip_tls_verify"`
	// URL for the QRadar instance. This should be the base URL instance, without any path components and must be HTTPS. For example, "https://qradar.westus2.cloudapp.azure.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemQRadar) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemQRadar) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemQRadar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemQRadar(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemQRadar) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Rapid7 InsightIDR as a SIEM Provider.
type SiemRapid7InsightIdr struct {
	Credential *Rapid7InsightCloudCredential `json:"credential" url:"credential"`
	// URL for the Rapid7 API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://us2.api.insight.rapid7.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemRapid7InsightIdr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemRapid7InsightIdr) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemRapid7InsightIdr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemRapid7InsightIdr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemRapid7InsightIdr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Splunk as a SIEM Provider. This integration allows sending data to Splunk using an HTTP Event Collector (HEC). Additionally, it can be used to query Splunk using the Splunk Search Service.
type SiemSplunk struct {
	HecCredential *SplunkHecToken `json:"hec_credential" url:"hec_credential"`
	// URL for the Splunk HEC endpoint. This must include the full path to the HEC endpoint. For example, "https://tenant.cloud.splunk.com:8088/services_collector_event".
	HecUrl string `json:"hec_url" url:"hec_url"`
	// Splunk index to send events to. If not provided, will use the default index for the Splunk collector.
	Index *string `json:"index,omitempty" url:"index,omitempty"`
	// Optional id of a credential used for connecting to the Splunk search service. If not provided, querying is disabled.
	SearchServiceCredential *SplunkSearchCredential `json:"search_service_credential,omitempty" url:"search_service_credential,omitempty"`
	// Optional URL used for connecting to the Splunk search service. If not provided, querying is disabled.
	SearchServiceUrl *string `json:"search_service_url,omitempty" url:"search_service_url,omitempty"`
	// If true, skips verification of the Splunk server's TLS certificate.
	SkipTlsVerify bool `json:"skip_tls_verify" url:"skip_tls_verify"`
	// Splunk source to send events to. If not provided, will use the default source for the Splunk collector.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// Splunk source type to send events to. If not provided, will use the default source type for the Splunk collector.
	SourceType *string `json:"source_type,omitempty" url:"source_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemSplunk) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemSplunk) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemSplunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemSplunk(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemSplunk) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Sumo Logic Cloud SIEM.
type SiemSumoLogic struct {
	// Automatically parse logs as JSON when running log queries against Sumo Logic.
	AutoParseLogs *bool `json:"auto_parse_logs,omitempty" url:"auto_parse_logs,omitempty"`
	// Required if you need to send Sumo Logic events from the Synqly API.
	CollectionUrl *SumoLogicCollectionUrl `json:"collection_url,omitempty" url:"collection_url,omitempty"`
	Credential    *SumoLogicCredential    `json:"credential" url:"credential"`
	// Only query for logs that have been processed into the Sumo Logic Cloud SIEM app.
	SiemLogsOnly *bool `json:"siem_logs_only,omitempty" url:"siem_logs_only,omitempty"`
	// Your Sumo Logic API endpoint. See https://help.sumologic.com/docs/api/getting-started/#sumo-logic-endpoints-by-deployment-and-firewall-security for help determining which base URL to use.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemSumoLogic) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemSumoLogic) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemSumoLogic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemSumoLogic(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SiemSumoLogic) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SentinelOneCredential struct {
	Type string
	// SentinelOne API token for authentication. Follow the API DOC overview once logged into your SentinelOne Management URL, "https://your_management_url/docs/en/generating-api-tokens.html".
	Token *TokenCredential
	// ID of an existing credential that stores a SentinelOne API token.
	TokenId TokenCredentialId
}

func (s *SentinelOneCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SentinelOneCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SentinelOneCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SentinelOneCredential) Accept(visitor SentinelOneCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type ServiceNowCredential struct {
	Type string
	// Username and password used to authenticate with ServiceNow. The password can be a token that is generated following [this guide to generate an API token](https://docs.servicenow.com/bundle/vancouver-platform-administration/page/administer/users-and-groups/task/t_CreateAUser.html). The token receives the same permissions as the user that generates it, so must have access to the projects you want to use.
	Basic *BasicCredential
	// ID of a credential that stores a username and password used to authenticate with ServiceNow.
	BasicId BasicCredentialId
	// Token used to authenticate with ServiceNow. This token will be used with the authentication header `x-sn-apikey`. To use token authentication, the version of ServiceNow must be Washington D.C. or later.
	Token *TokenCredential
	// ID of a credential that stores a token used to authenticate with ServiceNow.
	TokenId TokenCredentialId
}

func (s *ServiceNowCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.BasicId = valueUnmarshaler.BasicId
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s ServiceNowCredential) MarshalJSON() ([]byte, error) {
	if s.Basic != nil {
		return core.MarshalJSONWithExtraProperty(s.Basic, "type", "basic")
	}
	if s.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: s.BasicId,
		}
		return json.Marshal(marshaler)
	}
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type ServiceNowCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *ServiceNowCredential) Accept(visitor ServiceNowCredentialVisitor) error {
	if s.Basic != nil {
		return visitor.VisitBasic(s.Basic)
	}
	if s.BasicId != "" {
		return visitor.VisitBasicId(s.BasicId)
	}
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// Configuration for AWS Simple Queue Service (SQS) as a Sink Provider.
type SinkAwsSqs struct {
	// Credential ID that stores AWS authentication key and secret. This token pair must have write access to the configured SQS queue
	Credential *AwsSqsCredential `json:"credential" url:"credential"`
	// Override the default AWS region for this integration. If not present, the region will be inferred from the URL.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// URL of the SQS queue where events are sent. Must be in the format `https://sqs.{region}.amazonaws.com_{account_id}/{queue_name}`.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAwsSqs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAwsSqs) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAwsSqs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAwsSqs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkAwsSqs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for AWS Security Lake provider. Events are written directly to an AWS S3 bucket in Apache Parquet format.
type SinkAwsSecurityLake struct {
	Credential *AwsSecurityLakeCredential `json:"credential" url:"credential"`
	// Override the default AWS region for this integration. If not present, the region will be inferred from the URL.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// URL of the S3 bucket where the AWS Security Lake events are stored.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAwsSecurityLake) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAwsSecurityLake) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAwsSecurityLake
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAwsSecurityLake(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkAwsSecurityLake) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Azure Monitor Logs as a Sink Provider. Azure Monitor Logs is a feature of Azure Monitor that collects and organizes log and performance data from monitored resources.
type SinkAzureMonitorLogs struct {
	// Azure Client (Application) ID.
	ClientId   string                      `json:"client_id" url:"client_id"`
	Credential *AzureMonitorLogsCredential `json:"credential" url:"credential"`
	// Data collection rule immutable ID.
	RuleId string `json:"rule_id" url:"rule_id"`
	// Name of the Data collection rule stream.
	StreamName string `json:"stream_name" url:"stream_name"`
	// Azure Directory (tenant) ID.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// URL of the Azure data collection endpoint.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAzureMonitorLogs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAzureMonitorLogs) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAzureMonitorLogs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAzureMonitorLogs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkAzureMonitorLogs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Crowdstrike HEC as a Sink Provider
type SinkCrowdstrikeHec struct {
	Credential *CrowdstrikeHecCredential `json:"credential" url:"credential"`
	// API URL for the CrowdStrike HEC API. This must be an HTTPS URL, for example "https://<some-guid>.ingest.us-2.crowdstrike.com/services/collector".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkCrowdstrikeHec) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkCrowdstrikeHec) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkCrowdstrikeHec
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkCrowdstrikeHec(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkCrowdstrikeHec) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory sink handler. This provider is for testing purposes only and does not retain events pushed to it.
type SinkMock struct {
	// Name of the destination where events are stored. This property is unused.
	Destination *string `json:"destination,omitempty" url:"destination,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkMock) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SinkMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SlackCredential struct {
	Type string
	// Slack authentication token. Follow [this guide to generate an API token](https://api.slack.com/concepts/token-types#bot). The token must have access to the configured channel.
	Token *TokenCredential
	// ID of a credential that stores a token used to authenticate with Slack.
	TokenId TokenCredentialId
}

func (s *SlackCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SlackCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SlackCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SlackCredential) Accept(visitor SlackCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SophosCredential struct {
	Type string
	// Docs for setting up oAuth - https://developer.sophos.com/intro#getting-started
	OAuthClient *OAuthClientCredential
	// ID of a credential that stores a Sophos oAuth client ID.
	OAuthClientId OAuthClientCredentialId
}

func (s *SophosCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (s SophosCredential) MarshalJSON() ([]byte, error) {
	if s.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(s.OAuthClient, "type", "o_auth_client")
	}
	if s.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: s.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SophosCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (s *SophosCredential) Accept(visitor SophosCredentialVisitor) error {
	if s.OAuthClient != nil {
		return visitor.VisitOAuthClient(s.OAuthClient)
	}
	if s.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(s.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkBridgeHecToken struct {
	Type string
	// Credential ID that stores a Splunk HTTP endpoint collector synqly bridge agent local token definition. Follow [this guide to generate an API token](https://docs.splunk.com/Documentation/Splunk/8.1.3/Data/UsetheHTTPEventCollector#Authentication). The token must have access to the configured data collection endpoint.
	BridgeToken *BridgeTokenCredential
	// ID of a credential that stores a Splunk HTTP endpoint collector (HEC) synqly bridge agent local token definition.
	BridgeTokenId BridgeTokenCredentialId
}

func (s *SplunkBridgeHecToken) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "bridge_token":
		value := new(BridgeTokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.BridgeToken = value
	case "bridge_token_id":
		var valueUnmarshaler struct {
			BridgeTokenId BridgeTokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.BridgeTokenId = valueUnmarshaler.BridgeTokenId
	}
	return nil
}

func (s SplunkBridgeHecToken) MarshalJSON() ([]byte, error) {
	if s.BridgeToken != nil {
		return core.MarshalJSONWithExtraProperty(s.BridgeToken, "type", "bridge_token")
	}
	if s.BridgeTokenId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			BridgeTokenId BridgeTokenCredentialId `json:"value"`
		}{
			Type:          "bridge_token_id",
			BridgeTokenId: s.BridgeTokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkBridgeHecTokenVisitor interface {
	VisitBridgeToken(*BridgeTokenCredential) error
	VisitBridgeTokenId(BridgeTokenCredentialId) error
}

func (s *SplunkBridgeHecToken) Accept(visitor SplunkBridgeHecTokenVisitor) error {
	if s.BridgeToken != nil {
		return visitor.VisitBridgeToken(s.BridgeToken)
	}
	if s.BridgeTokenId != "" {
		return visitor.VisitBridgeTokenId(s.BridgeTokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkBridgeSearchCredential struct {
	Type string
	// Optional URL used for connecting to the Splunk search service through a synqly bridge agent with local credentials. If not provided, querying is disabled.
	BridgeToken *BridgeTokenCredential
	// Optional id of a credential used for connecting to the Splunk search service through a synqly bridge agent with local credentials.
	BridgeTokenId BridgeTokenCredentialId
}

func (s *SplunkBridgeSearchCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "bridge_token":
		value := new(BridgeTokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.BridgeToken = value
	case "bridge_token_id":
		var valueUnmarshaler struct {
			BridgeTokenId BridgeTokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.BridgeTokenId = valueUnmarshaler.BridgeTokenId
	}
	return nil
}

func (s SplunkBridgeSearchCredential) MarshalJSON() ([]byte, error) {
	if s.BridgeToken != nil {
		return core.MarshalJSONWithExtraProperty(s.BridgeToken, "type", "bridge_token")
	}
	if s.BridgeTokenId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			BridgeTokenId BridgeTokenCredentialId `json:"value"`
		}{
			Type:          "bridge_token_id",
			BridgeTokenId: s.BridgeTokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkBridgeSearchCredentialVisitor interface {
	VisitBridgeToken(*BridgeTokenCredential) error
	VisitBridgeTokenId(BridgeTokenCredentialId) error
}

func (s *SplunkBridgeSearchCredential) Accept(visitor SplunkBridgeSearchCredentialVisitor) error {
	if s.BridgeToken != nil {
		return visitor.VisitBridgeToken(s.BridgeToken)
	}
	if s.BridgeTokenId != "" {
		return visitor.VisitBridgeTokenId(s.BridgeTokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkHecToken struct {
	Type string
	// Bridge Agent HEC local credentials
	Bridge *SplunkBridgeHecToken
	// Credential ID that stores a Splunk HTTP endpoint collector token. Follow [this guide to generate an API token](https://docs.splunk.com/Documentation/Splunk/8.1.3/Data/UsetheHTTPEventCollector#Authentication). The token must have access to the configured data collection endpoint.
	Token *TokenCredential
	// ID of a credential that stores a Splunk HTTP endpoint collector (HEC) token.
	TokenId TokenCredentialId
}

func (s *SplunkHecToken) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "bridge":
		var valueUnmarshaler struct {
			Bridge *SplunkBridgeHecToken `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.Bridge = valueUnmarshaler.Bridge
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SplunkHecToken) MarshalJSON() ([]byte, error) {
	if s.Bridge != nil {
		var marshaler = struct {
			Type   string                `json:"type"`
			Bridge *SplunkBridgeHecToken `json:"value"`
		}{
			Type:   "bridge",
			Bridge: s.Bridge,
		}
		return json.Marshal(marshaler)
	}
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkHecTokenVisitor interface {
	VisitBridge(*SplunkBridgeHecToken) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SplunkHecToken) Accept(visitor SplunkHecTokenVisitor) error {
	if s.Bridge != nil {
		return visitor.VisitBridge(s.Bridge)
	}
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkSearchCredential struct {
	Type string
	// Bridge Agent search local credentials
	Bridge *SplunkBridgeSearchCredential
	// Optional URL used for connecting to the Splunk search service. If not provided, querying is disabled.
	Token *TokenCredential
	// Optional id of a credential used for connecting to the Splunk search service.
	TokenId TokenCredentialId
}

func (s *SplunkSearchCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "bridge":
		var valueUnmarshaler struct {
			Bridge *SplunkBridgeSearchCredential `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.Bridge = valueUnmarshaler.Bridge
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SplunkSearchCredential) MarshalJSON() ([]byte, error) {
	if s.Bridge != nil {
		var marshaler = struct {
			Type   string                        `json:"type"`
			Bridge *SplunkBridgeSearchCredential `json:"value"`
		}{
			Type:   "bridge",
			Bridge: s.Bridge,
		}
		return json.Marshal(marshaler)
	}
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkSearchCredentialVisitor interface {
	VisitBridge(*SplunkBridgeSearchCredential) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SplunkSearchCredential) Accept(visitor SplunkSearchCredentialVisitor) error {
	if s.Bridge != nil {
		return visitor.VisitBridge(s.Bridge)
	}
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// Configuration for AWS S3 as a Storage Provider
type StorageAwsS3 struct {
	// Name of the AWS S3 bucket where files are stored.
	Bucket     string           `json:"bucket" url:"bucket"`
	Credential *AwsS3Credential `json:"credential" url:"credential"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty" url:"endpoint,omitempty"`
	// AWS region where the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty" url:"transforms,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageAwsS3) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageAwsS3) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageAwsS3
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageAwsS3(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StorageAwsS3) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Azure Blob Storage as a Storage Provider
type StorageAzureBlob struct {
	// Name of the blob container where files are stored.
	Bucket     string               `json:"bucket" url:"bucket"`
	Credential *AzureBlobCredential `json:"credential" url:"credential"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty" url:"transforms,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageAzureBlob) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageAzureBlob) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageAzureBlob
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageAzureBlob(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StorageAzureBlob) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Google Cloud Storage for storing unstructured data
type StorageGcs struct {
	// Name of the bucket where files are stored.
	Bucket     string         `json:"bucket" url:"bucket"`
	Credential *GcsCredential `json:"credential" url:"credential"`
	// Google Cloud region where the bucket is located.
	Region string `json:"region" url:"region"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty" url:"transforms,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageGcs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageGcs) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageGcs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageGcs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StorageGcs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory storage handler. This provider is for testing purposes only and does not retain files pushed to it.
type StorageMock struct {
	// Name of the bucket where files are stored.
	Bucket string `json:"bucket" url:"bucket"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageMock) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StorageMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SumoLogicCollectionUrl struct {
	Type string
	// The Sumo Logic HTTP collection URL, stored as a secret. This URL contains all of the authorization information for sending logs to Sumo Logic and is stored in a credential to protect that information. See https://help.sumologic.com/docs/send-data/hosted-collectors/http-source/logs-metrics/ for instruction on generating a collection URL.
	Secret *SecretCredential
	// ID of a credential that stores a Sumo Logic HTTP collection URL.
	SecretId SecretCredentialId
}

func (s *SumoLogicCollectionUrl) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (s SumoLogicCollectionUrl) MarshalJSON() ([]byte, error) {
	if s.Secret != nil {
		return core.MarshalJSONWithExtraProperty(s.Secret, "type", "secret")
	}
	if s.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: s.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCollectionUrlVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (s *SumoLogicCollectionUrl) Accept(visitor SumoLogicCollectionUrlVisitor) error {
	if s.Secret != nil {
		return visitor.VisitSecret(s.Secret)
	}
	if s.SecretId != "" {
		return visitor.VisitSecretId(s.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCredential struct {
	Type string
	// Your Access ID and Access Key. See https://help.sumologic.com/docs/api/getting-started/#authentication for information on generating these values.
	Basic *BasicCredential
	// ID of a credential that stores a Sumo Logic Access ID and Access Key.
	BasicId BasicCredentialId
}

func (s *SumoLogicCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (s SumoLogicCredential) MarshalJSON() ([]byte, error) {
	if s.Basic != nil {
		return core.MarshalJSONWithExtraProperty(s.Basic, "type", "basic")
	}
	if s.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: s.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (s *SumoLogicCredential) Accept(visitor SumoLogicCredentialVisitor) error {
	if s.Basic != nil {
		return visitor.VisitBasic(s.Basic)
	}
	if s.BasicId != "" {
		return visitor.VisitBasicId(s.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// Supported credential types for Tanium Cloud
type TaniumCloudCredential struct {
	Type string
	// Tanium™ API authentication tokens allow users to maintain extended sessions with Tanium Cloud, eliminating the need for repeated authentication in long-running workflows that aren't continuously active. Each token is tied to a specific user or persona, authenticating based on their credentials and permissions. Multiple tokens can be created per user or persona, with a configurable expiration period. To avoid workflow disruptions, users should regularly rotate tokens by requesting new ones and revoking the old ones before they expire. For more details on generating, managing, rotating, or revoking an API token, please refer to [this API Token guide](https://help.tanium.com/bundle/ug_console_cloud/page/platform_user/console_api_tokens.html#add_API_tokens). A persona in Tanium is a set of roles and computer groups selected for a session, allowing different restrictions for a user without needing multiple accounts. For example, a user managing endpoints across various countries can have one persona for client maintenance in a specific country and another for security patch installations in only certain computer groups. For more details please refer our [Tanium Authentication Guide](ref:tanium-setup).
	Token *TokenCredential
	// ID of a credential that stores a Tanium Cloud authentication token.
	TokenId TokenCredentialId
}

func (t *TaniumCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (t TaniumCloudCredential) MarshalJSON() ([]byte, error) {
	if t.Token != nil {
		return core.MarshalJSONWithExtraProperty(t.Token, "type", "token")
	}
	if t.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: t.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TaniumCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (t *TaniumCloudCredential) Accept(visitor TaniumCloudCredentialVisitor) error {
	if t.Token != nil {
		return visitor.VisitToken(t.Token)
	}
	if t.TokenId != "" {
		return visitor.VisitTokenId(t.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TeamsCredential struct {
	Type string
	// Azure OAuth 2.0 Client ID and Client Secret for an Azure App Registration. Follow [this guide to generate an API token](https://learn.microsoft.com/en-us/connectors/azureadapplications/). The application must be configured with permissions to access Microsoft Power Automate with user delegation.
	OAuthClient *OAuthClientCredential
	// The ID of a credential that stores the Azure OAuth 2.0 values for an azure App Registration.
	OAuthClientId OAuthClientCredentialId
	// Public Webhook URL used to authenticate with Teams.
	WebhookUrl *SecretCredential
	// ID of a credential that stores a public Webhook URL used to authenticate with Teams.
	WebhookUrlId SecretCredentialId
}

func (t *TeamsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.OAuthClientId = valueUnmarshaler.OAuthClientId
	case "webhook_url":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.WebhookUrl = value
	case "webhook_url_id":
		var valueUnmarshaler struct {
			WebhookUrlId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.WebhookUrlId = valueUnmarshaler.WebhookUrlId
	}
	return nil
}

func (t TeamsCredential) MarshalJSON() ([]byte, error) {
	if t.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(t.OAuthClient, "type", "o_auth_client")
	}
	if t.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: t.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if t.WebhookUrl != nil {
		return core.MarshalJSONWithExtraProperty(t.WebhookUrl, "type", "webhook_url")
	}
	if t.WebhookUrlId != "" {
		var marshaler = struct {
			Type         string             `json:"type"`
			WebhookUrlId SecretCredentialId `json:"value"`
		}{
			Type:         "webhook_url_id",
			WebhookUrlId: t.WebhookUrlId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TeamsCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
	VisitWebhookUrl(*SecretCredential) error
	VisitWebhookUrlId(SecretCredentialId) error
}

func (t *TeamsCredential) Accept(visitor TeamsCredentialVisitor) error {
	if t.OAuthClient != nil {
		return visitor.VisitOAuthClient(t.OAuthClient)
	}
	if t.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(t.OAuthClientId)
	}
	if t.WebhookUrl != nil {
		return visitor.VisitWebhookUrl(t.WebhookUrl)
	}
	if t.WebhookUrlId != "" {
		return visitor.VisitWebhookUrlId(t.WebhookUrlId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

// Supported credential types for Tenable Cloud
type TenableCloudCredential struct {
	Type string
	// Tenable Cloud authentication token. Follow [this guide to generate an API token](https://docs.tenable.com/vulnerability-management/Content/Settings/my-account/GenerateAPIKey.htm). Secret must be of the form accessKey=<key>;secretKey=<secret>.
	Token *TokenCredential
	// ID of a credential that stores a Tenable Cloud authentication token.
	TokenId TokenCredentialId
}

func (t *TenableCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (t TenableCloudCredential) MarshalJSON() ([]byte, error) {
	if t.Token != nil {
		return core.MarshalJSONWithExtraProperty(t.Token, "type", "token")
	}
	if t.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: t.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TenableCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (t *TenableCloudCredential) Accept(visitor TenableCloudCredentialVisitor) error {
	if t.Token != nil {
		return visitor.VisitToken(t.Token)
	}
	if t.TokenId != "" {
		return visitor.VisitTokenId(t.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

// Configuration for Jira as a Ticketing Provider
type TicketingJira struct {
	Credential *JiraCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Default Project for the integration.
	DefaultProject *string `json:"default_project,omitempty" url:"default_project,omitempty"`
	// URL for the Jira API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.atlassian.net".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingJira) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingJira) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingJira
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingJira(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingJira) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for the Synqly mock in-memory ticketing handler. This provider is for testing purposes only. It retains tickets for a limited time and does not persist them for long-term usage.
type TicketingMock struct {
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Optional name of the mock provider. This value is unused.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingMock) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingMock) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingMock) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for PagerDuty as a Ticketing Provider
type TicketingPagerDuty struct {
	Credential *PagerDutyCredential `json:"credential" url:"credential"`
	// URL for the PagerDuty API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://api.pagerduty.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingPagerDuty) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingPagerDuty) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingPagerDuty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingPagerDuty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingPagerDuty) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for ServiceNow as a Ticketing Provider
type TicketingServiceNow struct {
	Credential *ServiceNowCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Default Project for the integration. This maps to the custom table for tickets. This table should be derived from Incident table. If not provided, defaults to the incident table.
	DefaultProject *string `json:"default_project,omitempty" url:"default_project,omitempty"`
	// URL for the ServiceNow API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.service-now.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingServiceNow) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingServiceNow) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingServiceNow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingServiceNow(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingServiceNow) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for Torq as a Ticketing Provider
type TicketingTorq struct {
	Credential *TorqCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingTorq) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingTorq) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingTorq
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingTorq(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingTorq) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TorqCredential struct {
	Type string
	// Client ID for the Torq REST API. [Torq API key generation documentation](https://learn.torq.io/apidocs/authentication).
	OAuthClient *OAuthClientCredential
	// Synqly credential id for the Torq Client ID and Client Secret.
	OAuthClientId OAuthClientCredentialId
}

func (t *TorqCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (t TorqCredential) MarshalJSON() ([]byte, error) {
	if t.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(t.OAuthClient, "type", "o_auth_client")
	}
	if t.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: t.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TorqCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (t *TorqCredential) Accept(visitor TorqCredentialVisitor) error {
	if t.OAuthClient != nil {
		return visitor.VisitOAuthClient(t.OAuthClient)
	}
	if t.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(t.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

// Configuration for CrowdStrike Falcon as a Vulnerabilities Provider
type VulnerabilitiesCrowdStrike struct {
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// The root domain where your CrowdStrike Falcon tenant is located.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesCrowdStrike) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesCrowdStrike) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesCrowdStrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesCrowdStrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesCrowdStrike) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Nucleus as a Vulnerabilities Provider
type VulnerabilitiesNucleus struct {
	Credential *NucleusCredential `json:"credential" url:"credential"`
	// The **project_id** is a string representing a numeric ID (e.g., "12345") and can be found in the Nucleus UI by selecting **Global Dashboard** from the left-hand menu, then choosing **All Projects** at the top, where the **Projects** widget lists all projects with their IDs.
	ProjectId string `json:"project_id" url:"project_id"`
	// URL for the Nucleus API. This should be the base URL for the API, without any path components and must be HTTPS, e.g. "https://{sandbox}.nucleussec.com" .
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesNucleus) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesNucleus) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesNucleus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesNucleus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesNucleus) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Qualys Cloud Platform as a Vulnerabilities Provider
type VulnerabilitiesQualysCloud struct {
	Credential *QualysCloudCredential `json:"credential" url:"credential"`
	// URL for the Qualys Cloud API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://qualysguard.qg4.apps.qualys.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesQualysCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesQualysCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesQualysCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesQualysCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesQualysCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Rapid7 Insight Cloud as a Vulnerabilities Provider
type VulnerabilitiesRapid7InsightCloud struct {
	Credential *Rapid7InsightCloudCredential `json:"credential" url:"credential"`
	// URL for the Rapid7 API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://us2.api.insight.rapid7.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesRapid7InsightCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesRapid7InsightCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesRapid7InsightCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesRapid7InsightCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesRapid7InsightCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Tanium Cloud as a Vulnerabilities Provider
type VulnerabilitiesTaniumCloud struct {
	Credential *TaniumCloudCredential `json:"credential" url:"credential"`
	// URL for the Tanium Cloud API. This should be the base URL for the API, without any path components and must be HTTPS, e.g. "https://<customername>-api.cloud.tanium.com" or "https://<customername>-api.titankube.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesTaniumCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesTaniumCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesTaniumCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesTaniumCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesTaniumCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Tenable Cloud as a Vulnerabilities Provider
type VulnerabilitiesTenableCloud struct {
	Credential *TenableCloudCredential `json:"credential" url:"credential"`
	// URL for the Tenable Cloud API. This should be the base URL for the API, without any path components and must be HTTPS. If not provided, defaults to "https://cloud.tenable.com".
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesTenableCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesTenableCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesTenableCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesTenableCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *VulnerabilitiesTenableCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type AdhocRole struct {
	Resources     *Resources  `json:"resources" url:"resources"`
	PermissionSet Permissions `json:"permission_set" url:"permission_set"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdhocRole) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdhocRole) UnmarshalJSON(data []byte) error {
	type unmarshaler AdhocRole
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdhocRole(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AdhocRole) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Resources struct {
	Organizations *RoleOrganizations `json:"organizations,omitempty" url:"organizations,omitempty"`
	Accounts      *RoleAccounts      `json:"accounts,omitempty" url:"accounts,omitempty"`
	Integrations  *RoleIntegrations  `json:"integrations,omitempty" url:"integrations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Resources) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Resources) UnmarshalJSON(data []byte) error {
	type unmarshaler Resources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resources(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Resources) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleAccounts struct {
	// List of account ids that this role definition grants access to. Use "\*" to grant access to all account ids.
	Ids []AccountId `json:"ids" url:"ids"`
	// List of account labels this role definition grants access to. If both labels and environments are specified both must pass
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// Account environments this role definition grants access to. If both labels and environments are specified both must pass
	Environments []Environment `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleAccounts) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleAccounts) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleAccounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleAccounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RoleAccounts) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleIntegrations struct {
	// List of categories ids that this role definition grants access to. Use "\*" to grant access to all category ids.
	Categories []CategoryId `json:"categories" url:"categories"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleIntegrations) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleIntegrations) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleIntegrations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleIntegrations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RoleIntegrations) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Unique identifier for this Role
type RoleName = string

type RoleOrganizations struct {
	// List of organization ids that this role definition grants access to. Use "\*" to grant access to all organization ids.
	Ids []OrganizationId `json:"ids" url:"ids"`
	// List of organization labels this role definition grants access to.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleOrganizations) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleOrganizations) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleOrganizations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleOrganizations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RoleOrganizations) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type BuiltinRoles string

const (
	BuiltinRolesRootAdministrator BuiltinRoles = "root_administrator"
	BuiltinRolesAdministrator     BuiltinRoles = "administrator"
	BuiltinRolesViewer            BuiltinRoles = "viewer"
	BuiltinRolesMember            BuiltinRoles = "member"
)

func NewBuiltinRolesFromString(s string) (BuiltinRoles, error) {
	switch s {
	case "root_administrator":
		return BuiltinRolesRootAdministrator, nil
	case "administrator":
		return BuiltinRolesAdministrator, nil
	case "viewer":
		return BuiltinRolesViewer, nil
	case "member":
		return BuiltinRolesMember, nil
	}
	var t BuiltinRoles
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BuiltinRoles) Ptr() *BuiltinRoles {
	return &b
}

type RoleDefinition struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        RoleId    `json:"id" url:"id"`
	// Full name of role
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the resources included in the role and permissions granted on those resources. Includes details of when to use this role along with the intended personas.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Selects the resources the permission set applies to.
	Resources *Resources `json:"resources,omitempty" url:"resources,omitempty"`
	// Permission set for this role.
	PermissionSet Permissions `json:"permission_set" url:"permission_set"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleDefinition) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleDefinition) UnmarshalJSON(data []byte) error {
	type embed RoleDefinition
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RoleDefinition(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RoleDefinition) MarshalJSON() ([]byte, error) {
	type embed RoleDefinition
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (r *RoleDefinition) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type GetIntegrationTimeseriesResult = *GetStatusTimeseriesResult

// Status timeseries object
type GetStatusTimeseriesResult struct {
	// start time
	StartTime time.Time `json:"start_time" url:"start_time"`
	// end time
	EndTime time.Time `json:"end_time" url:"end_time"`
	// interval duration
	Interval string              `json:"interval" url:"interval"`
	Series   []*TimeseriesResult `json:"series" url:"series"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetStatusTimeseriesResult) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetStatusTimeseriesResult) UnmarshalJSON(data []byte) error {
	type embed GetStatusTimeseriesResult
	var unmarshaler = struct {
		embed
		StartTime *core.DateTime `json:"start_time"`
		EndTime   *core.DateTime `json:"end_time"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GetStatusTimeseriesResult(unmarshaler.embed)
	g.StartTime = unmarshaler.StartTime.Time()
	g.EndTime = unmarshaler.EndTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetStatusTimeseriesResult) MarshalJSON() ([]byte, error) {
	type embed GetStatusTimeseriesResult
	var marshaler = struct {
		embed
		StartTime *core.DateTime `json:"start_time"`
		EndTime   *core.DateTime `json:"end_time"`
	}{
		embed:     embed(*g),
		StartTime: core.NewDateTime(g.StartTime),
		EndTime:   core.NewDateTime(g.EndTime),
	}
	return json.Marshal(marshaler)
}

func (g *GetStatusTimeseriesResult) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Status object
type Status struct {
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// Account associated with this status. Use the expand=accounts parameter with the List API to expand the Account to the full object
	AccountId AccountId `json:"account_id" url:"account_id"`
	// When using the expand option on the List API, the full account object is included in the response
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// Integration associated with this status. Use the expand=integrations parameter with the List API to expand the Account to the full object
	IntegrationId IntegrationId `json:"integration_id" url:"integration_id"`
	// When using the expand option on the List API, the full integration object is included in the response
	Integration *Integration `json:"integration,omitempty" url:"integration,omitempty"`
	// The current status of the notification.
	Status string `json:"status" url:"status"`
	// Request count
	Requests int64 `json:"requests" url:"requests"`
	// Failed count
	Failed int64 `json:"failed" url:"failed"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time" url:"cpu_time"`
	// Database operations count
	DbOps int64 `json:"db_ops" url:"db_ops"`
	// API operations count
	ApiOps int64 `json:"api_ops" url:"api_ops"`
	// API input byte count
	InBytes int64 `json:"in_bytes" url:"in_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Status) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Status) UnmarshalJSON(data []byte) error {
	type embed Status
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Status(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Status) MarshalJSON() ([]byte, error) {
	type embed Status
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
		UpdatedAt: core.NewDateTime(s.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Status) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Status event object
type StatusEvent struct {
	// Account owner
	AccountId AccountId `json:"account_id" url:"account_id"`
	// Integration object
	IntegrationId IntegrationId `json:"integration_id" url:"integration_id"`
	// Time created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Error message
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Request number
	Request int64 `json:"request" url:"request"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StatusEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StatusEvent) UnmarshalJSON(data []byte) error {
	type embed StatusEvent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = StatusEvent(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StatusEvent) MarshalJSON() ([]byte, error) {
	type embed StatusEvent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *StatusEvent) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TimeseriesOptions string

const (
	TimeseriesOptionsHour TimeseriesOptions = "hour"
)

func NewTimeseriesOptionsFromString(s string) (TimeseriesOptions, error) {
	switch s {
	case "hour":
		return TimeseriesOptionsHour, nil
	}
	var t TimeseriesOptions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeseriesOptions) Ptr() *TimeseriesOptions {
	return &t
}

// Status timeseries object
type TimeseriesResult struct {
	// Interval time
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Succeeded count
	Succeeded int64 `json:"succeeded" url:"succeeded"`
	// Failed count
	Failed int64 `json:"failed" url:"failed"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time" url:"cpu_time"`
	// API input byte count
	InBytes int64 `json:"in_bytes" url:"in_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeseriesResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeseriesResult) UnmarshalJSON(data []byte) error {
	type embed TimeseriesResult
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeseriesResult(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TimeseriesResult) MarshalJSON() ([]byte, error) {
	type embed TimeseriesResult
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TimeseriesResult) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Token struct {
	// Secret value for the token; used for authentication when making requests.
	Secret string `json:"secret" url:"secret"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires" url:"expires"`
	// Permissions granted to this token.
	Permissions *Permission `json:"permissions" url:"permissions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Token) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Token) UnmarshalJSON(data []byte) error {
	type embed Token
	var unmarshaler = struct {
		embed
		Expires *core.DateTime `json:"expires"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Token(unmarshaler.embed)
	t.Expires = unmarshaler.Expires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Token) MarshalJSON() ([]byte, error) {
	type embed Token
	var marshaler = struct {
		embed
		Expires *core.DateTime `json:"expires"`
	}{
		embed:   embed(*t),
		Expires: core.NewDateTime(t.Expires),
	}
	return json.Marshal(marshaler)
}

func (t *Token) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenOwnerType string

const (
	TokenOwnerTypeOrganization TokenOwnerType = "organization"
	TokenOwnerTypeIntegration  TokenOwnerType = "integration"
)

func NewTokenOwnerTypeFromString(s string) (TokenOwnerType, error) {
	switch s {
	case "organization":
		return TokenOwnerTypeOrganization, nil
	case "integration":
		return TokenOwnerTypeIntegration, nil
	}
	var t TokenOwnerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenOwnerType) Ptr() *TokenOwnerType {
	return &t
}

type TokenPair struct {
	// Access token contains the bearer secret
	Access *Token `json:"access" url:"access"`
	// Refresh token used for RefreshToken API
	Refresh *Token `json:"refresh" url:"refresh"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenPair) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenPair) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenPair
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenPair(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TokenPair) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type RefreshToken struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        TokenId   `json:"id" url:"id"`
	// Member Id
	MemberId *Id `json:"member_id,omitempty" url:"member_id,omitempty"`
	// ID of the entity that owns this token
	OwnerId Id `json:"owner_id" url:"owner_id"`
	// Type of the entity that owns this token
	OwnerType TokenOwnerType `json:"owner_type" url:"owner_type"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires" url:"expires"`
	// Token time-to-live
	TokenTtl string `json:"token_ttl" url:"token_ttl"`
	// Primary running access and refresh tokens
	Primary *TokenPair `json:"primary" url:"primary"`
	// Temporary secondary TokenPair created after a RefreshToken operation
	Secondary *TokenPair `json:"secondary,omitempty" url:"secondary,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefreshToken) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefreshToken) UnmarshalJSON(data []byte) error {
	type embed RefreshToken
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RefreshToken(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	r.Expires = unmarshaler.Expires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RefreshToken) MarshalJSON() ([]byte, error) {
	type embed RefreshToken
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
		Expires:   core.NewDateTime(r.Expires),
	}
	return json.Marshal(marshaler)
}

func (r *RefreshToken) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Transforms data collected before it is sent to the target Integration.
type Transform struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time   `json:"updated_at" url:"updated_at"`
	Id        TransformId `json:"id" url:"id"`
	// Account that manages this Transform.
	AccountId AccountId `json:"account_id" url:"account_id"`
	// Human friendly display name for this Transform.
	Fullname string `json:"fullname" url:"fullname"`
	// JSON Patch transform to apply (rfc6902).
	Patch []byte `json:"patch" url:"patch"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Transform) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Transform) UnmarshalJSON(data []byte) error {
	type embed Transform
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Transform(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Transform) MarshalJSON() ([]byte, error) {
	type embed Transform
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *Transform) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Usage struct {
	IntegrationId     Id      `json:"integration_id" url:"integration_id"`
	RequestsCount     float64 `json:"requests_count" url:"requests_count"`
	CpuTimeSeconds    float64 `json:"cpu_time_seconds" url:"cpu_time_seconds"`
	DbOperationsCount float64 `json:"db_operations_count" url:"db_operations_count"`
	IntOpsCount       float64 `json:"int_ops_count" url:"int_ops_count"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *Usage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Usage) UnmarshalJSON(data []byte) error {
	type unmarshaler Usage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Usage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = nil
	return nil
}

func (u *Usage) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
