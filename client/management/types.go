// This file was auto-generated by Fern from our API Definition.

package management

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/synqly/go-sdk/client/management/core"
	time "time"
)

type Account struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        AccountId `json:"id" url:"id"`
	// Human friendly display name for this account.
	Fullname string `json:"fullname" url:"fullname"`
	// Organization that manages this Account.
	OrganizationId OrganizationId `json:"organization_id" url:"organization_id"`
	// Environment this account runs in.
	Environment Environment `json:"environment" url:"environment"`
	// User defined labels that apply to this account. These values can be used in role bindings to limit the scope of permissions.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type embed Account
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Account(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()
	a.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Account) MarshalJSON() ([]byte, error) {
	type embed Account
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
		UpdatedAt: core.NewDateTime(a.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Account) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Unique identifier for this Account
type AccountId = Id

type CreateAccountResponseResult struct {
	Account *Account `json:"account" url:"account"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAccountResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAccountResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAccountResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAccountResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateAccountResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Audit struct {
	Environment string `json:"environment" url:"environment"`
	// Time when the API request occurred.
	CreatedAt     time.Time      `json:"created_at" url:"created_at"`
	RemoteAddr    string         `json:"remote_addr" url:"remote_addr"`
	UserAgent     string         `json:"user_agent" url:"user_agent"`
	Method        HttpMethod     `json:"method" url:"method"`
	Path          string         `json:"path" url:"path"`
	Code          string         `json:"code" url:"code"`
	Body          interface{}    `json:"body,omitempty" url:"body,omitempty"`
	Response      *string        `json:"response,omitempty" url:"response,omitempty"`
	Status        *string        `json:"status,omitempty" url:"status,omitempty"`
	MemberId      *MemberId      `json:"member_id,omitempty" url:"member_id,omitempty"`
	AccountId     *AccountId     `json:"account_id,omitempty" url:"account_id,omitempty"`
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Audit) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Audit) UnmarshalJSON(data []byte) error {
	type embed Audit
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Audit(unmarshaler.embed)
	a.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Audit) MarshalJSON() ([]byte, error) {
	type embed Audit
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*a),
		CreatedAt: core.NewDateTime(a.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (a *Audit) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type HttpMethod string

const (
	HttpMethodGet    HttpMethod = "GET"
	HttpMethodPatch  HttpMethod = "PATCH"
	HttpMethodPost   HttpMethod = "POST"
	HttpMethodPut    HttpMethod = "PUT"
	HttpMethodDelete HttpMethod = "DELETE"
)

func NewHttpMethodFromString(s string) (HttpMethod, error) {
	switch s {
	case "GET":
		return HttpMethodGet, nil
	case "PATCH":
		return HttpMethodPatch, nil
	case "POST":
		return HttpMethodPost, nil
	case "PUT":
		return HttpMethodPut, nil
	case "DELETE":
		return HttpMethodDelete, nil
	}
	var t HttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HttpMethod) Ptr() *HttpMethod {
	return &h
}

type AuthCode string

const (
	AuthCodeSuccess  AuthCode = "success"
	AuthCodeFailure  AuthCode = "failure"
	AuthCodeDisabled AuthCode = "disabled"
	AuthCodeExpired  AuthCode = "expired"
	AuthCodeInvited  AuthCode = "invited"
	AuthCodeLocked   AuthCode = "locked"
)

func NewAuthCodeFromString(s string) (AuthCode, error) {
	switch s {
	case "success":
		return AuthCodeSuccess, nil
	case "failure":
		return AuthCodeFailure, nil
	case "disabled":
		return AuthCodeDisabled, nil
	case "expired":
		return AuthCodeExpired, nil
	case "invited":
		return AuthCodeInvited, nil
	case "locked":
		return AuthCodeLocked, nil
	}
	var t AuthCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthCode) Ptr() *AuthCode {
	return &a
}

type ChangePasswordResponseResult struct {
	// Authentication result
	AuthCode AuthCode `json:"auth_code" url:"auth_code"`
	// Authentication failure message
	AuthMsg *string `json:"auth_msg,omitempty" url:"auth_msg,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChangePasswordResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChangePasswordResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ChangePasswordResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChangePasswordResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChangePasswordResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type LogonResponseResult struct {
	// Authentication result
	AuthCode AuthCode `json:"auth_code" url:"auth_code"`
	// Authentication failure message
	AuthMsg        *string       `json:"auth_msg,omitempty" url:"auth_msg,omitempty"`
	RefreshTokenId TokenId       `json:"refresh_token_id" url:"refresh_token_id"`
	Token          *TokenPair    `json:"token" url:"token"`
	Organization   *Organization `json:"organization" url:"organization"`
	Member         *Member       `json:"member" url:"member"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LogonResponseResult) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogonResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler LogonResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogonResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogonResponseResult) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A Bridge Group represents a connection between the Synqly Saas or Embedded service and a Bridge Agent. See 'Synqly Bridge Agent' guide in Synqly docs for additional information.
type BridgeGroup struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time     `json:"updated_at" url:"updated_at"`
	Id        BridgeGroupId `json:"id" url:"id"`
	// Full name of bridge
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the resources included in the bridge and permissions granted on those resources. Includes details of when to use this bridge along with the intended personas.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Labels applied to Bridges within the group. These labels can be used by integrations to select the groups of bridges capable of handling requests to the integration.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgeGroup) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgeGroup) UnmarshalJSON(data []byte) error {
	type embed BridgeGroup
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BridgeGroup(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BridgeGroup) MarshalJSON() ([]byte, error) {
	type embed BridgeGroup
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BridgeGroup) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CreateBridgeResponseResult struct {
	Bridge *BridgeGroup `json:"bridge" url:"bridge"`
	// JWT for the Bridge Group to connect to Synqly. This must be saved in a file {bridgeId}.creds in the same directory as the bridge executable.
	Credential string `json:"credential" url:"credential"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateBridgeResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBridgeResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBridgeResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBridgeResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBridgeResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CapabilitiesProviderConfig = map[string]interface{}

// Provides details on an available Integration.
type Category struct {
	Category CategoryId `json:"category" url:"category"`
	// Description of what this Integration does.
	Description string `json:"description" url:"description"`
	// List of Providers that implement this Integration.
	Providers []ProviderId `json:"providers" url:"providers"`
	// URL of the icon representing this type of Integration.
	Picture *string `json:"picture,omitempty" url:"picture,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Category) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Category) UnmarshalJSON(data []byte) error {
	type unmarshaler Category
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Category(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Category) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Provider struct {
	// Name of the Provider.
	Name string `json:"name" url:"name"`
	// Description of what this Provider does.
	Description string `json:"description" url:"description"`
	// Categories that this Provider implements.
	Categories []CategoryId `json:"categories" url:"categories"`
	// URL of the icon representing this type of Provider.
	Picture *string `json:"picture,omitempty" url:"picture,omitempty"`
	// Operations that this Provider implements.
	SupportedOperations interface{} `json:"supported_operations" url:"supported_operations"`
	// List of credential types that this Provider supports.
	Credentials []ProviderCredentialConfig `json:"credentials" url:"credentials"`
	// Details on the specific configuration options for this Provider.
	ProviderConfig map[string]CapabilitiesProviderConfig `json:"provider_config" url:"provider_config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Provider) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Provider) UnmarshalJSON(data []byte) error {
	type unmarshaler Provider
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Provider(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Provider) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderCredentialConfig = map[string]interface{}

// Id of the Integrations category
type CategoryId string

const (
	CategoryIdAssets          CategoryId = "assets"
	CategoryIdEdr             CategoryId = "edr"
	CategoryIdHooks           CategoryId = "hooks"
	CategoryIdIdentity        CategoryId = "identity"
	CategoryIdNotifications   CategoryId = "notifications"
	CategoryIdSiem            CategoryId = "siem"
	CategoryIdSink            CategoryId = "sink"
	CategoryIdStorage         CategoryId = "storage"
	CategoryIdTicketing       CategoryId = "ticketing"
	CategoryIdVulnerabilities CategoryId = "vulnerabilities"
)

func NewCategoryIdFromString(s string) (CategoryId, error) {
	switch s {
	case "assets":
		return CategoryIdAssets, nil
	case "edr":
		return CategoryIdEdr, nil
	case "hooks":
		return CategoryIdHooks, nil
	case "identity":
		return CategoryIdIdentity, nil
	case "notifications":
		return CategoryIdNotifications, nil
	case "siem":
		return CategoryIdSiem, nil
	case "sink":
		return CategoryIdSink, nil
	case "storage":
		return CategoryIdStorage, nil
	case "ticketing":
		return CategoryIdTicketing, nil
	case "vulnerabilities":
		return CategoryIdVulnerabilities, nil
	}
	var t CategoryId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CategoryId) Ptr() *CategoryId {
	return &c
}

type ProviderId = string

type Base struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Base) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Base) UnmarshalJSON(data []byte) error {
	type embed Base
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Base(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Base) MarshalJSON() ([]byte, error) {
	type embed Base
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *Base) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ErrorBody struct {
	Status     int           `json:"status" url:"status"`
	Message    *string       `json:"message,omitempty" url:"message,omitempty"`
	Errors     []string      `json:"errors,omitempty" url:"errors,omitempty"`
	Parameters []*ErrorParam `json:"parameters,omitempty" url:"parameters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ErrorBody) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorBody) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorParam struct {
	Name  string `json:"name" url:"name"`
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ErrorParam) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorParam) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorParam
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorParam(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorParam) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Id = string

// AWS access key to authenticate with AWS. Access keys are long-term credentials for an IAM user and consist of an ID and secret. Follow [this guide to generate access and secret keys](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys). You may optionally provide a session token if you are using temporary credentials.
type AwsCredential struct {
	// ID portion of the AWS access key pair.
	AccessKeyId string `json:"access_key_id" url:"access_key_id"`
	// Secret portion of the AWS access key pair.
	SecretAccessKey string `json:"secret_access_key" url:"secret_access_key"`
	// A temporary session token. Session tokens are optional and are only necessary if you are using temporary credentials.
	Session *string `json:"session,omitempty" url:"session,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AwsCredential) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AwsCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler AwsCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AwsCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AwsCredential) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Unique identifier for an AWS Credential
type AwsCredentialId = CredentialId

// Username and secret used to authenticate with an external service.
type BasicCredential struct {
	// Username value for authentication
	Username string `json:"username" url:"username"`
	// Secret value for authentication
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BasicCredential) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasicCredential) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Unique identifier for a basic auth Credential
type BasicCredentialId = CredentialId

// Credential to access an integration. Each credential is owned by an Account, Integration, IntegrationPoint or OrganizationWebhook.
type Credential struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at" url:"updated_at"`
	Id        CredentialId `json:"id" url:"id"`
	// Account that manages this credential.
	AccountId *AccountId `json:"account_id,omitempty" url:"account_id,omitempty"`
	// Integration associated with this credential.
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`
	// Integration Point associated with this credential.
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// Integration Point associated with this credential.
	OrganizationWebhookId *WebhookId `json:"organization_webhook_id,omitempty" url:"organization_webhook_id,omitempty"`
	// One of `account` or `integration_point`.
	OwnerType OwnerType `json:"owner_type" url:"owner_type"`
	// Human friendly display name for this Credential
	Fullname string `json:"fullname" url:"fullname"`
	// Credential configuration
	Config *CredentialConfig `json:"config,omitempty" url:"config,omitempty"`
	// Time when this credential expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`
	// Field is set by the management process. Determines lifecycle and ownership of the credential.
	Managed ManagedType `json:"managed" url:"managed"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Credential) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Credential) UnmarshalJSON(data []byte) error {
	type embed Credential
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Credential(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Credential) MarshalJSON() ([]byte, error) {
	type embed Credential
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Expires:   core.NewOptionalDateTime(c.Expires),
	}
	return json.Marshal(marshaler)
}

func (c *Credential) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialConfig struct {
	Type        string
	Aws         *AwsCredential
	Token       *TokenCredential
	Basic       *BasicCredential
	Secret      *SecretCredential
	OAuthClient *OAuthClientCredential
}

func (c *CredentialConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Aws = value
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Token = value
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Basic = value
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Secret = value
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.OAuthClient = value
	}
	return nil
}

func (c CredentialConfig) MarshalJSON() ([]byte, error) {
	if c.Aws != nil {
		return core.MarshalJSONWithExtraProperty(c.Aws, "type", "aws")
	}
	if c.Token != nil {
		return core.MarshalJSONWithExtraProperty(c.Token, "type", "token")
	}
	if c.Basic != nil {
		return core.MarshalJSONWithExtraProperty(c.Basic, "type", "basic")
	}
	if c.Secret != nil {
		return core.MarshalJSONWithExtraProperty(c.Secret, "type", "secret")
	}
	if c.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(c.OAuthClient, "type", "o_auth_client")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CredentialConfigVisitor interface {
	VisitAws(*AwsCredential) error
	VisitToken(*TokenCredential) error
	VisitBasic(*BasicCredential) error
	VisitSecret(*SecretCredential) error
	VisitOAuthClient(*OAuthClientCredential) error
}

func (c *CredentialConfig) Accept(visitor CredentialConfigVisitor) error {
	if c.Aws != nil {
		return visitor.VisitAws(c.Aws)
	}
	if c.Token != nil {
		return visitor.VisitToken(c.Token)
	}
	if c.Basic != nil {
		return visitor.VisitBasic(c.Basic)
	}
	if c.Secret != nil {
		return visitor.VisitSecret(c.Secret)
	}
	if c.OAuthClient != nil {
		return visitor.VisitOAuthClient(c.OAuthClient)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CredentialConfigNoSecret struct {
	Type string `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialConfigNoSecret) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialConfigNoSecret) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialConfigNoSecret
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialConfigNoSecret(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialConfigNoSecret) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response object for a Credential
type CredentialResponse struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time    `json:"updated_at" url:"updated_at"`
	Id        CredentialId `json:"id" url:"id"`
	// Account that manages this credential.
	AccountId *AccountId `json:"account_id,omitempty" url:"account_id,omitempty"`
	// Integration associated with this credential.
	IntegrationId *IntegrationId `json:"integration_id,omitempty" url:"integration_id,omitempty"`
	// Integration Point associated with this credential.
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// Integration Point associated with this credential.
	OrganizationWebhookId *WebhookId `json:"organization_webhook_id,omitempty" url:"organization_webhook_id,omitempty"`
	// One of `account` or `integration_point`.
	OwnerType OwnerType `json:"owner_type" url:"owner_type"`
	// Human friendly display name for this Credential. Defaults to the same value as the 'name' field if not specified.
	Fullname string                    `json:"fullname" url:"fullname"`
	Config   *CredentialConfigNoSecret `json:"config" url:"config"`
	// Time when this credential expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`
	// Field is set by the management process. Determines lifecycle and ownership of the credential.
	Managed ManagedType `json:"managed" url:"managed"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialResponse) UnmarshalJSON(data []byte) error {
	type embed CredentialResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CredentialResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	c.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialResponse) MarshalJSON() ([]byte, error) {
	type embed CredentialResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
		Expires:   core.NewOptionalDateTime(c.Expires),
	}
	return json.Marshal(marshaler)
}

func (c *CredentialResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialType string

const (
	CredentialTypeAws         CredentialType = "aws"
	CredentialTypeToken       CredentialType = "token"
	CredentialTypeBasic       CredentialType = "basic"
	CredentialTypeSecret      CredentialType = "secret"
	CredentialTypeOAuthClient CredentialType = "o_auth_client"
)

func NewCredentialTypeFromString(s string) (CredentialType, error) {
	switch s {
	case "aws":
		return CredentialTypeAws, nil
	case "token":
		return CredentialTypeToken, nil
	case "basic":
		return CredentialTypeBasic, nil
	case "secret":
		return CredentialTypeSecret, nil
	case "o_auth_client":
		return CredentialTypeOAuthClient, nil
	}
	var t CredentialType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialType) Ptr() *CredentialType {
	return &c
}

type ManagedType string

const (
	ManagedTypeManaged   ManagedType = "Managed"
	ManagedTypeUnmanaged ManagedType = "Unmanaged"
)

func NewManagedTypeFromString(s string) (ManagedType, error) {
	switch s {
	case "Managed":
		return ManagedTypeManaged, nil
	case "Unmanaged":
		return ManagedTypeUnmanaged, nil
	}
	var t ManagedType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ManagedType) Ptr() *ManagedType {
	return &m
}

// A Client ID and secret used for authenticating with OAuth 2.0 compatible service using the client credentials grant.
type OAuthClientCredential struct {
	// Optional URL for the OAuth 2.0 token exchange if it can not be constructed based on provider configuration
	TokenUrl *string `json:"token_url,omitempty" url:"token_url,omitempty"`
	// The ID of the client application defined at the service provider
	ClientId string `json:"client_id" url:"client_id"`
	// Secret value for authentication
	ClientSecret string `json:"client_secret" url:"client_secret"`
	// Optional connection specific meta data such as a signing key ID or organization ID
	Extra map[string]interface{} `json:"extra,omitempty" url:"extra,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OAuthClientCredential) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthClientCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthClientCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthClientCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuthClientCredential) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Unique identifier for an OAuth client Credential
type OAuthClientCredentialId = CredentialId

type OwnerType string

const (
	OwnerTypeAccount             OwnerType = "account"
	OwnerTypeIntegration         OwnerType = "integration"
	OwnerTypeIntegrationPoint    OwnerType = "integration_point"
	OwnerTypeOrganizationWebhook OwnerType = "organization_webhook"
)

func NewOwnerTypeFromString(s string) (OwnerType, error) {
	switch s {
	case "account":
		return OwnerTypeAccount, nil
	case "integration":
		return OwnerTypeIntegration, nil
	case "integration_point":
		return OwnerTypeIntegrationPoint, nil
	case "organization_webhook":
		return OwnerTypeOrganizationWebhook, nil
	}
	var t OwnerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OwnerType) Ptr() *OwnerType {
	return &o
}

// Secret value such as password or webhook url
type SecretCredential struct {
	// Secret value
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SecretCredential) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecretCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler SecretCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecretCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecretCredential) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Unique identifier for a secret Credential
type SecretCredentialId = CredentialId

// Token used to authenticate with an external service.
type TokenCredential struct {
	// Secret value of the token.
	Secret string `json:"secret" url:"secret"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenCredential) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenCredential) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Unique identifier for a token Credential
type TokenCredentialId = CredentialId

// Unique identifier for this Integration
type IntegrationId = Id

type IntegrationEnvironments struct {
	// List of allowed providers for test environment.
	Test []ProviderConfigId `json:"test,omitempty" url:"test,omitempty"`
	// List of allowed providers for production environment.
	Prod []ProviderConfigId `json:"prod,omitempty" url:"prod,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationEnvironments) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationEnvironments) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationEnvironments
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationEnvironments(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationEnvironments) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Enables creation, editing and deletion of Integrations.
type IntegrationPoint struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time          `json:"updated_at" url:"updated_at"`
	Id        IntegrationPointId `json:"id" url:"id"`
	// Name of integration point, will be shown to end-users in the Connect UI.
	Fullname *string `json:"fullname,omitempty" url:"fullname,omitempty"`
	// Optional description of the Integration Point. Will not be displayed to end-users of Connect UI.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Connector to use for the Integration Point.
	Connector CategoryId `json:"connector" url:"connector"`
	// Selects providers to use for account environments.
	Environments *IntegrationEnvironments `json:"environments" url:"environments"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationPoint) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationPoint) UnmarshalJSON(data []byte) error {
	type embed IntegrationPoint
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = IntegrationPoint(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationPoint) MarshalJSON() ([]byte, error) {
	type embed IntegrationPoint
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*i),
		CreatedAt: core.NewDateTime(i.CreatedAt),
		UpdatedAt: core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *IntegrationPoint) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type BridgeSelector struct {
	Type string
	// ID of a specific bridge group to use
	Id string
	// Labels the bridge group must have. If multiple labels are provided, the first bridge group that has any one of the labels will be selected.
	Labels []string
}

func (b *BridgeSelector) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "id":
		var valueUnmarshaler struct {
			Id string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		b.Id = valueUnmarshaler.Id
	case "labels":
		var valueUnmarshaler struct {
			Labels []string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		b.Labels = valueUnmarshaler.Labels
	}
	return nil
}

func (b BridgeSelector) MarshalJSON() ([]byte, error) {
	if b.Id != "" {
		var marshaler = struct {
			Type string `json:"type"`
			Id   string `json:"value"`
		}{
			Type: "id",
			Id:   b.Id,
		}
		return json.Marshal(marshaler)
	}
	if b.Labels != nil {
		var marshaler = struct {
			Type   string   `json:"type"`
			Labels []string `json:"value"`
		}{
			Type:   "labels",
			Labels: b.Labels,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BridgeSelectorVisitor interface {
	VisitId(string) error
	VisitLabels([]string) error
}

func (b *BridgeSelector) Accept(visitor BridgeSelectorVisitor) error {
	if b.Id != "" {
		return visitor.VisitId(b.Id)
	}
	if b.Labels != nil {
		return visitor.VisitLabels(b.Labels)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

type CreateIntegrationResponseResult struct {
	CredentialsCreated []*CredentialResponse `json:"credentials_created,omitempty" url:"credentials_created,omitempty"`
	Integration        *Integration          `json:"integration" url:"integration"`
	Token              *TokenPair            `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateIntegrationResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateIntegrationResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateIntegrationResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateIntegrationResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateIntegrationResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Connects an Account to an external service
type Integration struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time     `json:"updated_at" url:"updated_at"`
	Id        IntegrationId `json:"id" url:"id"`
	// Human friendly display name for this integration.
	Fullname string `json:"fullname" url:"fullname"`
	// Integration refresh token id
	RefreshTokenId TokenId `json:"refresh_token_id" url:"refresh_token_id"`
	// Account associated with this integration. Use the expand=accounts parameter with the List and ListAccount APIs to expand the Account to the full object
	AccountId AccountId `json:"account_id" url:"account_id"`
	// When using the expand option on the List or ListAccount APIs, the full account object is included in the response
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// Id of the Connector Category for this Integration.
	Category CategoryId `json:"category" url:"category"`
	// Provider configuration for this Integration.
	ProviderConfig *ProviderConfig `json:"provider_config" url:"provider_config"`
	// Human friendly display name for the provider.
	ProviderFullname string `json:"provider_fullname" url:"provider_fullname"`
	// Type of the provider for this Integration.
	ProviderType string `json:"provider_type" url:"provider_type"`
	// Integration Point associated with this integration. Use the expand=integration_points parameter with the List and ListAccount APIs to expand the Integration Point to the full object
	IntegrationPointId *IntegrationPointId `json:"integration_point_id,omitempty" url:"integration_point_id,omitempty"`
	// When using the expand option on the List or ListAccount APIs, the full integration_point object is included in the response
	IntegrationPoint *IntegrationPoint `json:"integration_point,omitempty" url:"integration_point,omitempty"`
	// Use a Bridge to connect to the provider.
	BridgeSelector *BridgeSelector `json:"bridge_selector,omitempty" url:"bridge_selector,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Integration) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Integration) UnmarshalJSON(data []byte) error {
	type embed Integration
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = Integration(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Integration) MarshalJSON() ([]byte, error) {
	type embed Integration
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*i),
		CreatedAt: core.NewDateTime(i.CreatedAt),
		UpdatedAt: core.NewDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *Integration) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type CreateMemberResponseResult struct {
	Member *Member `json:"member" url:"member"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateMemberResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMemberResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateMemberResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateMemberResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMemberResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Member struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        MemberId  `json:"id" url:"id"`
	State     State     `json:"state" url:"state"`
	// Last logon time
	LastLogon time.Time `json:"last_logon" url:"last_logon"`
	// User's full display name.
	Fullname string `json:"fullname" url:"fullname"`
	// User's nickname
	Nickname string `json:"nickname" url:"nickname"`
	// Url of user's picture
	Picture    string    `json:"picture" url:"picture"`
	Ttl        string    `json:"ttl" url:"ttl"`
	TokenTtl   string    `json:"token_ttl" url:"token_ttl"`
	Expires    time.Time `json:"expires" url:"expires"`
	PinExpires time.Time `json:"pin_expires" url:"pin_expires"`
	// Roles granted to this member. Tokens inherit this access.
	RoleBinding []RoleName `json:"role_binding" url:"role_binding"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Member) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Member) UnmarshalJSON(data []byte) error {
	type embed Member
	var unmarshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"created_at"`
		UpdatedAt  *core.DateTime `json:"updated_at"`
		LastLogon  *core.DateTime `json:"last_logon"`
		Expires    *core.DateTime `json:"expires"`
		PinExpires *core.DateTime `json:"pin_expires"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Member(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	m.UpdatedAt = unmarshaler.UpdatedAt.Time()
	m.LastLogon = unmarshaler.LastLogon.Time()
	m.Expires = unmarshaler.Expires.Time()
	m.PinExpires = unmarshaler.PinExpires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Member) MarshalJSON() ([]byte, error) {
	type embed Member
	var marshaler = struct {
		embed
		CreatedAt  *core.DateTime `json:"created_at"`
		UpdatedAt  *core.DateTime `json:"updated_at"`
		LastLogon  *core.DateTime `json:"last_logon"`
		Expires    *core.DateTime `json:"expires"`
		PinExpires *core.DateTime `json:"pin_expires"`
	}{
		embed:      embed(*m),
		CreatedAt:  core.NewDateTime(m.CreatedAt),
		UpdatedAt:  core.NewDateTime(m.UpdatedAt),
		LastLogon:  core.NewDateTime(m.LastLogon),
		Expires:    core.NewDateTime(m.Expires),
		PinExpires: core.NewDateTime(m.PinExpires),
	}
	return json.Marshal(marshaler)
}

func (m *Member) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MemberOptions struct {
	// Optional member time-to-live duration. After a member expires, system requires a change password to re-enable member. Minimum 1 day, Maximum 1 year, Default 180 days.
	Ttl string `json:"ttl" url:"ttl"`
	// Options: "expired" will force change password on first logon.
	Options []Options `json:"options" url:"options"`
	// Optional token time-to-live duration. Tokens are created for this member with this duration as their TTL. Minimum 10 miniutes, Maximum 1 week, Defaults 1 hour.
	TokenTtl string `json:"token_ttl" url:"token_ttl"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MemberOptions) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MemberOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler MemberOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MemberOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MemberOptions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Options string

const (
	OptionsDisabled  Options = "disabled"
	OptionsExpired   Options = "expired"
	OptionsForgotten Options = "forgotten"
	OptionsInvited   Options = "invited"
	OptionsLocked    Options = "locked"
)

func NewOptionsFromString(s string) (Options, error) {
	switch s {
	case "disabled":
		return OptionsDisabled, nil
	case "expired":
		return OptionsExpired, nil
	case "forgotten":
		return OptionsForgotten, nil
	case "invited":
		return OptionsInvited, nil
	case "locked":
		return OptionsLocked, nil
	}
	var t Options
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o Options) Ptr() *Options {
	return &o
}

type State string

const (
	StateDisabled  State = "disabled"
	StateEnabled   State = "enabled"
	StateForgotten State = "forgotten"
	StateInvited   State = "invited"
	StateLocked    State = "locked"
)

func NewStateFromString(s string) (State, error) {
	switch s {
	case "disabled":
		return StateDisabled, nil
	case "enabled":
		return StateEnabled, nil
	case "forgotten":
		return StateForgotten, nil
	case "invited":
		return StateInvited, nil
	case "locked":
		return StateLocked, nil
	}
	var t State
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s State) Ptr() *State {
	return &s
}

type CreateOrganizationResponseResult struct {
	Member       *Member       `json:"member,omitempty" url:"member,omitempty"`
	Organization *Organization `json:"organization" url:"organization"`
	Token        *TokenPair    `json:"token" url:"token"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrganizationResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrganizationResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrganizationResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrganizationResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrganizationResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Environment string

const (
	EnvironmentTest Environment = "test"
	EnvironmentProd Environment = "prod"
)

func NewEnvironmentFromString(s string) (Environment, error) {
	switch s {
	case "test":
		return EnvironmentTest, nil
	case "prod":
		return EnvironmentProd, nil
	}
	var t Environment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e Environment) Ptr() *Environment {
	return &e
}

type GetOrganizationResponse struct {
	Result *Organization `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetOrganizationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOrganizationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrganizationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrganizationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOrganizationResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Organization struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time      `json:"updated_at" url:"updated_at"`
	Id        OrganizationId `json:"id" url:"id"`
	// Organization refresh token id
	RefreshTokenId TokenId `json:"refresh_token_id" url:"refresh_token_id"`
	// Organization type: root or standard
	OrganizationType OrganizationType `json:"organization_type" url:"organization_type"`
	// Human friendly display name for this Organization
	Fullname string `json:"fullname" url:"fullname"`
	// Organization email address
	Contact string `json:"contact" url:"contact"`
	// Reply-to email address, used for SMTP emails. Defaults to no-reply@synqly.com
	ReplyTo string `json:"reply_to" url:"reply_to"`
	// Picture URL of the organization
	Picture string `json:"picture" url:"picture"`
	// Organization options
	Options *OrganizationOptions `json:"options,omitempty" url:"options,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Organization) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Organization) UnmarshalJSON(data []byte) error {
	type embed Organization
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Organization(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Organization) MarshalJSON() ([]byte, error) {
	type embed Organization
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *Organization) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationOptions struct {
	// Duration new member invitations will be valid. Default: 168h (7 days), minimum 24h, maximum 168h (7 days).
	InviteDuration *string `json:"invite_duration,omitempty" url:"invite_duration,omitempty"`
	// Duration forgotten password invitations will be valid. Default: 24h, minimum 24h, maximum 168h (7 days).
	ForgotDuration *string `json:"forgot_duration,omitempty" url:"forgot_duration,omitempty"`
	// Duration before member password expires, part of required password rotation. Default: 4320h (180 days), minimum: 24h, maximum: 8760h (365 days).
	PasswordDuration *string `json:"password_duration,omitempty" url:"password_duration,omitempty"`
	// Minimum password length. Default: 8, minimum 8, maximum 72.
	MinimumPasswordLength *int `json:"minimum_password_length,omitempty" url:"minimum_password_length,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationOptions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationOptions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationType string

const (
	OrganizationTypeRoot     OrganizationType = "root"
	OrganizationTypeStandard OrganizationType = "standard"
)

func NewOrganizationTypeFromString(s string) (OrganizationType, error) {
	switch s {
	case "root":
		return OrganizationTypeRoot, nil
	case "standard":
		return OrganizationTypeStandard, nil
	}
	var t OrganizationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrganizationType) Ptr() *OrganizationType {
	return &o
}

type WebhookFilter string

const (
	WebhookFilterAll               WebhookFilter = "all"
	WebhookFilterAccountCreate     WebhookFilter = "account_create"
	WebhookFilterAccountDelete     WebhookFilter = "account_delete"
	WebhookFilterAccountUpdate     WebhookFilter = "account_update"
	WebhookFilterIntegrationCreate WebhookFilter = "integration_create"
	WebhookFilterIntegrationDelete WebhookFilter = "integration_delete"
	WebhookFilterIntegrationUpdate WebhookFilter = "integration_update"
)

func NewWebhookFilterFromString(s string) (WebhookFilter, error) {
	switch s {
	case "all":
		return WebhookFilterAll, nil
	case "account_create":
		return WebhookFilterAccountCreate, nil
	case "account_delete":
		return WebhookFilterAccountDelete, nil
	case "account_update":
		return WebhookFilterAccountUpdate, nil
	case "integration_create":
		return WebhookFilterIntegrationCreate, nil
	case "integration_delete":
		return WebhookFilterIntegrationDelete, nil
	case "integration_update":
		return WebhookFilterIntegrationUpdate, nil
	}
	var t WebhookFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookFilter) Ptr() *WebhookFilter {
	return &w
}

// Response payload for webhook events. This payload is sent to the webhook URL when an event occurs.
type OrganizationWebhookPayload struct {
	// The event that triggered the webhook
	Event WebhookFilter `json:"event" url:"event"`
	// The account that the event occurred in
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// The integration that the event occurred in
	Integration *Integration `json:"integration,omitempty" url:"integration,omitempty"`
	// A unique identifier for this webhook event
	Nonce string `json:"nonce" url:"nonce"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhookPayload) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhookPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationWebhookPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationWebhookPayload(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationWebhookPayload) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationWebhook struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        WebhookId `json:"id" url:"id"`
	// Human friendly slug for this webhook
	Fullname string `json:"fullname" url:"fullname"`
	// Environment that the webhook is configured for. Only events associated with this environment will trigger the webhook.
	Environment Environment `json:"environment" url:"environment"`
	// Specifies which Webhooks to send.
	Filters []WebhookFilter `json:"filters" url:"filters"`
	// URL that webhooks will be sent to
	Url string `json:"url" url:"url"`
	// Credential contain secret
	CredentialId CredentialId `json:"credential_id" url:"credential_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhook) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhook) UnmarshalJSON(data []byte) error {
	type embed OrganizationWebhook
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OrganizationWebhook(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationWebhook) MarshalJSON() ([]byte, error) {
	type embed OrganizationWebhook
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *OrganizationWebhook) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrganizationWebhookSecret struct {
	// Secret used for signing webhooks. This value is used to verify the authenticity of the webhook payload.
	Value string `json:"value" url:"value"`
	// Time when this secret expires and can no longer be used again.
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationWebhookSecret) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationWebhookSecret) UnmarshalJSON(data []byte) error {
	type embed OrganizationWebhookSecret
	var unmarshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OrganizationWebhookSecret(unmarshaler.embed)
	o.Expires = unmarshaler.Expires.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationWebhookSecret) MarshalJSON() ([]byte, error) {
	type embed OrganizationWebhookSecret
	var marshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed:   embed(*o),
		Expires: core.NewOptionalDateTime(o.Expires),
	}
	return json.Marshal(marshaler)
}

func (o *OrganizationWebhookSecret) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type Permission struct {
	// Roles granted to this token.
	RoleBinding []RoleName `json:"role_binding,omitempty" url:"role_binding,omitempty"`
	// Adhoc role granted to this token.
	AdhocRole *AdhocRole `json:"adhoc_role,omitempty" url:"adhoc_role,omitempty"`
	// ID of the resource that this permission grants access to.
	ResourceId Id `json:"resource_id" url:"resource_id"`
	// Type of the resource that this permission grants access to. Must be one of the following: "organization, "integration"
	ResourceType string `json:"resource_type" url:"resource_type"`
	// Token parentId
	ParentId Id `json:"parent_id" url:"parent_id"`
	// Token Id
	Id Id `json:"id" url:"id"`
	// Token organizationId
	OrganizationId Id `json:"organization_id" url:"organization_id"`
	// Token root organizationId
	RootOrganizationId *Id `json:"root_organization_id,omitempty" url:"root_organization_id,omitempty"`
	// Token memberId
	MemberId Id `json:"member_id" url:"member_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Permission) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Permission) UnmarshalJSON(data []byte) error {
	type unmarshaler Permission
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Permission(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Permission) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type AccountsActions string

const (
	AccountsActionsList   AccountsActions = "list"
	AccountsActionsCreate AccountsActions = "create"
	AccountsActionsGet    AccountsActions = "get"
	AccountsActionsUpdate AccountsActions = "update"
	AccountsActionsPatch  AccountsActions = "patch"
	AccountsActionsDelete AccountsActions = "delete"
	AccountsActionsAll    AccountsActions = "*"
)

func NewAccountsActionsFromString(s string) (AccountsActions, error) {
	switch s {
	case "list":
		return AccountsActionsList, nil
	case "create":
		return AccountsActionsCreate, nil
	case "get":
		return AccountsActionsGet, nil
	case "update":
		return AccountsActionsUpdate, nil
	case "patch":
		return AccountsActionsPatch, nil
	case "delete":
		return AccountsActionsDelete, nil
	case "*":
		return AccountsActionsAll, nil
	}
	var t AccountsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AccountsActions) Ptr() *AccountsActions {
	return &a
}

// Permissions for the accounts API
type AccountsPermissions struct {
	Actions []AccountsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AccountsPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccountsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AccountsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccountsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccountsPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiPermissionMap struct {
	All               *ReadWritePermissions         `json:"all,omitempty" url:"all,omitempty"`
	Accounts          *AccountsPermissions          `json:"accounts,omitempty" url:"accounts,omitempty"`
	Audit             *AuditPermissions             `json:"audit,omitempty" url:"audit,omitempty"`
	Auth              *AuthPermissions              `json:"auth,omitempty" url:"auth,omitempty"`
	Bridges           *BridgesPermissions           `json:"bridges,omitempty" url:"bridges,omitempty"`
	Capabilities      *CapabilitiesPermissions      `json:"capabilities,omitempty" url:"capabilities,omitempty"`
	Credentials       *CredentialsPermissions       `json:"credentials,omitempty" url:"credentials,omitempty"`
	Integrations      *IntegrationsPermissions      `json:"integrations,omitempty" url:"integrations,omitempty"`
	IntegrationPoints *IntegrationPointsPermissions `json:"integration_points,omitempty" url:"integration_points,omitempty"`
	Members           *MembersPermissions           `json:"members,omitempty" url:"members,omitempty"`
	Organizations     *OrganizationPermissions      `json:"organizations,omitempty" url:"organizations,omitempty"`
	PermissionSet     *PermissionSetPermissions     `json:"permission_set,omitempty" url:"permission_set,omitempty"`
	Roles             *RolesPermissions             `json:"roles,omitempty" url:"roles,omitempty"`
	Status            *StatusPermissions            `json:"status,omitempty" url:"status,omitempty"`
	Suborgs           *SubOrgsPermissions           `json:"suborgs,omitempty" url:"suborgs,omitempty"`
	Tokens            *TokensPermissions            `json:"tokens,omitempty" url:"tokens,omitempty"`
	Transforms        *TransformsPermissions        `json:"transforms,omitempty" url:"transforms,omitempty"`
	Webhooks          *WebhooksPermissions          `json:"webhooks,omitempty" url:"webhooks,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiPermissionMap) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiPermissionMap) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiPermissionMap
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiPermissionMap(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiPermissionMap) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuditActions string

const (
	AuditActionsList AuditActions = "list"
	AuditActionsAll  AuditActions = "*"
)

func NewAuditActionsFromString(s string) (AuditActions, error) {
	switch s {
	case "list":
		return AuditActionsList, nil
	case "*":
		return AuditActionsAll, nil
	}
	var t AuditActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuditActions) Ptr() *AuditActions {
	return &a
}

// Permissions for the audit API
type AuditPermissions struct {
	Actions []AuditActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AuditPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AuditPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AuditPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuditPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuditPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AuthActions string

const (
	AuthActionsLogon          AuthActions = "logon"
	AuthActionsChangePassword AuthActions = "change_password"
	AuthActionsLogoff         AuthActions = "logoff"
	AuthActionsAll            AuthActions = "*"
)

func NewAuthActionsFromString(s string) (AuthActions, error) {
	switch s {
	case "logon":
		return AuthActionsLogon, nil
	case "change_password":
		return AuthActionsChangePassword, nil
	case "logoff":
		return AuthActionsLogoff, nil
	case "*":
		return AuthActionsAll, nil
	}
	var t AuthActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthActions) Ptr() *AuthActions {
	return &a
}

// Permissions for the auth logon/logoff API
type AuthPermissions struct {
	Actions []AuthActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AuthPermissions) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AuthPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuthPermissions) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BridgesActions string

const (
	BridgesActionsList   BridgesActions = "list"
	BridgesActionsCreate BridgesActions = "create"
	BridgesActionsGet    BridgesActions = "get"
	BridgesActionsUpdate BridgesActions = "update"
	BridgesActionsPatch  BridgesActions = "patch"
	BridgesActionsDelete BridgesActions = "delete"
	BridgesActionsAll    BridgesActions = "*"
)

func NewBridgesActionsFromString(s string) (BridgesActions, error) {
	switch s {
	case "list":
		return BridgesActionsList, nil
	case "create":
		return BridgesActionsCreate, nil
	case "get":
		return BridgesActionsGet, nil
	case "update":
		return BridgesActionsUpdate, nil
	case "patch":
		return BridgesActionsPatch, nil
	case "delete":
		return BridgesActionsDelete, nil
	case "*":
		return BridgesActionsAll, nil
	}
	var t BridgesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BridgesActions) Ptr() *BridgesActions {
	return &b
}

// Permissions for the bridge API
type BridgesPermissions struct {
	Actions []BridgesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BridgesPermissions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BridgesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler BridgesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BridgesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BridgesPermissions) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CapabilitiesActions string

const (
	CapabilitiesActionsListCategory  CapabilitiesActions = "list_category"
	CapabilitiesActionsListProviders CapabilitiesActions = "list_providers"
	CapabilitiesActionsAll           CapabilitiesActions = "*"
)

func NewCapabilitiesActionsFromString(s string) (CapabilitiesActions, error) {
	switch s {
	case "list_category":
		return CapabilitiesActionsListCategory, nil
	case "list_providers":
		return CapabilitiesActionsListProviders, nil
	case "*":
		return CapabilitiesActionsAll, nil
	}
	var t CapabilitiesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CapabilitiesActions) Ptr() *CapabilitiesActions {
	return &c
}

// Permissions for the capabilities API
type CapabilitiesPermissions struct {
	Actions []CapabilitiesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CapabilitiesPermissions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CapabilitiesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler CapabilitiesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CapabilitiesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CapabilitiesPermissions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialsActions string

const (
	CredentialsActionsList   CredentialsActions = "list"
	CredentialsActionsCreate CredentialsActions = "create"
	CredentialsActionsGet    CredentialsActions = "get"
	CredentialsActionsUpdate CredentialsActions = "update"
	CredentialsActionsPatch  CredentialsActions = "patch"
	CredentialsActionsDelete CredentialsActions = "delete"
	CredentialsActionsLookup CredentialsActions = "lookup"
	CredentialsActionsAll    CredentialsActions = "*"
)

func NewCredentialsActionsFromString(s string) (CredentialsActions, error) {
	switch s {
	case "list":
		return CredentialsActionsList, nil
	case "create":
		return CredentialsActionsCreate, nil
	case "get":
		return CredentialsActionsGet, nil
	case "update":
		return CredentialsActionsUpdate, nil
	case "patch":
		return CredentialsActionsPatch, nil
	case "delete":
		return CredentialsActionsDelete, nil
	case "lookup":
		return CredentialsActionsLookup, nil
	case "*":
		return CredentialsActionsAll, nil
	}
	var t CredentialsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialsActions) Ptr() *CredentialsActions {
	return &c
}

// Permissions for the credentials API
type CredentialsPermissions struct {
	Actions []CredentialsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialsPermissions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialsPermissions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type IntegrationPointsActions string

const (
	IntegrationPointsActionsList   IntegrationPointsActions = "list"
	IntegrationPointsActionsCreate IntegrationPointsActions = "create"
	IntegrationPointsActionsGet    IntegrationPointsActions = "get"
	IntegrationPointsActionsUpdate IntegrationPointsActions = "update"
	IntegrationPointsActionsPatch  IntegrationPointsActions = "patch"
	IntegrationPointsActionsDelete IntegrationPointsActions = "delete"
	IntegrationPointsActionsAll    IntegrationPointsActions = "*"
)

func NewIntegrationPointsActionsFromString(s string) (IntegrationPointsActions, error) {
	switch s {
	case "list":
		return IntegrationPointsActionsList, nil
	case "create":
		return IntegrationPointsActionsCreate, nil
	case "get":
		return IntegrationPointsActionsGet, nil
	case "update":
		return IntegrationPointsActionsUpdate, nil
	case "patch":
		return IntegrationPointsActionsPatch, nil
	case "delete":
		return IntegrationPointsActionsDelete, nil
	case "*":
		return IntegrationPointsActionsAll, nil
	}
	var t IntegrationPointsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationPointsActions) Ptr() *IntegrationPointsActions {
	return &i
}

// Permissions for the integrations points API
type IntegrationPointsPermissions struct {
	Actions []IntegrationPointsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationPointsPermissions) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationPointsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationPointsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationPointsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationPointsPermissions) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IntegrationsActions string

const (
	IntegrationsActionsList        IntegrationsActions = "list"
	IntegrationsActionsCreate      IntegrationsActions = "create"
	IntegrationsActionsGet         IntegrationsActions = "get"
	IntegrationsActionsUpdate      IntegrationsActions = "update"
	IntegrationsActionsPatch       IntegrationsActions = "patch"
	IntegrationsActionsDelete      IntegrationsActions = "delete"
	IntegrationsActionsListAccount IntegrationsActions = "list_account"
	IntegrationsActionsVerify      IntegrationsActions = "verify"
	IntegrationsActionsAll         IntegrationsActions = "*"
)

func NewIntegrationsActionsFromString(s string) (IntegrationsActions, error) {
	switch s {
	case "list":
		return IntegrationsActionsList, nil
	case "create":
		return IntegrationsActionsCreate, nil
	case "get":
		return IntegrationsActionsGet, nil
	case "update":
		return IntegrationsActionsUpdate, nil
	case "patch":
		return IntegrationsActionsPatch, nil
	case "delete":
		return IntegrationsActionsDelete, nil
	case "list_account":
		return IntegrationsActionsListAccount, nil
	case "verify":
		return IntegrationsActionsVerify, nil
	case "*":
		return IntegrationsActionsAll, nil
	}
	var t IntegrationsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationsActions) Ptr() *IntegrationsActions {
	return &i
}

// Permissions for the integrations API
type IntegrationsPermissions struct {
	Actions []IntegrationsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationsPermissions) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationsPermissions) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type MembersActions string

const (
	MembersActionsList   MembersActions = "list"
	MembersActionsCreate MembersActions = "create"
	MembersActionsGet    MembersActions = "get"
	MembersActionsUpdate MembersActions = "update"
	MembersActionsPatch  MembersActions = "patch"
	MembersActionsDelete MembersActions = "delete"
	MembersActionsAll    MembersActions = "*"
)

func NewMembersActionsFromString(s string) (MembersActions, error) {
	switch s {
	case "list":
		return MembersActionsList, nil
	case "create":
		return MembersActionsCreate, nil
	case "get":
		return MembersActionsGet, nil
	case "update":
		return MembersActionsUpdate, nil
	case "patch":
		return MembersActionsPatch, nil
	case "delete":
		return MembersActionsDelete, nil
	case "*":
		return MembersActionsAll, nil
	}
	var t MembersActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MembersActions) Ptr() *MembersActions {
	return &m
}

// Permissions for the members API
type MembersPermissions struct {
	Actions []MembersActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MembersPermissions) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MembersPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler MembersPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MembersPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MembersPermissions) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OrganizationActions string

const (
	OrganizationActionsGet    OrganizationActions = "get"
	OrganizationActionsUpdate OrganizationActions = "update"
	OrganizationActionsPatch  OrganizationActions = "patch"
	OrganizationActionsAll    OrganizationActions = "*"
)

func NewOrganizationActionsFromString(s string) (OrganizationActions, error) {
	switch s {
	case "get":
		return OrganizationActionsGet, nil
	case "update":
		return OrganizationActionsUpdate, nil
	case "patch":
		return OrganizationActionsPatch, nil
	case "*":
		return OrganizationActionsAll, nil
	}
	var t OrganizationActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrganizationActions) Ptr() *OrganizationActions {
	return &o
}

// Permissions for the organization API
type OrganizationPermissions struct {
	Actions []OrganizationActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrganizationPermissions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrganizationPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrganizationPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrganizationPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrganizationPermissions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PermissionSet struct {
	Name Permissions `json:"name" url:"name"`
	// Description of when the permission set should be used and what permissions are granted by the permission set.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Resources that can be used with this permission set
	ResourceRestrictions []ResourceRestrictions `json:"resource_restrictions,omitempty" url:"resource_restrictions,omitempty"`
	// API permissions granted by the permission set.
	Permissions *ApiPermissionMap `json:"permissions" url:"permissions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PermissionSet) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PermissionSet) UnmarshalJSON(data []byte) error {
	type unmarshaler PermissionSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PermissionSet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PermissionSet) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PermissionSetActions string

const (
	PermissionSetActionsList PermissionSetActions = "list"
	PermissionSetActionsGet  PermissionSetActions = "get"
	PermissionSetActionsAll  PermissionSetActions = "*"
)

func NewPermissionSetActionsFromString(s string) (PermissionSetActions, error) {
	switch s {
	case "list":
		return PermissionSetActionsList, nil
	case "get":
		return PermissionSetActionsGet, nil
	case "*":
		return PermissionSetActionsAll, nil
	}
	var t PermissionSetActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PermissionSetActions) Ptr() *PermissionSetActions {
	return &p
}

// Permissions for the permissionset API
type PermissionSetPermissions struct {
	Actions []PermissionSetActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PermissionSetPermissions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PermissionSetPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler PermissionSetPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PermissionSetPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PermissionSetPermissions) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ReadWriteActions string

const (
	ReadWriteActionsRead      ReadWriteActions = "read"
	ReadWriteActionsReadWrite ReadWriteActions = "*"
)

func NewReadWriteActionsFromString(s string) (ReadWriteActions, error) {
	switch s {
	case "read":
		return ReadWriteActionsRead, nil
	case "*":
		return ReadWriteActionsReadWrite, nil
	}
	var t ReadWriteActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ReadWriteActions) Ptr() *ReadWriteActions {
	return &r
}

// Permissions for all accounts
type ReadWritePermissions struct {
	Actions []ReadWriteActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReadWritePermissions) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReadWritePermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler ReadWritePermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReadWritePermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReadWritePermissions) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResourceRestrictions string

const (
	ResourceRestrictionsAccounts     ResourceRestrictions = "accounts"
	ResourceRestrictionsIntegrations ResourceRestrictions = "integrations"
)

func NewResourceRestrictionsFromString(s string) (ResourceRestrictions, error) {
	switch s {
	case "accounts":
		return ResourceRestrictionsAccounts, nil
	case "integrations":
		return ResourceRestrictionsIntegrations, nil
	}
	var t ResourceRestrictions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResourceRestrictions) Ptr() *ResourceRestrictions {
	return &r
}

type RolesActions string

const (
	RolesActionsList   RolesActions = "list"
	RolesActionsCreate RolesActions = "create"
	RolesActionsGet    RolesActions = "get"
	RolesActionsUpdate RolesActions = "update"
	RolesActionsPatch  RolesActions = "patch"
	RolesActionsDelete RolesActions = "delete"
	RolesActionsAll    RolesActions = "*"
)

func NewRolesActionsFromString(s string) (RolesActions, error) {
	switch s {
	case "list":
		return RolesActionsList, nil
	case "create":
		return RolesActionsCreate, nil
	case "get":
		return RolesActionsGet, nil
	case "update":
		return RolesActionsUpdate, nil
	case "patch":
		return RolesActionsPatch, nil
	case "delete":
		return RolesActionsDelete, nil
	case "*":
		return RolesActionsAll, nil
	}
	var t RolesActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RolesActions) Ptr() *RolesActions {
	return &r
}

// Permissions for the roles API
type RolesPermissions struct {
	Actions []RolesActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RolesPermissions) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RolesPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler RolesPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RolesPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RolesPermissions) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type StatusActions string

const (
	StatusActionsList                  StatusActions = "list"
	StatusActionsGet                   StatusActions = "get"
	StatusActionsReset                 StatusActions = "reset"
	StatusActionsListEvents            StatusActions = "list_events"
	StatusActionsTimeseries            StatusActions = "timeseries"
	StatusActionsIntegrationTimeseries StatusActions = "integration_timeseries"
	StatusActionsAll                   StatusActions = "*"
)

func NewStatusActionsFromString(s string) (StatusActions, error) {
	switch s {
	case "list":
		return StatusActionsList, nil
	case "get":
		return StatusActionsGet, nil
	case "reset":
		return StatusActionsReset, nil
	case "list_events":
		return StatusActionsListEvents, nil
	case "timeseries":
		return StatusActionsTimeseries, nil
	case "integration_timeseries":
		return StatusActionsIntegrationTimeseries, nil
	case "*":
		return StatusActionsAll, nil
	}
	var t StatusActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusActions) Ptr() *StatusActions {
	return &s
}

// Permissions for the status API
type StatusPermissions struct {
	Actions []StatusActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StatusPermissions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StatusPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler StatusPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StatusPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StatusPermissions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubOrgsActions string

const (
	SubOrgsActionsList   SubOrgsActions = "list"
	SubOrgsActionsCreate SubOrgsActions = "create"
	SubOrgsActionsGet    SubOrgsActions = "get"
	SubOrgsActionsDelete SubOrgsActions = "delete"
	SubOrgsActionsAll    SubOrgsActions = "*"
)

func NewSubOrgsActionsFromString(s string) (SubOrgsActions, error) {
	switch s {
	case "list":
		return SubOrgsActionsList, nil
	case "create":
		return SubOrgsActionsCreate, nil
	case "get":
		return SubOrgsActionsGet, nil
	case "delete":
		return SubOrgsActionsDelete, nil
	case "*":
		return SubOrgsActionsAll, nil
	}
	var t SubOrgsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubOrgsActions) Ptr() *SubOrgsActions {
	return &s
}

// Permissions for the roles API
type SubOrgsPermissions struct {
	Actions []SubOrgsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubOrgsPermissions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubOrgsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler SubOrgsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubOrgsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubOrgsPermissions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TokensActions string

const (
	TokensActionsList              TokensActions = "list"
	TokensActionsCreate            TokensActions = "create"
	TokensActionsCreateIntegration TokensActions = "create_integration"
	TokensActionsGet               TokensActions = "get"
	TokensActionsReset             TokensActions = "reset"
	TokensActionsRefresh           TokensActions = "refresh"
	TokensActionsRemoveSecondary   TokensActions = "remove_secondary"
	TokensActionsAll               TokensActions = "*"
)

func NewTokensActionsFromString(s string) (TokensActions, error) {
	switch s {
	case "list":
		return TokensActionsList, nil
	case "create":
		return TokensActionsCreate, nil
	case "create_integration":
		return TokensActionsCreateIntegration, nil
	case "get":
		return TokensActionsGet, nil
	case "reset":
		return TokensActionsReset, nil
	case "refresh":
		return TokensActionsRefresh, nil
	case "remove_secondary":
		return TokensActionsRemoveSecondary, nil
	case "*":
		return TokensActionsAll, nil
	}
	var t TokensActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokensActions) Ptr() *TokensActions {
	return &t
}

// Permissions for the tokens API
type TokensPermissions struct {
	Actions []TokensActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokensPermissions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokensPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler TokensPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokensPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokensPermissions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TransformsActions string

const (
	TransformsActionsList   TransformsActions = "list"
	TransformsActionsCreate TransformsActions = "create"
	TransformsActionsGet    TransformsActions = "get"
	TransformsActionsUpdate TransformsActions = "update"
	TransformsActionsPatch  TransformsActions = "patch"
	TransformsActionsDelete TransformsActions = "delete"
	TransformsActionsAll    TransformsActions = "*"
)

func NewTransformsActionsFromString(s string) (TransformsActions, error) {
	switch s {
	case "list":
		return TransformsActionsList, nil
	case "create":
		return TransformsActionsCreate, nil
	case "get":
		return TransformsActionsGet, nil
	case "update":
		return TransformsActionsUpdate, nil
	case "patch":
		return TransformsActionsPatch, nil
	case "delete":
		return TransformsActionsDelete, nil
	case "*":
		return TransformsActionsAll, nil
	}
	var t TransformsActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformsActions) Ptr() *TransformsActions {
	return &t
}

// Permissions for the transforms API
type TransformsPermissions struct {
	Actions []TransformsActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransformsPermissions) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformsPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformsPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformsPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransformsPermissions) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type WebhooksActions string

const (
	WebhooksActionsList   WebhooksActions = "list"
	WebhooksActionsCreate WebhooksActions = "create"
	WebhooksActionsGet    WebhooksActions = "get"
	WebhooksActionsUpdate WebhooksActions = "update"
	WebhooksActionsPatch  WebhooksActions = "patch"
	WebhooksActionsDelete WebhooksActions = "delete"
	WebhooksActionsAll    WebhooksActions = "*"
)

func NewWebhooksActionsFromString(s string) (WebhooksActions, error) {
	switch s {
	case "list":
		return WebhooksActionsList, nil
	case "create":
		return WebhooksActionsCreate, nil
	case "get":
		return WebhooksActionsGet, nil
	case "update":
		return WebhooksActionsUpdate, nil
	case "patch":
		return WebhooksActionsPatch, nil
	case "delete":
		return WebhooksActionsDelete, nil
	case "*":
		return WebhooksActionsAll, nil
	}
	var t WebhooksActions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhooksActions) Ptr() *WebhooksActions {
	return &w
}

// Permissions for the webhooks API
type WebhooksPermissions struct {
	Actions []WebhooksActions `json:"actions" url:"actions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhooksPermissions) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhooksPermissions) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhooksPermissions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhooksPermissions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhooksPermissions) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type ArmisCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (a *ArmisCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a ArmisCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type ArmisCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *ArmisCredential) Accept(visitor ArmisCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

// Configuration for the Armis Centrix Assets Provider
type AssetsArmisCentrix struct {
	Credential *ArmisCredential `json:"credential" url:"credential"`
	// URL for the Armis Centrix API. This should be the base URL for the API, without any path components. For example, "https://tenant.armis.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsArmisCentrix) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsArmisCentrix) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsArmisCentrix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsArmisCentrix(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssetsArmisCentrix) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for the Nozomi Vantage provider
type AssetsNozomiVantage struct {
	Credential *NozomiVantageCredential `json:"credential" url:"credential"`
	// URL for the Nozomi Vantage API. This should be the base URL for the API, without any path components. For example, "https://tenant.us1.vantage.nozominetworks.io".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsNozomiVantage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsNozomiVantage) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsNozomiVantage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsNozomiVantage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssetsNozomiVantage) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Configuration for ServiceNow as an Assets Provider
type AssetsServiceNow struct {
	Credential *ServiceNowCredential `json:"credential" url:"credential"`
	// URL for the ServiceNow API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.service-now.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AssetsServiceNow) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AssetsServiceNow) UnmarshalJSON(data []byte) error {
	type unmarshaler AssetsServiceNow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AssetsServiceNow(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AssetsServiceNow) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AwsS3Credential struct {
	Type  string
	Aws   *AwsCredential
	AwsId AwsCredentialId
}

func (a *AwsS3Credential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsS3Credential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsS3CredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsS3Credential) Accept(visitor AwsS3CredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSqsCredential struct {
	Type  string
	Aws   *AwsCredential
	AwsId AwsCredentialId
}

func (a *AwsSqsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsSqsCredential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSqsCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsSqsCredential) Accept(visitor AwsSqsCredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSecurityLakeCredential struct {
	Type  string
	Aws   *AwsCredential
	AwsId AwsCredentialId
}

func (a *AwsSecurityLakeCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (a AwsSecurityLakeCredential) MarshalJSON() ([]byte, error) {
	if a.Aws != nil {
		return core.MarshalJSONWithExtraProperty(a.Aws, "type", "aws")
	}
	if a.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: a.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AwsSecurityLakeCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (a *AwsSecurityLakeCredential) Accept(visitor AwsSecurityLakeCredentialVisitor) error {
	if a.Aws != nil {
		return visitor.VisitAws(a.Aws)
	}
	if a.AwsId != "" {
		return visitor.VisitAwsId(a.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureBlobCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (a *AzureBlobCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a AzureBlobCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureBlobCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *AzureBlobCredential) Accept(visitor AzureBlobCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureMonitorLogsCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (a *AzureMonitorLogsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (a AzureMonitorLogsCredential) MarshalJSON() ([]byte, error) {
	if a.Token != nil {
		return core.MarshalJSONWithExtraProperty(a.Token, "type", "token")
	}
	if a.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: a.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AzureMonitorLogsCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (a *AzureMonitorLogsCredential) Accept(visitor AzureMonitorLogsCredentialVisitor) error {
	if a.Token != nil {
		return visitor.VisitToken(a.Token)
	}
	if a.TokenId != "" {
		return visitor.VisitTokenId(a.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

type CrowdStrikeCredential struct {
	Type          string
	OAuthClient   *OAuthClientCredential
	OAuthClientId OAuthClientCredentialId
}

func (c *CrowdStrikeCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (c CrowdStrikeCredential) MarshalJSON() ([]byte, error) {
	if c.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(c.OAuthClient, "type", "o_auth_client")
	}
	if c.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: c.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CrowdStrikeCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (c *CrowdStrikeCredential) Accept(visitor CrowdStrikeCredentialVisitor) error {
	if c.OAuthClient != nil {
		return visitor.VisitOAuthClient(c.OAuthClient)
	}
	if c.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(c.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CustomFieldMapping struct {
	// Name for the custom field that you will use in the `custom_fields` field in ticket objects within Synqly.
	Name string `json:"name" url:"name"`
	// ID of the project this field mapping is associated with. ID of "\*" is used to apply to all projects.
	ProjectId string `json:"project_id" url:"project_id"`
	// Path to or name of the custom field in the provider.
	ProviderFieldPath string `json:"provider_field_path" url:"provider_field_path"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomFieldMapping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomFieldMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomFieldMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomFieldMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomFieldMapping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DefenderCredential struct {
	Type          string
	OAuthClient   *OAuthClientCredential
	OAuthClientId OAuthClientCredentialId
}

func (d *DefenderCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", d)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		d.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (d DefenderCredential) MarshalJSON() ([]byte, error) {
	if d.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(d.OAuthClient, "type", "o_auth_client")
	}
	if d.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: d.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", d)
}

type DefenderCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (d *DefenderCredential) Accept(visitor DefenderCredentialVisitor) error {
	if d.OAuthClient != nil {
		return visitor.VisitOAuthClient(d.OAuthClient)
	}
	if d.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(d.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", d)
}

// Configuration for the CrowdStrike EDR Provider
type EdrCrowdStrike struct {
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// The root domain where your CrowdStrike Falcon tenant is located. Default "https://api.crowdstrike.com".
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrCrowdStrike) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrCrowdStrike) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrCrowdStrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrCrowdStrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EdrCrowdStrike) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for the Microsoft Defender EDR Provider
type EdrDefender struct {
	Credential *DefenderCredential `json:"credential" url:"credential"`
	// TenantId for the Microsoft Defender Management Console.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// URL for the Microsoft Defender Management Console.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrDefender) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrDefender) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrDefender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrDefender(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EdrDefender) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Configuration for the SentinelOne EDR Provider
type EdrSentinelOne struct {
	Credential *SentinelOneCredential `json:"credential" url:"credential"`
	// URL for the SentinelOne Management API. This should be the base URL for the API, without any path components. For example, "https://your_management_url".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EdrSentinelOne) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdrSentinelOne) UnmarshalJSON(data []byte) error {
	type unmarshaler EdrSentinelOne
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdrSentinelOne(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EdrSentinelOne) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Options used to control how requests are made to elasticsearch when different authentication types are used.
type ElasticsearchAuthOptions struct {
	// When you have the correct permissions, this allows API requests to get made as a specific user, with all of their roles
	// and permissions. When populated, this option will send the 'es-security-runas-user' header with every request made to
	// the Elasticsearch API.
	RunAs *string `json:"run_as,omitempty" url:"run_as,omitempty"`
	// Some auth cases, notably JWT auth can be configured to require sending a shared secret in the `ES-Client-Authentication`
	// header. When this secret is populated, it will get added as the shared secret for every request made to Elasticsearch.
	SharedSecret *ElasticsearchSharedSecret `json:"shared_secret,omitempty" url:"shared_secret,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ElasticsearchAuthOptions) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElasticsearchAuthOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ElasticsearchAuthOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElasticsearchAuthOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElasticsearchAuthOptions) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ElasticsearchCredential struct {
	Type          string
	OAuthClient   *OAuthClientCredential
	OAuthClientId OAuthClientCredentialId
	Token         *TokenCredential
	TokenId       TokenCredentialId
}

func (e *ElasticsearchCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.OAuthClientId = valueUnmarshaler.OAuthClientId
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (e ElasticsearchCredential) MarshalJSON() ([]byte, error) {
	if e.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(e.OAuthClient, "type", "o_auth_client")
	}
	if e.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: e.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if e.Token != nil {
		return core.MarshalJSONWithExtraProperty(e.Token, "type", "token")
	}
	if e.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: e.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (e *ElasticsearchCredential) Accept(visitor ElasticsearchCredentialVisitor) error {
	if e.OAuthClient != nil {
		return visitor.VisitOAuthClient(e.OAuthClient)
	}
	if e.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(e.OAuthClientId)
	}
	if e.Token != nil {
		return visitor.VisitToken(e.Token)
	}
	if e.TokenId != "" {
		return visitor.VisitTokenId(e.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchSharedSecret struct {
	Type     string
	Secret   *SecretCredential
	SecretId SecretCredentialId
}

func (e *ElasticsearchSharedSecret) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (e ElasticsearchSharedSecret) MarshalJSON() ([]byte, error) {
	if e.Secret != nil {
		return core.MarshalJSONWithExtraProperty(e.Secret, "type", "secret")
	}
	if e.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: e.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ElasticsearchSharedSecretVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (e *ElasticsearchSharedSecret) Accept(visitor ElasticsearchSharedSecretVisitor) error {
	if e.Secret != nil {
		return visitor.VisitSecret(e.Secret)
	}
	if e.SecretId != "" {
		return visitor.VisitSecretId(e.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EntraIdCredential struct {
	Type          string
	OAuthClient   *OAuthClientCredential
	OAuthClientId OAuthClientCredentialId
}

func (e *EntraIdCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		e.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (e EntraIdCredential) MarshalJSON() ([]byte, error) {
	if e.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(e.OAuthClient, "type", "o_auth_client")
	}
	if e.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: e.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EntraIdCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (e *EntraIdCredential) Accept(visitor EntraIdCredentialVisitor) error {
	if e.OAuthClient != nil {
		return visitor.VisitOAuthClient(e.OAuthClient)
	}
	if e.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(e.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type GcsCredential struct {
	Type  string
	Aws   *AwsCredential
	AwsId AwsCredentialId
}

func (g *GcsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", g)
	}
	switch unmarshaler.Type {
	case "aws":
		value := new(AwsCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.Aws = value
	case "aws_id":
		var valueUnmarshaler struct {
			AwsId AwsCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		g.AwsId = valueUnmarshaler.AwsId
	}
	return nil
}

func (g GcsCredential) MarshalJSON() ([]byte, error) {
	if g.Aws != nil {
		return core.MarshalJSONWithExtraProperty(g.Aws, "type", "aws")
	}
	if g.AwsId != "" {
		var marshaler = struct {
			Type  string          `json:"type"`
			AwsId AwsCredentialId `json:"value"`
		}{
			Type:  "aws_id",
			AwsId: g.AwsId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GcsCredentialVisitor interface {
	VisitAws(*AwsCredential) error
	VisitAwsId(AwsCredentialId) error
}

func (g *GcsCredential) Accept(visitor GcsCredentialVisitor) error {
	if g.Aws != nil {
		return visitor.VisitAws(g.Aws)
	}
	if g.AwsId != "" {
		return visitor.VisitAwsId(g.AwsId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

type HooksHttpCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (h *HooksHttpCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", h)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		h.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (h HooksHttpCredential) MarshalJSON() ([]byte, error) {
	if h.Token != nil {
		return core.MarshalJSONWithExtraProperty(h.Token, "type", "token")
	}
	if h.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: h.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", h)
}

type HooksHttpCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (h *HooksHttpCredential) Accept(visitor HooksHttpCredentialVisitor) error {
	if h.Token != nil {
		return visitor.VisitToken(h.Token)
	}
	if h.TokenId != "" {
		return visitor.VisitTokenId(h.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", h)
}

// Configuration for a Webhook Provider
type HooksHttp struct {
	Credential *HooksHttpCredential `json:"credential" url:"credential"`
	// Optional webhook filter specification
	Filter *string `json:"filter,omitempty" url:"filter,omitempty"`
	// Events to hook or empty list for all events
	SourceEvents []string `json:"source_events" url:"source_events"`
	// Webhook verification secret
	SourceSecret *CredentialId `json:"source_secret,omitempty" url:"source_secret,omitempty"`
	// Add optional webhook secure hash for verification
	TargetSecret *CredentialId `json:"target_secret,omitempty" url:"target_secret,omitempty"`
	// Optional list of transformations used to modify the webhook responses.
	Transforms []TransformId `json:"transforms,omitempty" url:"transforms,omitempty"`
	// URL of the endpoint used for connecting to the external service.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HooksHttp) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HooksHttp) UnmarshalJSON(data []byte) error {
	type unmarshaler HooksHttp
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HooksHttp(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HooksHttp) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Configuration for the Microsoft Entra ID Identity Provider
type IdentityEntraId struct {
	Credential *EntraIdCredential `json:"credential" url:"credential"`
	// Azure Directory (tenant) ID.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// Optional URL override for the Microsoft Graph API. This should be the base URL for the API without any path components.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityEntraId) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityEntraId) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityEntraId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityEntraId(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IdentityEntraId) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for the Okta Identity Provider
type IdentityOkta struct {
	Credential *OktaCredential `json:"credential" url:"credential"`
	// URL for the Okta API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.okta.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityOkta) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityOkta) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityOkta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityOkta(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IdentityOkta) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for the PingOne Identity Platform
type IdentityPingOne struct {
	// The URL base for making authentication requests to PingOne.
	AuthUrl string `json:"auth_url" url:"auth_url"`
	// The client ID for the application set up as a worker.
	ClientId   string             `json:"client_id" url:"client_id"`
	Credential *PingOneCredential `json:"credential" url:"credential"`
	// The organization ID that the client app is a part of.
	OrganizationId string `json:"organization_id" url:"organization_id"`
	// URL for the PingOne API. This should be the base URL for the API, without any path components.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IdentityPingOne) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IdentityPingOne) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityPingOne
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityPingOne(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IdentityPingOne) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JiraCredential struct {
	Type    string
	Basic   *BasicCredential
	BasicId BasicCredentialId
}

func (j *JiraCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	j.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", j)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		j.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		j.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (j JiraCredential) MarshalJSON() ([]byte, error) {
	if j.Basic != nil {
		return core.MarshalJSONWithExtraProperty(j.Basic, "type", "basic")
	}
	if j.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: j.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", j)
}

type JiraCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (j *JiraCredential) Accept(visitor JiraCredentialVisitor) error {
	if j.Basic != nil {
		return visitor.VisitBasic(j.Basic)
	}
	if j.BasicId != "" {
		return visitor.VisitBasicId(j.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", j)
}

// Configuration for Jira as a Notification Provider
type NotificationsJira struct {
	Credential *JiraCredential `json:"credential" url:"credential"`
	// URL for the Jira API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.atlassian.net".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsJira) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsJira) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsJira
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsJira(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationsJira) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for the Mock in-memory notification handler. This provider is for testing purposes only.
type NotificationsMock struct {
	// The channel to send notifications to.
	Channel *string `json:"channel,omitempty" url:"channel,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsMock) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsMock) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationsMock) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for the Slack Notification Provider
type NotificationsSlack struct {
	// The channel to send notifications to. Should be the ID of the desired channel.
	Channel    string           `json:"channel" url:"channel"`
	Credential *SlackCredential `json:"credential" url:"credential"`
	// Optional URL override for the Slack API. This should include the full path to the API endpoint. Defaults to "https://slack.com_api_chat.postMessage".
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsSlack) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsSlack) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsSlack
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsSlack(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationsSlack) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Configuration for Microsoft Teams Notification Provider
type NotificationsTeams struct {
	Credential *TeamsCredential `json:"credential" url:"credential"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NotificationsTeams) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NotificationsTeams) UnmarshalJSON(data []byte) error {
	type unmarshaler NotificationsTeams
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NotificationsTeams(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NotificationsTeams) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NozomiVantageCredential struct {
	Type    string
	Basic   *BasicCredential
	BasicId BasicCredentialId
}

func (n *NozomiVantageCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		n.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (n NozomiVantageCredential) MarshalJSON() ([]byte, error) {
	if n.Basic != nil {
		return core.MarshalJSONWithExtraProperty(n.Basic, "type", "basic")
	}
	if n.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: n.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NozomiVantageCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (n *NozomiVantageCredential) Accept(visitor NozomiVantageCredentialVisitor) error {
	if n.Basic != nil {
		return visitor.VisitBasic(n.Basic)
	}
	if n.BasicId != "" {
		return visitor.VisitBasicId(n.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

type OktaCredential struct {
	Type          string
	OAuthClient   *OAuthClientCredential
	OAuthClientId OAuthClientCredentialId
	Token         *TokenCredential
	TokenId       TokenCredentialId
}

func (o *OktaCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", o)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		o.OAuthClientId = valueUnmarshaler.OAuthClientId
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		o.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (o OktaCredential) MarshalJSON() ([]byte, error) {
	if o.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(o.OAuthClient, "type", "o_auth_client")
	}
	if o.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: o.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	if o.Token != nil {
		return core.MarshalJSONWithExtraProperty(o.Token, "type", "token")
	}
	if o.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: o.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", o)
}

type OktaCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (o *OktaCredential) Accept(visitor OktaCredentialVisitor) error {
	if o.OAuthClient != nil {
		return visitor.VisitOAuthClient(o.OAuthClient)
	}
	if o.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(o.OAuthClientId)
	}
	if o.Token != nil {
		return visitor.VisitToken(o.Token)
	}
	if o.TokenId != "" {
		return visitor.VisitTokenId(o.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", o)
}

type PagerDutyCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (p *PagerDutyCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (p PagerDutyCredential) MarshalJSON() ([]byte, error) {
	if p.Token != nil {
		return core.MarshalJSONWithExtraProperty(p.Token, "type", "token")
	}
	if p.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: p.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PagerDutyCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (p *PagerDutyCredential) Accept(visitor PagerDutyCredentialVisitor) error {
	if p.Token != nil {
		return visitor.VisitToken(p.Token)
	}
	if p.TokenId != "" {
		return visitor.VisitTokenId(p.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PingOneCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (p *PingOneCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (p PingOneCredential) MarshalJSON() ([]byte, error) {
	if p.Token != nil {
		return core.MarshalJSONWithExtraProperty(p.Token, "type", "token")
	}
	if p.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: p.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PingOneCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (p *PingOneCredential) Accept(visitor PingOneCredentialVisitor) error {
	if p.Token != nil {
		return visitor.VisitToken(p.Token)
	}
	if p.TokenId != "" {
		return visitor.VisitTokenId(p.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PriorityMapping struct {
	// Custom value for the "High" priority.
	High *string `json:"high,omitempty" url:"high,omitempty"`
	// Custom value for the "Low" priority.
	Low *string `json:"low,omitempty" url:"low,omitempty"`
	// Custom value for the "Medium" priority.
	Medium *string `json:"medium,omitempty" url:"medium,omitempty"`
	// Custom value for the "Urgent" priority.
	Urgent *string `json:"urgent,omitempty" url:"urgent,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PriorityMapping) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PriorityMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler PriorityMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PriorityMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PriorityMapping) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProviderConfig struct {
	Type                              string
	AssetsArmisCentrix                *AssetsArmisCentrix
	AssetsNozomiVantage               *AssetsNozomiVantage
	AssetsServicenow                  *AssetsServiceNow
	EdrCrowdstrike                    *EdrCrowdStrike
	EdrDefender                       *EdrDefender
	EdrSentinelone                    *EdrSentinelOne
	HooksHttp                         *HooksHttp
	IdentityEntraId                   *IdentityEntraId
	IdentityOkta                      *IdentityOkta
	IdentityPingone                   *IdentityPingOne
	NotificationsJira                 *NotificationsJira
	NotificationsMockNotifications    *NotificationsMock
	NotificationsSlack                *NotificationsSlack
	NotificationsTeams                *NotificationsTeams
	SiemElasticsearch                 *SiemElasticsearch
	SiemMockSiem                      *SiemMock
	SiemQRadar                        *SiemQRadar
	SiemRapid7Insightidr              *SiemRapid7InsightIdr
	SiemSplunk                        *SiemSplunk
	SiemSumoLogic                     *SiemSumoLogic
	SinkAwsSecurityLake               *SinkAwsSecurityLake
	SinkAwsSqs                        *SinkAwsSqs
	SinkAzureMonitorLogs              *SinkAzureMonitorLogs
	SinkMockSink                      *SinkMock
	StorageAwsS3                      *StorageAwsS3
	StorageAzureBlob                  *StorageAzureBlob
	StorageGcs                        *StorageGcs
	StorageMockStorage                *StorageMock
	TicketingJira                     *TicketingJira
	TicketingMockTicketing            *TicketingMock
	TicketingPagerduty                *TicketingPagerDuty
	TicketingServicenow               *TicketingServiceNow
	TicketingTorq                     *TicketingTorq
	VulnerabilitiesCrowdstrike        *VulnerabilitiesCrowdStrike
	VulnerabilitiesQualysCloud        *VulnerabilitiesQualysCloud
	VulnerabilitiesRapid7InsightCloud *VulnerabilitiesRapid7InsightCloud
	VulnerabilitiesTaniumCloud        *VulnerabilitiesTaniumCloud
	VulnerabilitiesTenableCloud       *VulnerabilitiesTenableCloud
}

func (p *ProviderConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "assets_armis_centrix":
		value := new(AssetsArmisCentrix)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsArmisCentrix = value
	case "assets_nozomi_vantage":
		value := new(AssetsNozomiVantage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsNozomiVantage = value
	case "assets_servicenow":
		value := new(AssetsServiceNow)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.AssetsServicenow = value
	case "edr_crowdstrike":
		value := new(EdrCrowdStrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrCrowdstrike = value
	case "edr_defender":
		value := new(EdrDefender)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrDefender = value
	case "edr_sentinelone":
		value := new(EdrSentinelOne)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.EdrSentinelone = value
	case "hooks_http":
		value := new(HooksHttp)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.HooksHttp = value
	case "identity_entra_id":
		value := new(IdentityEntraId)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityEntraId = value
	case "identity_okta":
		value := new(IdentityOkta)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityOkta = value
	case "identity_pingone":
		value := new(IdentityPingOne)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.IdentityPingone = value
	case "notifications_jira":
		value := new(NotificationsJira)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsJira = value
	case "notifications_mock_notifications":
		value := new(NotificationsMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsMockNotifications = value
	case "notifications_slack":
		value := new(NotificationsSlack)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsSlack = value
	case "notifications_teams":
		value := new(NotificationsTeams)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.NotificationsTeams = value
	case "siem_elasticsearch":
		value := new(SiemElasticsearch)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemElasticsearch = value
	case "siem_mock_siem":
		value := new(SiemMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemMockSiem = value
	case "siem_q_radar":
		value := new(SiemQRadar)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemQRadar = value
	case "siem_rapid7_insightidr":
		value := new(SiemRapid7InsightIdr)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemRapid7Insightidr = value
	case "siem_splunk":
		value := new(SiemSplunk)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemSplunk = value
	case "siem_sumo_logic":
		value := new(SiemSumoLogic)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SiemSumoLogic = value
	case "sink_aws_security_lake":
		value := new(SinkAwsSecurityLake)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAwsSecurityLake = value
	case "sink_aws_sqs":
		value := new(SinkAwsSqs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAwsSqs = value
	case "sink_azure_monitor_logs":
		value := new(SinkAzureMonitorLogs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkAzureMonitorLogs = value
	case "sink_mock_sink":
		value := new(SinkMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SinkMockSink = value
	case "storage_aws_s3":
		value := new(StorageAwsS3)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageAwsS3 = value
	case "storage_azure_blob":
		value := new(StorageAzureBlob)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageAzureBlob = value
	case "storage_gcs":
		value := new(StorageGcs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageGcs = value
	case "storage_mock_storage":
		value := new(StorageMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.StorageMockStorage = value
	case "ticketing_jira":
		value := new(TicketingJira)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingJira = value
	case "ticketing_mock_ticketing":
		value := new(TicketingMock)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingMockTicketing = value
	case "ticketing_pagerduty":
		value := new(TicketingPagerDuty)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingPagerduty = value
	case "ticketing_servicenow":
		value := new(TicketingServiceNow)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingServicenow = value
	case "ticketing_torq":
		value := new(TicketingTorq)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.TicketingTorq = value
	case "vulnerabilities_crowdstrike":
		value := new(VulnerabilitiesCrowdStrike)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesCrowdstrike = value
	case "vulnerabilities_qualys_cloud":
		value := new(VulnerabilitiesQualysCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesQualysCloud = value
	case "vulnerabilities_rapid7_insight_cloud":
		value := new(VulnerabilitiesRapid7InsightCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesRapid7InsightCloud = value
	case "vulnerabilities_tanium_cloud":
		value := new(VulnerabilitiesTaniumCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesTaniumCloud = value
	case "vulnerabilities_tenable_cloud":
		value := new(VulnerabilitiesTenableCloud)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.VulnerabilitiesTenableCloud = value
	}
	return nil
}

func (p ProviderConfig) MarshalJSON() ([]byte, error) {
	if p.AssetsArmisCentrix != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsArmisCentrix, "type", "assets_armis_centrix")
	}
	if p.AssetsNozomiVantage != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsNozomiVantage, "type", "assets_nozomi_vantage")
	}
	if p.AssetsServicenow != nil {
		return core.MarshalJSONWithExtraProperty(p.AssetsServicenow, "type", "assets_servicenow")
	}
	if p.EdrCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrCrowdstrike, "type", "edr_crowdstrike")
	}
	if p.EdrDefender != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrDefender, "type", "edr_defender")
	}
	if p.EdrSentinelone != nil {
		return core.MarshalJSONWithExtraProperty(p.EdrSentinelone, "type", "edr_sentinelone")
	}
	if p.HooksHttp != nil {
		return core.MarshalJSONWithExtraProperty(p.HooksHttp, "type", "hooks_http")
	}
	if p.IdentityEntraId != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityEntraId, "type", "identity_entra_id")
	}
	if p.IdentityOkta != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityOkta, "type", "identity_okta")
	}
	if p.IdentityPingone != nil {
		return core.MarshalJSONWithExtraProperty(p.IdentityPingone, "type", "identity_pingone")
	}
	if p.NotificationsJira != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsJira, "type", "notifications_jira")
	}
	if p.NotificationsMockNotifications != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsMockNotifications, "type", "notifications_mock_notifications")
	}
	if p.NotificationsSlack != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsSlack, "type", "notifications_slack")
	}
	if p.NotificationsTeams != nil {
		return core.MarshalJSONWithExtraProperty(p.NotificationsTeams, "type", "notifications_teams")
	}
	if p.SiemElasticsearch != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemElasticsearch, "type", "siem_elasticsearch")
	}
	if p.SiemMockSiem != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemMockSiem, "type", "siem_mock_siem")
	}
	if p.SiemQRadar != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemQRadar, "type", "siem_q_radar")
	}
	if p.SiemRapid7Insightidr != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemRapid7Insightidr, "type", "siem_rapid7_insightidr")
	}
	if p.SiemSplunk != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemSplunk, "type", "siem_splunk")
	}
	if p.SiemSumoLogic != nil {
		return core.MarshalJSONWithExtraProperty(p.SiemSumoLogic, "type", "siem_sumo_logic")
	}
	if p.SinkAwsSecurityLake != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAwsSecurityLake, "type", "sink_aws_security_lake")
	}
	if p.SinkAwsSqs != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAwsSqs, "type", "sink_aws_sqs")
	}
	if p.SinkAzureMonitorLogs != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkAzureMonitorLogs, "type", "sink_azure_monitor_logs")
	}
	if p.SinkMockSink != nil {
		return core.MarshalJSONWithExtraProperty(p.SinkMockSink, "type", "sink_mock_sink")
	}
	if p.StorageAwsS3 != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageAwsS3, "type", "storage_aws_s3")
	}
	if p.StorageAzureBlob != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageAzureBlob, "type", "storage_azure_blob")
	}
	if p.StorageGcs != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageGcs, "type", "storage_gcs")
	}
	if p.StorageMockStorage != nil {
		return core.MarshalJSONWithExtraProperty(p.StorageMockStorage, "type", "storage_mock_storage")
	}
	if p.TicketingJira != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingJira, "type", "ticketing_jira")
	}
	if p.TicketingMockTicketing != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingMockTicketing, "type", "ticketing_mock_ticketing")
	}
	if p.TicketingPagerduty != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingPagerduty, "type", "ticketing_pagerduty")
	}
	if p.TicketingServicenow != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingServicenow, "type", "ticketing_servicenow")
	}
	if p.TicketingTorq != nil {
		return core.MarshalJSONWithExtraProperty(p.TicketingTorq, "type", "ticketing_torq")
	}
	if p.VulnerabilitiesCrowdstrike != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesCrowdstrike, "type", "vulnerabilities_crowdstrike")
	}
	if p.VulnerabilitiesQualysCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesQualysCloud, "type", "vulnerabilities_qualys_cloud")
	}
	if p.VulnerabilitiesRapid7InsightCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesRapid7InsightCloud, "type", "vulnerabilities_rapid7_insight_cloud")
	}
	if p.VulnerabilitiesTaniumCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesTaniumCloud, "type", "vulnerabilities_tanium_cloud")
	}
	if p.VulnerabilitiesTenableCloud != nil {
		return core.MarshalJSONWithExtraProperty(p.VulnerabilitiesTenableCloud, "type", "vulnerabilities_tenable_cloud")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type ProviderConfigVisitor interface {
	VisitAssetsArmisCentrix(*AssetsArmisCentrix) error
	VisitAssetsNozomiVantage(*AssetsNozomiVantage) error
	VisitAssetsServicenow(*AssetsServiceNow) error
	VisitEdrCrowdstrike(*EdrCrowdStrike) error
	VisitEdrDefender(*EdrDefender) error
	VisitEdrSentinelone(*EdrSentinelOne) error
	VisitHooksHttp(*HooksHttp) error
	VisitIdentityEntraId(*IdentityEntraId) error
	VisitIdentityOkta(*IdentityOkta) error
	VisitIdentityPingone(*IdentityPingOne) error
	VisitNotificationsJira(*NotificationsJira) error
	VisitNotificationsMockNotifications(*NotificationsMock) error
	VisitNotificationsSlack(*NotificationsSlack) error
	VisitNotificationsTeams(*NotificationsTeams) error
	VisitSiemElasticsearch(*SiemElasticsearch) error
	VisitSiemMockSiem(*SiemMock) error
	VisitSiemQRadar(*SiemQRadar) error
	VisitSiemRapid7Insightidr(*SiemRapid7InsightIdr) error
	VisitSiemSplunk(*SiemSplunk) error
	VisitSiemSumoLogic(*SiemSumoLogic) error
	VisitSinkAwsSecurityLake(*SinkAwsSecurityLake) error
	VisitSinkAwsSqs(*SinkAwsSqs) error
	VisitSinkAzureMonitorLogs(*SinkAzureMonitorLogs) error
	VisitSinkMockSink(*SinkMock) error
	VisitStorageAwsS3(*StorageAwsS3) error
	VisitStorageAzureBlob(*StorageAzureBlob) error
	VisitStorageGcs(*StorageGcs) error
	VisitStorageMockStorage(*StorageMock) error
	VisitTicketingJira(*TicketingJira) error
	VisitTicketingMockTicketing(*TicketingMock) error
	VisitTicketingPagerduty(*TicketingPagerDuty) error
	VisitTicketingServicenow(*TicketingServiceNow) error
	VisitTicketingTorq(*TicketingTorq) error
	VisitVulnerabilitiesCrowdstrike(*VulnerabilitiesCrowdStrike) error
	VisitVulnerabilitiesQualysCloud(*VulnerabilitiesQualysCloud) error
	VisitVulnerabilitiesRapid7InsightCloud(*VulnerabilitiesRapid7InsightCloud) error
	VisitVulnerabilitiesTaniumCloud(*VulnerabilitiesTaniumCloud) error
	VisitVulnerabilitiesTenableCloud(*VulnerabilitiesTenableCloud) error
}

func (p *ProviderConfig) Accept(visitor ProviderConfigVisitor) error {
	if p.AssetsArmisCentrix != nil {
		return visitor.VisitAssetsArmisCentrix(p.AssetsArmisCentrix)
	}
	if p.AssetsNozomiVantage != nil {
		return visitor.VisitAssetsNozomiVantage(p.AssetsNozomiVantage)
	}
	if p.AssetsServicenow != nil {
		return visitor.VisitAssetsServicenow(p.AssetsServicenow)
	}
	if p.EdrCrowdstrike != nil {
		return visitor.VisitEdrCrowdstrike(p.EdrCrowdstrike)
	}
	if p.EdrDefender != nil {
		return visitor.VisitEdrDefender(p.EdrDefender)
	}
	if p.EdrSentinelone != nil {
		return visitor.VisitEdrSentinelone(p.EdrSentinelone)
	}
	if p.HooksHttp != nil {
		return visitor.VisitHooksHttp(p.HooksHttp)
	}
	if p.IdentityEntraId != nil {
		return visitor.VisitIdentityEntraId(p.IdentityEntraId)
	}
	if p.IdentityOkta != nil {
		return visitor.VisitIdentityOkta(p.IdentityOkta)
	}
	if p.IdentityPingone != nil {
		return visitor.VisitIdentityPingone(p.IdentityPingone)
	}
	if p.NotificationsJira != nil {
		return visitor.VisitNotificationsJira(p.NotificationsJira)
	}
	if p.NotificationsMockNotifications != nil {
		return visitor.VisitNotificationsMockNotifications(p.NotificationsMockNotifications)
	}
	if p.NotificationsSlack != nil {
		return visitor.VisitNotificationsSlack(p.NotificationsSlack)
	}
	if p.NotificationsTeams != nil {
		return visitor.VisitNotificationsTeams(p.NotificationsTeams)
	}
	if p.SiemElasticsearch != nil {
		return visitor.VisitSiemElasticsearch(p.SiemElasticsearch)
	}
	if p.SiemMockSiem != nil {
		return visitor.VisitSiemMockSiem(p.SiemMockSiem)
	}
	if p.SiemQRadar != nil {
		return visitor.VisitSiemQRadar(p.SiemQRadar)
	}
	if p.SiemRapid7Insightidr != nil {
		return visitor.VisitSiemRapid7Insightidr(p.SiemRapid7Insightidr)
	}
	if p.SiemSplunk != nil {
		return visitor.VisitSiemSplunk(p.SiemSplunk)
	}
	if p.SiemSumoLogic != nil {
		return visitor.VisitSiemSumoLogic(p.SiemSumoLogic)
	}
	if p.SinkAwsSecurityLake != nil {
		return visitor.VisitSinkAwsSecurityLake(p.SinkAwsSecurityLake)
	}
	if p.SinkAwsSqs != nil {
		return visitor.VisitSinkAwsSqs(p.SinkAwsSqs)
	}
	if p.SinkAzureMonitorLogs != nil {
		return visitor.VisitSinkAzureMonitorLogs(p.SinkAzureMonitorLogs)
	}
	if p.SinkMockSink != nil {
		return visitor.VisitSinkMockSink(p.SinkMockSink)
	}
	if p.StorageAwsS3 != nil {
		return visitor.VisitStorageAwsS3(p.StorageAwsS3)
	}
	if p.StorageAzureBlob != nil {
		return visitor.VisitStorageAzureBlob(p.StorageAzureBlob)
	}
	if p.StorageGcs != nil {
		return visitor.VisitStorageGcs(p.StorageGcs)
	}
	if p.StorageMockStorage != nil {
		return visitor.VisitStorageMockStorage(p.StorageMockStorage)
	}
	if p.TicketingJira != nil {
		return visitor.VisitTicketingJira(p.TicketingJira)
	}
	if p.TicketingMockTicketing != nil {
		return visitor.VisitTicketingMockTicketing(p.TicketingMockTicketing)
	}
	if p.TicketingPagerduty != nil {
		return visitor.VisitTicketingPagerduty(p.TicketingPagerduty)
	}
	if p.TicketingServicenow != nil {
		return visitor.VisitTicketingServicenow(p.TicketingServicenow)
	}
	if p.TicketingTorq != nil {
		return visitor.VisitTicketingTorq(p.TicketingTorq)
	}
	if p.VulnerabilitiesCrowdstrike != nil {
		return visitor.VisitVulnerabilitiesCrowdstrike(p.VulnerabilitiesCrowdstrike)
	}
	if p.VulnerabilitiesQualysCloud != nil {
		return visitor.VisitVulnerabilitiesQualysCloud(p.VulnerabilitiesQualysCloud)
	}
	if p.VulnerabilitiesRapid7InsightCloud != nil {
		return visitor.VisitVulnerabilitiesRapid7InsightCloud(p.VulnerabilitiesRapid7InsightCloud)
	}
	if p.VulnerabilitiesTaniumCloud != nil {
		return visitor.VisitVulnerabilitiesTaniumCloud(p.VulnerabilitiesTaniumCloud)
	}
	if p.VulnerabilitiesTenableCloud != nil {
		return visitor.VisitVulnerabilitiesTenableCloud(p.VulnerabilitiesTenableCloud)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

// List of supported providers.
type ProviderConfigId string

const (
	// Armis Centrix™ for Asset Management and Security
	ProviderConfigIdAssetsArmisCentrix ProviderConfigId = "assets_armis_centrix"
	// Nozomi Vantage
	ProviderConfigIdAssetsNozomiVantage ProviderConfigId = "assets_nozomi_vantage"
	// ServiceNow Configuration Management Database (CMDB)
	ProviderConfigIdAssetsServiceNow ProviderConfigId = "assets_servicenow"
	// CrowdStrike Falcon® Insight EDR
	ProviderConfigIdEdrCrowdStrike ProviderConfigId = "edr_crowdstrike"
	// Microsoft Defender for Endpoint
	ProviderConfigIdEdrDefender ProviderConfigId = "edr_defender"
	// SentinelOne Singularity™ Endpoint
	ProviderConfigIdEdrSentinelOne ProviderConfigId = "edr_sentinelone"
	// HTTP Webhook
	ProviderConfigIdHooksHttp ProviderConfigId = "hooks_http"
	// Microsoft Entra ID
	ProviderConfigIdIdentityEntraId ProviderConfigId = "identity_entra_id"
	// Okta Identity
	ProviderConfigIdIdentityOkta ProviderConfigId = "identity_okta"
	// PingOne Cloud Platform
	ProviderConfigIdIdentityPingOne ProviderConfigId = "identity_pingone"
	// Atlassian Jira
	ProviderConfigIdNotificationsJira ProviderConfigId = "notifications_jira"
	// Notifications Test
	ProviderConfigIdNotificationsMock ProviderConfigId = "notifications_mock_notifications"
	// Slack
	ProviderConfigIdNotificationsSlack ProviderConfigId = "notifications_slack"
	// Microsoft Teams
	ProviderConfigIdNotificationsTeams ProviderConfigId = "notifications_teams"
	// Elastic SIEM
	ProviderConfigIdSiemElasticsearch ProviderConfigId = "siem_elasticsearch"
	// SIEM Test
	ProviderConfigIdSiemMock ProviderConfigId = "siem_mock_siem"
	// QRadar
	ProviderConfigIdSiemQRadar ProviderConfigId = "siem_q_radar"
	// Rapid7 InsightIDR
	ProviderConfigIdSiemRapid7InsightIdr ProviderConfigId = "siem_rapid7_insightidr"
	// Splunk Enterprise Security
	ProviderConfigIdSiemSplunk ProviderConfigId = "siem_splunk"
	// Sumo Logic Cloud SIEM
	ProviderConfigIdSiemSumoLogic ProviderConfigId = "siem_sumo_logic"
	// AWS Security Lake
	ProviderConfigIdSinkAwsSecurityLake ProviderConfigId = "sink_aws_security_lake"
	// AWS Simple Queue Service
	ProviderConfigIdSinkAwsSqs ProviderConfigId = "sink_aws_sqs"
	// Microsoft Azure Monitor Logs
	ProviderConfigIdSinkAzureMonitorLogs ProviderConfigId = "sink_azure_monitor_logs"
	// Sink Test
	ProviderConfigIdSinkMock ProviderConfigId = "sink_mock_sink"
	// AWS S3
	ProviderConfigIdStorageAwsS3 ProviderConfigId = "storage_aws_s3"
	// Microsoft Azure Blob Storage
	ProviderConfigIdStorageAzureBlob ProviderConfigId = "storage_azure_blob"
	// Google Cloud Storage
	ProviderConfigIdStorageGcs ProviderConfigId = "storage_gcs"
	// Storage Test
	ProviderConfigIdStorageMock ProviderConfigId = "storage_mock_storage"
	// Atlassian Jira
	ProviderConfigIdTicketingJira ProviderConfigId = "ticketing_jira"
	// Ticketing Test
	ProviderConfigIdTicketingMock ProviderConfigId = "ticketing_mock_ticketing"
	// PagerDuty Operations Cloud
	ProviderConfigIdTicketingPagerDuty ProviderConfigId = "ticketing_pagerduty"
	// ServiceNow IT Service Management (ITSM)
	ProviderConfigIdTicketingServiceNow ProviderConfigId = "ticketing_servicenow"
	// Torq
	ProviderConfigIdTicketingTorq ProviderConfigId = "ticketing_torq"
	// CrowdStrike Falcon Spotlight
	ProviderConfigIdVulnerabilitiesCrowdStrike ProviderConfigId = "vulnerabilities_crowdstrike"
	// Qualys Vulnerability Management, Detection & Response (VMDR)
	ProviderConfigIdVulnerabilitiesQualysCloud ProviderConfigId = "vulnerabilities_qualys_cloud"
	// Rapid7 Insight Vulnerability Management Cloud
	ProviderConfigIdVulnerabilitiesRapid7InsightCloud ProviderConfigId = "vulnerabilities_rapid7_insight_cloud"
	// Tanium Vulnerability Management
	ProviderConfigIdVulnerabilitiesTaniumCloud ProviderConfigId = "vulnerabilities_tanium_cloud"
	// Tenable Vulnerability Management
	ProviderConfigIdVulnerabilitiesTenableCloud ProviderConfigId = "vulnerabilities_tenable_cloud"
	// Any provider config type.
	ProviderConfigIdAll ProviderConfigId = "*"
)

func NewProviderConfigIdFromString(s string) (ProviderConfigId, error) {
	switch s {
	case "assets_armis_centrix":
		return ProviderConfigIdAssetsArmisCentrix, nil
	case "assets_nozomi_vantage":
		return ProviderConfigIdAssetsNozomiVantage, nil
	case "assets_servicenow":
		return ProviderConfigIdAssetsServiceNow, nil
	case "edr_crowdstrike":
		return ProviderConfigIdEdrCrowdStrike, nil
	case "edr_defender":
		return ProviderConfigIdEdrDefender, nil
	case "edr_sentinelone":
		return ProviderConfigIdEdrSentinelOne, nil
	case "hooks_http":
		return ProviderConfigIdHooksHttp, nil
	case "identity_entra_id":
		return ProviderConfigIdIdentityEntraId, nil
	case "identity_okta":
		return ProviderConfigIdIdentityOkta, nil
	case "identity_pingone":
		return ProviderConfigIdIdentityPingOne, nil
	case "notifications_jira":
		return ProviderConfigIdNotificationsJira, nil
	case "notifications_mock_notifications":
		return ProviderConfigIdNotificationsMock, nil
	case "notifications_slack":
		return ProviderConfigIdNotificationsSlack, nil
	case "notifications_teams":
		return ProviderConfigIdNotificationsTeams, nil
	case "siem_elasticsearch":
		return ProviderConfigIdSiemElasticsearch, nil
	case "siem_mock_siem":
		return ProviderConfigIdSiemMock, nil
	case "siem_q_radar":
		return ProviderConfigIdSiemQRadar, nil
	case "siem_rapid7_insightidr":
		return ProviderConfigIdSiemRapid7InsightIdr, nil
	case "siem_splunk":
		return ProviderConfigIdSiemSplunk, nil
	case "siem_sumo_logic":
		return ProviderConfigIdSiemSumoLogic, nil
	case "sink_aws_security_lake":
		return ProviderConfigIdSinkAwsSecurityLake, nil
	case "sink_aws_sqs":
		return ProviderConfigIdSinkAwsSqs, nil
	case "sink_azure_monitor_logs":
		return ProviderConfigIdSinkAzureMonitorLogs, nil
	case "sink_mock_sink":
		return ProviderConfigIdSinkMock, nil
	case "storage_aws_s3":
		return ProviderConfigIdStorageAwsS3, nil
	case "storage_azure_blob":
		return ProviderConfigIdStorageAzureBlob, nil
	case "storage_gcs":
		return ProviderConfigIdStorageGcs, nil
	case "storage_mock_storage":
		return ProviderConfigIdStorageMock, nil
	case "ticketing_jira":
		return ProviderConfigIdTicketingJira, nil
	case "ticketing_mock_ticketing":
		return ProviderConfigIdTicketingMock, nil
	case "ticketing_pagerduty":
		return ProviderConfigIdTicketingPagerDuty, nil
	case "ticketing_servicenow":
		return ProviderConfigIdTicketingServiceNow, nil
	case "ticketing_torq":
		return ProviderConfigIdTicketingTorq, nil
	case "vulnerabilities_crowdstrike":
		return ProviderConfigIdVulnerabilitiesCrowdStrike, nil
	case "vulnerabilities_qualys_cloud":
		return ProviderConfigIdVulnerabilitiesQualysCloud, nil
	case "vulnerabilities_rapid7_insight_cloud":
		return ProviderConfigIdVulnerabilitiesRapid7InsightCloud, nil
	case "vulnerabilities_tanium_cloud":
		return ProviderConfigIdVulnerabilitiesTaniumCloud, nil
	case "vulnerabilities_tenable_cloud":
		return ProviderConfigIdVulnerabilitiesTenableCloud, nil
	case "*":
		return ProviderConfigIdAll, nil
	}
	var t ProviderConfigId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProviderConfigId) Ptr() *ProviderConfigId {
	return &p
}

type QRadarCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (q *QRadarCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	q.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", q)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		q.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		q.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (q QRadarCredential) MarshalJSON() ([]byte, error) {
	if q.Token != nil {
		return core.MarshalJSONWithExtraProperty(q.Token, "type", "token")
	}
	if q.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: q.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QRadarCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (q *QRadarCredential) Accept(visitor QRadarCredentialVisitor) error {
	if q.Token != nil {
		return visitor.VisitToken(q.Token)
	}
	if q.TokenId != "" {
		return visitor.VisitTokenId(q.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QualysCloudCredential struct {
	Type    string
	Basic   *BasicCredential
	BasicId BasicCredentialId
}

func (q *QualysCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	q.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", q)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		q.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		q.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (q QualysCloudCredential) MarshalJSON() ([]byte, error) {
	if q.Basic != nil {
		return core.MarshalJSONWithExtraProperty(q.Basic, "type", "basic")
	}
	if q.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: q.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", q)
}

type QualysCloudCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (q *QualysCloudCredential) Accept(visitor QualysCloudCredentialVisitor) error {
	if q.Basic != nil {
		return visitor.VisitBasic(q.Basic)
	}
	if q.BasicId != "" {
		return visitor.VisitBasicId(q.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", q)
}

type Rapid7InsightCloudCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (r *Rapid7InsightCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		r.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (r Rapid7InsightCloudCredential) MarshalJSON() ([]byte, error) {
	if r.Token != nil {
		return core.MarshalJSONWithExtraProperty(r.Token, "type", "token")
	}
	if r.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: r.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type Rapid7InsightCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (r *Rapid7InsightCloudCredential) Accept(visitor Rapid7InsightCloudCredentialVisitor) error {
	if r.Token != nil {
		return visitor.VisitToken(r.Token)
	}
	if r.TokenId != "" {
		return visitor.VisitTokenId(r.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

// Configuration for Elasticsearch search and analytics engine. Supports both managed and self-hosted Elasticsearch deployments
type SiemElasticsearch struct {
	AuthOptions *ElasticsearchAuthOptions `json:"auth_options,omitempty" url:"auth_options,omitempty"`
	Credential  *ElasticsearchCredential  `json:"credential" url:"credential"`
	// Elasticsearch index to send events to.
	Index string `json:"index" url:"index"`
	// URL for the Elasticsearch API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.elastic.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemElasticsearch) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemElasticsearch) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemElasticsearch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemElasticsearch(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SiemElasticsearch) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory SIEM handler. This provider is for testing purposes only and does not retain events pushed to it.
type SiemMock struct {
	// Name of the index where events are stored.
	Index *string `json:"index,omitempty" url:"index,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemMock) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SiemMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for IBM QRadar as a SIEM Provider.
type SiemQRadar struct {
	// The QRadar HTTP Receiver URL, stored as a secret. This URL has a special port in QRadar and is stored in a credential to protect that information. See https://www.youtube.com/watch?v=UEBLVVNpyfg for a demonstration of setting up and mapping and HTTP Receiver in QRadar.
	CollectionPort int               `json:"collection_port" url:"collection_port"`
	Credential     *QRadarCredential `json:"credential" url:"credential"`
	// If true, skips verification of the QRadar server's TLS certificate. Defaults to false.
	SkipTlsVerify bool `json:"skip_tls_verify" url:"skip_tls_verify"`
	// URL for the QRadar instance. This should be the base URL instance, without any path components and must be HTTPS. For example, "https://qradar.westus2.cloudapp.azure.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemQRadar) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemQRadar) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemQRadar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemQRadar(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SiemQRadar) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Rapid7 InsightIDR as a SIEM Provider.
type SiemRapid7InsightIdr struct {
	Credential *Rapid7InsightCloudCredential `json:"credential" url:"credential"`
	// URL for the Rapid7 API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://us2.api.insight.rapid7.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemRapid7InsightIdr) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemRapid7InsightIdr) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemRapid7InsightIdr
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemRapid7InsightIdr(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SiemRapid7InsightIdr) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Splunk as a SIEM Provider. This integration allows sending data to Splunk using an HTTP Event Collector (HEC). Additionally, it can be used to query Splunk using the Splunk Search Service.
type SiemSplunk struct {
	HecCredential *SplunkHecToken `json:"hec_credential" url:"hec_credential"`
	// URL for the Splunk HEC endpoint. This must include the full path to the HEC endpoint. For example, "https://tenant.cloud.splunk.com:8088/services_collector_event".
	HecUrl string `json:"hec_url" url:"hec_url"`
	// Splunk index to send events to. If not provided, will use the default index for the Splunk collector.
	Index *string `json:"index,omitempty" url:"index,omitempty"`
	// Optional id of a credential used for connecting to the Splunk search service. If not provided, querying is disabled.
	SearchServiceCredential *SplunkSearchCredential `json:"search_service_credential,omitempty" url:"search_service_credential,omitempty"`
	// Optional URL used for connecting to the Splunk search service. If not provided, querying is disabled.
	SearchServiceUrl *string `json:"search_service_url,omitempty" url:"search_service_url,omitempty"`
	// If true, skips verification of the Splunk server's TLS certificate. Defaults to false.
	SkipTlsVerify bool `json:"skip_tls_verify" url:"skip_tls_verify"`
	// Splunk source to send events to. If not provided, will use the default source for the Splunk collector.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// Splunk source type to send events to. If not provided, will use the default source type for the Splunk collector.
	SourceType *string `json:"source_type,omitempty" url:"source_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemSplunk) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemSplunk) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemSplunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemSplunk(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SiemSplunk) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Sumo Logic Cloud SIEM.
type SiemSumoLogic struct {
	// Automatically parse logs as JSON when running log queries against Sumo Logic. Default is true.
	AutoParseLogs *bool `json:"auto_parse_logs,omitempty" url:"auto_parse_logs,omitempty"`
	// Required if you need to send Sumo Logic events from the Synqly API.
	CollectionUrl *SumoLogicCollectionUrl `json:"collection_url,omitempty" url:"collection_url,omitempty"`
	Credential    *SumoLogicCredential    `json:"credential" url:"credential"`
	// Only query for logs that have been processed into the Sumo Logic Cloud SIEM app. Default is false.
	SiemLogsOnly *bool `json:"siem_logs_only,omitempty" url:"siem_logs_only,omitempty"`
	// Your Sumo Logic API endpoint. See https://help.sumologic.com/docs/api/getting-started/#sumo-logic-endpoints-by-deployment-and-firewall-security for help determining which base URL to use.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SiemSumoLogic) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SiemSumoLogic) UnmarshalJSON(data []byte) error {
	type unmarshaler SiemSumoLogic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SiemSumoLogic(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SiemSumoLogic) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SentinelOneCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (s *SentinelOneCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SentinelOneCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SentinelOneCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SentinelOneCredential) Accept(visitor SentinelOneCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type ServiceNowCredential struct {
	Type    string
	Basic   *BasicCredential
	BasicId BasicCredentialId
}

func (s *ServiceNowCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (s ServiceNowCredential) MarshalJSON() ([]byte, error) {
	if s.Basic != nil {
		return core.MarshalJSONWithExtraProperty(s.Basic, "type", "basic")
	}
	if s.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: s.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type ServiceNowCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (s *ServiceNowCredential) Accept(visitor ServiceNowCredentialVisitor) error {
	if s.Basic != nil {
		return visitor.VisitBasic(s.Basic)
	}
	if s.BasicId != "" {
		return visitor.VisitBasicId(s.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// Configuration for AWS Simple Queue Service (SQS) as a Sink Provider.
type SinkAwsSqs struct {
	// Credential ID that stores AWS authentication key and secret. This token pair must have write access to the configured SQS queue
	Credential *AwsSqsCredential `json:"credential" url:"credential"`
	// Override the default AWS region for this integration. If not present, the region will be inferred from the URL.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// URL of the SQS queue where events are sent. Must be in the format `https://sqs.{region}.amazonaws.com_{account_id}/{queue_name}`.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAwsSqs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAwsSqs) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAwsSqs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAwsSqs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SinkAwsSqs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for AWS Security Lake provider. Events are written directly to an AWS S3 bucket in Apache Parquet format.
type SinkAwsSecurityLake struct {
	Credential *AwsSecurityLakeCredential `json:"credential" url:"credential"`
	// Override the default AWS region for this integration. If not present, the region will be inferred from the URL.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// URL of the S3 bucket where the AWS Security Lake events are stored.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAwsSecurityLake) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAwsSecurityLake) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAwsSecurityLake
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAwsSecurityLake(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SinkAwsSecurityLake) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Azure Monitor Logs as a Sink Provider. Azure Monitor Logs is a feature of Azure Monitor that collects and organizes log and performance data from monitored resources.
type SinkAzureMonitorLogs struct {
	// Azure Client (Application) ID.
	ClientId   string                      `json:"client_id" url:"client_id"`
	Credential *AzureMonitorLogsCredential `json:"credential" url:"credential"`
	// Data collection rule immutable ID.
	RuleId string `json:"rule_id" url:"rule_id"`
	// Name of the Data collection rule stream.
	StreamName string `json:"stream_name" url:"stream_name"`
	// Azure Directory (tenant) ID.
	TenantId string `json:"tenant_id" url:"tenant_id"`
	// URL of the Azure data collection endpoint.
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkAzureMonitorLogs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkAzureMonitorLogs) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkAzureMonitorLogs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkAzureMonitorLogs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SinkAzureMonitorLogs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory sink handler. This provider is for testing purposes only and does not retain events pushed to it.
type SinkMock struct {
	// Name of the destination where events are stored. This property is unused.
	Destination *string `json:"destination,omitempty" url:"destination,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SinkMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SinkMock) UnmarshalJSON(data []byte) error {
	type unmarshaler SinkMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SinkMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SinkMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SlackCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (s *SlackCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SlackCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SlackCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SlackCredential) Accept(visitor SlackCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkHecToken struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (s *SplunkHecToken) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SplunkHecToken) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkHecTokenVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SplunkHecToken) Accept(visitor SplunkHecTokenVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkSearchCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (s *SplunkSearchCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (s SplunkSearchCredential) MarshalJSON() ([]byte, error) {
	if s.Token != nil {
		return core.MarshalJSONWithExtraProperty(s.Token, "type", "token")
	}
	if s.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: s.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SplunkSearchCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (s *SplunkSearchCredential) Accept(visitor SplunkSearchCredentialVisitor) error {
	if s.Token != nil {
		return visitor.VisitToken(s.Token)
	}
	if s.TokenId != "" {
		return visitor.VisitTokenId(s.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type StatusMapping struct {
	// Custom value for the "Closed" status.
	Closed *string `json:"closed,omitempty" url:"closed,omitempty"`
	// Custom value for the "Done" status.
	Done *string `json:"done,omitempty" url:"done,omitempty"`
	// Custom value for the "In Progress" status.
	InProgress *string `json:"in_progress,omitempty" url:"in_progress,omitempty"`
	// Custom value for the "On Hold" status.
	OnHold *string `json:"on_hold,omitempty" url:"on_hold,omitempty"`
	// Custom value for the "Open" status.
	Open *string `json:"open,omitempty" url:"open,omitempty"`
	// Custom value for the "To Do" status.
	Todo *string `json:"todo,omitempty" url:"todo,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StatusMapping) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StatusMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler StatusMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StatusMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StatusMapping) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for AWS S3 as a Storage Provider
type StorageAwsS3 struct {
	// Name of the AWS S3 bucket where files are stored.
	Bucket     string           `json:"bucket" url:"bucket"`
	Credential *AwsS3Credential `json:"credential" url:"credential"`
	// Endpoint used for connecting to the external service. If not provided, will connect to the default endpoint for the Provider.
	Endpoint *string `json:"endpoint,omitempty" url:"endpoint,omitempty"`
	// AWS region where the S3 bucket is located.
	Region string `json:"region" url:"region"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty" url:"transforms,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageAwsS3) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageAwsS3) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageAwsS3
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageAwsS3(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StorageAwsS3) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Azure Blob Storage as a Storage Provider
type StorageAzureBlob struct {
	// Name of the blob container where files are stored.
	Bucket     string               `json:"bucket" url:"bucket"`
	Credential *AzureBlobCredential `json:"credential" url:"credential"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty" url:"transforms,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageAzureBlob) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageAzureBlob) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageAzureBlob
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageAzureBlob(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StorageAzureBlob) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for Google Cloud Storage for storing unstructured data
type StorageGcs struct {
	// Name of the bucket where files are stored.
	Bucket     string         `json:"bucket" url:"bucket"`
	Credential *GcsCredential `json:"credential" url:"credential"`
	// Google Cloud region where the bucket is located.
	Region string `json:"region" url:"region"`
	// Optional list of transformations used to modify requests before they are sent to the external service.
	Transforms []TransformId `json:"transforms,omitempty" url:"transforms,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageGcs) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageGcs) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageGcs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageGcs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StorageGcs) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for the Synqly mock in-memory storage handler. This provider is for testing purposes only and does not retain files pushed to it.
type StorageMock struct {
	// Name of the bucket where files are stored.
	Bucket string `json:"bucket" url:"bucket"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StorageMock) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StorageMock) UnmarshalJSON(data []byte) error {
	type unmarshaler StorageMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StorageMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StorageMock) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SumoLogicCollectionUrl struct {
	Type     string
	Secret   *SecretCredential
	SecretId SecretCredentialId
}

func (s *SumoLogicCollectionUrl) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (s SumoLogicCollectionUrl) MarshalJSON() ([]byte, error) {
	if s.Secret != nil {
		return core.MarshalJSONWithExtraProperty(s.Secret, "type", "secret")
	}
	if s.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: s.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCollectionUrlVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (s *SumoLogicCollectionUrl) Accept(visitor SumoLogicCollectionUrlVisitor) error {
	if s.Secret != nil {
		return visitor.VisitSecret(s.Secret)
	}
	if s.SecretId != "" {
		return visitor.VisitSecretId(s.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCredential struct {
	Type    string
	Basic   *BasicCredential
	BasicId BasicCredentialId
}

func (s *SumoLogicCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "basic":
		value := new(BasicCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Basic = value
	case "basic_id":
		var valueUnmarshaler struct {
			BasicId BasicCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		s.BasicId = valueUnmarshaler.BasicId
	}
	return nil
}

func (s SumoLogicCredential) MarshalJSON() ([]byte, error) {
	if s.Basic != nil {
		return core.MarshalJSONWithExtraProperty(s.Basic, "type", "basic")
	}
	if s.BasicId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			BasicId BasicCredentialId `json:"value"`
		}{
			Type:    "basic_id",
			BasicId: s.BasicId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SumoLogicCredentialVisitor interface {
	VisitBasic(*BasicCredential) error
	VisitBasicId(BasicCredentialId) error
}

func (s *SumoLogicCredential) Accept(visitor SumoLogicCredentialVisitor) error {
	if s.Basic != nil {
		return visitor.VisitBasic(s.Basic)
	}
	if s.BasicId != "" {
		return visitor.VisitBasicId(s.BasicId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// Supported credential types for Tanium Cloud
type TaniumCloudCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (t *TaniumCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (t TaniumCloudCredential) MarshalJSON() ([]byte, error) {
	if t.Token != nil {
		return core.MarshalJSONWithExtraProperty(t.Token, "type", "token")
	}
	if t.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: t.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TaniumCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (t *TaniumCloudCredential) Accept(visitor TaniumCloudCredentialVisitor) error {
	if t.Token != nil {
		return visitor.VisitToken(t.Token)
	}
	if t.TokenId != "" {
		return visitor.VisitTokenId(t.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TeamsCredential struct {
	Type     string
	Secret   *SecretCredential
	SecretId SecretCredentialId
}

func (t *TeamsCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "secret":
		value := new(SecretCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Secret = value
	case "secret_id":
		var valueUnmarshaler struct {
			SecretId SecretCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.SecretId = valueUnmarshaler.SecretId
	}
	return nil
}

func (t TeamsCredential) MarshalJSON() ([]byte, error) {
	if t.Secret != nil {
		return core.MarshalJSONWithExtraProperty(t.Secret, "type", "secret")
	}
	if t.SecretId != "" {
		var marshaler = struct {
			Type     string             `json:"type"`
			SecretId SecretCredentialId `json:"value"`
		}{
			Type:     "secret_id",
			SecretId: t.SecretId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TeamsCredentialVisitor interface {
	VisitSecret(*SecretCredential) error
	VisitSecretId(SecretCredentialId) error
}

func (t *TeamsCredential) Accept(visitor TeamsCredentialVisitor) error {
	if t.Secret != nil {
		return visitor.VisitSecret(t.Secret)
	}
	if t.SecretId != "" {
		return visitor.VisitSecretId(t.SecretId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

// Supported credential types for Tenable Cloud
type TenableCloudCredential struct {
	Type    string
	Token   *TokenCredential
	TokenId TokenCredentialId
}

func (t *TenableCloudCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "token":
		value := new(TokenCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Token = value
	case "token_id":
		var valueUnmarshaler struct {
			TokenId TokenCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.TokenId = valueUnmarshaler.TokenId
	}
	return nil
}

func (t TenableCloudCredential) MarshalJSON() ([]byte, error) {
	if t.Token != nil {
		return core.MarshalJSONWithExtraProperty(t.Token, "type", "token")
	}
	if t.TokenId != "" {
		var marshaler = struct {
			Type    string            `json:"type"`
			TokenId TokenCredentialId `json:"value"`
		}{
			Type:    "token_id",
			TokenId: t.TokenId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TenableCloudCredentialVisitor interface {
	VisitToken(*TokenCredential) error
	VisitTokenId(TokenCredentialId) error
}

func (t *TenableCloudCredential) Accept(visitor TenableCloudCredentialVisitor) error {
	if t.Token != nil {
		return visitor.VisitToken(t.Token)
	}
	if t.TokenId != "" {
		return visitor.VisitTokenId(t.TokenId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

// Configuration for Jira as a Ticketing Provider
type TicketingJira struct {
	Credential *JiraCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Default Project for the integration.
	DefaultProject *string `json:"default_project,omitempty" url:"default_project,omitempty"`
	// URL for the Jira API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.atlassian.net".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingJira) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingJira) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingJira
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingJira(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TicketingJira) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for the Synqly mock in-memory ticketing handler. This provider is for testing purposes only. It retains tickets for a limited time and does not persist them for long-term usage.
type TicketingMock struct {
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Optional name of the mock provider. This value is unused.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingMock) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingMock) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingMock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingMock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TicketingMock) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for PagerDuty as a Ticketing Provider
type TicketingPagerDuty struct {
	Credential *PagerDutyCredential `json:"credential" url:"credential"`
	// URL for the PagerDuty API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://api.pagerduty.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingPagerDuty) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingPagerDuty) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingPagerDuty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingPagerDuty(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TicketingPagerDuty) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for ServiceNow as a Ticketing Provider
type TicketingServiceNow struct {
	Credential *ServiceNowCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`
	// Default Project for the integration. This maps to the custom table for tickets. This table should be derived from Incident table. If not provided, defaults to the incident table.
	DefaultProject *string `json:"default_project,omitempty" url:"default_project,omitempty"`
	// URL for the ServiceNow API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://tenant.service-now.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingServiceNow) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingServiceNow) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingServiceNow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingServiceNow(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TicketingServiceNow) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Configuration for Torq as a Ticketing Provider
type TicketingTorq struct {
	Credential *TorqCredential `json:"credential" url:"credential"`
	// Custom field mappings for this provider.
	CustomFieldMappings []*CustomFieldMapping `json:"custom_field_mappings,omitempty" url:"custom_field_mappings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingTorq) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingTorq) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingTorq
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingTorq(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TicketingTorq) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TorqCredential struct {
	Type          string
	OAuthClient   *OAuthClientCredential
	OAuthClientId OAuthClientCredentialId
}

func (t *TorqCredential) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "o_auth_client":
		value := new(OAuthClientCredential)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OAuthClient = value
	case "o_auth_client_id":
		var valueUnmarshaler struct {
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		t.OAuthClientId = valueUnmarshaler.OAuthClientId
	}
	return nil
}

func (t TorqCredential) MarshalJSON() ([]byte, error) {
	if t.OAuthClient != nil {
		return core.MarshalJSONWithExtraProperty(t.OAuthClient, "type", "o_auth_client")
	}
	if t.OAuthClientId != "" {
		var marshaler = struct {
			Type          string                  `json:"type"`
			OAuthClientId OAuthClientCredentialId `json:"value"`
		}{
			Type:          "o_auth_client_id",
			OAuthClientId: t.OAuthClientId,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TorqCredentialVisitor interface {
	VisitOAuthClient(*OAuthClientCredential) error
	VisitOAuthClientId(OAuthClientCredentialId) error
}

func (t *TorqCredential) Accept(visitor TorqCredentialVisitor) error {
	if t.OAuthClient != nil {
		return visitor.VisitOAuthClient(t.OAuthClient)
	}
	if t.OAuthClientId != "" {
		return visitor.VisitOAuthClientId(t.OAuthClientId)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

type ValueMapping struct {
	// Optionally restrict this value mapping to a specific issue type. If not provided, the mapping will apply to all issue types.
	IssueType *string `json:"issue_type,omitempty" url:"issue_type,omitempty"`
	// Remap the standard Synqly priorities to custom values.
	Priority *PriorityMapping `json:"priority,omitempty" url:"priority,omitempty"`
	// ID of the project this value mapping is associated with. ID of "\*" is used to apply to all projects.
	ProjectId string `json:"project_id" url:"project_id"`
	// Remap the standard Synqly statuses to custom values.
	Status *StatusMapping `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *ValueMapping) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValueMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler ValueMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValueMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValueMapping) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for CrowdStrike Falcon as a Vulnerabilities Provider
type VulnerabilitiesCrowdStrike struct {
	Credential *CrowdStrikeCredential `json:"credential" url:"credential"`
	// The root domain where your CrowdStrike Falcon tenant is located. Default "https://api.crowdstrike.com".
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesCrowdStrike) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesCrowdStrike) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesCrowdStrike
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesCrowdStrike(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VulnerabilitiesCrowdStrike) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Qualys Cloud Platform as a Vulnerabilities Provider
type VulnerabilitiesQualysCloud struct {
	Credential *QualysCloudCredential `json:"credential" url:"credential"`
	// URL for the Qualys Cloud API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://qualysguard.qg4.apps.qualys.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesQualysCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesQualysCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesQualysCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesQualysCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VulnerabilitiesQualysCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Rapid7 Insight Cloud as a Vulnerabilities Provider
type VulnerabilitiesRapid7InsightCloud struct {
	Credential *Rapid7InsightCloudCredential `json:"credential" url:"credential"`
	// URL for the Rapid7 API. This should be the base URL for the API, without any path components and must be HTTPS. For example, "https://us2.api.insight.rapid7.com".
	Url string `json:"url" url:"url"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesRapid7InsightCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesRapid7InsightCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesRapid7InsightCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesRapid7InsightCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VulnerabilitiesRapid7InsightCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Tanium Cloud as a Vulnerabilities Provider
type VulnerabilitiesTaniumCloud struct {
	Credential *TaniumCloudCredential `json:"credential" url:"credential"`
	// URL for the Tanium Cloud API. This should be the base URL for the API, without any path components and must be HTTPS, e.g. "https://<customername>-api.cloud.tanium.com" or "https://<customername>-api.titankube.com".
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesTaniumCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesTaniumCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesTaniumCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesTaniumCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VulnerabilitiesTaniumCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Configuration for Tenable Cloud as a Vulnerabilities Provider
type VulnerabilitiesTenableCloud struct {
	Credential *TenableCloudCredential `json:"credential" url:"credential"`
	// URL for the Tenable Cloud API. This should be the base URL for the API, without any path components and must be HTTPS. If not provided, defaults to "https://cloud.tenable.com".
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VulnerabilitiesTenableCloud) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VulnerabilitiesTenableCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler VulnerabilitiesTenableCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VulnerabilitiesTenableCloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VulnerabilitiesTenableCloud) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type AdhocRole struct {
	Resources     *Resources  `json:"resources" url:"resources"`
	PermissionSet Permissions `json:"permission_set" url:"permission_set"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdhocRole) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdhocRole) UnmarshalJSON(data []byte) error {
	type unmarshaler AdhocRole
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdhocRole(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdhocRole) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Resources struct {
	Organizations *RoleOrganizations `json:"organizations,omitempty" url:"organizations,omitempty"`
	Accounts      *RoleAccounts      `json:"accounts,omitempty" url:"accounts,omitempty"`
	Integrations  *RoleIntegrations  `json:"integrations,omitempty" url:"integrations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Resources) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Resources) UnmarshalJSON(data []byte) error {
	type unmarshaler Resources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resources(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Resources) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleAccounts struct {
	// List of account ids that this role definition grants access to. Use "\*" to grant access to all account ids.
	Ids []IntegrationId `json:"ids" url:"ids"`
	// List of account labels this role definition grants access to. If both labels and environments are specified both must pass
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// Account environments this role definition grants access to. If both labels and environments are specified both must pass
	Environments []Environment `json:"environments,omitempty" url:"environments,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleAccounts) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleAccounts) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleAccounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleAccounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleAccounts) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleIntegrations struct {
	// List of categories ids that this role definition grants access to. Use "\*" to grant access to all category ids.
	Categories []CategoryId `json:"categories" url:"categories"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleIntegrations) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleIntegrations) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleIntegrations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleIntegrations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleIntegrations) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Unique identifier for this Role
type RoleName = string

type RoleOrganizations struct {
	// List of organization ids that this role definition grants access to. Use "\*" to grant access to all organization ids.
	Ids []OrganizationId `json:"ids" url:"ids"`
	// List of organization labels this role definition grants access to.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleOrganizations) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleOrganizations) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleOrganizations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleOrganizations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleOrganizations) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type BuiltinRoles string

const (
	BuiltinRolesRootAdministrator BuiltinRoles = "root_administrator"
	BuiltinRolesAdministrator     BuiltinRoles = "administrator"
	BuiltinRolesViewer            BuiltinRoles = "viewer"
	BuiltinRolesMember            BuiltinRoles = "member"
)

func NewBuiltinRolesFromString(s string) (BuiltinRoles, error) {
	switch s {
	case "root_administrator":
		return BuiltinRolesRootAdministrator, nil
	case "administrator":
		return BuiltinRolesAdministrator, nil
	case "viewer":
		return BuiltinRolesViewer, nil
	case "member":
		return BuiltinRolesMember, nil
	}
	var t BuiltinRoles
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BuiltinRoles) Ptr() *BuiltinRoles {
	return &b
}

type RoleDefinition struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        RoleId    `json:"id" url:"id"`
	// Full name of role
	Fullname string `json:"fullname" url:"fullname"`
	// Description of the resources included in the role and permissions granted on those resources. Includes details of when to use this role along with the intended personas.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Selects the resources the permission set applies to.
	Resources *Resources `json:"resources,omitempty" url:"resources,omitempty"`
	// Permission set for this role.
	PermissionSet Permissions `json:"permission_set" url:"permission_set"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RoleDefinition) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RoleDefinition) UnmarshalJSON(data []byte) error {
	type embed RoleDefinition
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RoleDefinition(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleDefinition) MarshalJSON() ([]byte, error) {
	type embed RoleDefinition
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (r *RoleDefinition) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type GetIntegrationTimeseriesResult = *GetStatusTimeseriesResult

// Status timeseries object
type GetStatusTimeseriesResult struct {
	// start time
	StartTime time.Time `json:"start_time" url:"start_time"`
	// end time
	EndTime time.Time `json:"end_time" url:"end_time"`
	// interval duration
	Interval string              `json:"interval" url:"interval"`
	Series   []*TimeseriesResult `json:"series" url:"series"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetStatusTimeseriesResult) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetStatusTimeseriesResult) UnmarshalJSON(data []byte) error {
	type embed GetStatusTimeseriesResult
	var unmarshaler = struct {
		embed
		StartTime *core.DateTime `json:"start_time"`
		EndTime   *core.DateTime `json:"end_time"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GetStatusTimeseriesResult(unmarshaler.embed)
	g.StartTime = unmarshaler.StartTime.Time()
	g.EndTime = unmarshaler.EndTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetStatusTimeseriesResult) MarshalJSON() ([]byte, error) {
	type embed GetStatusTimeseriesResult
	var marshaler = struct {
		embed
		StartTime *core.DateTime `json:"start_time"`
		EndTime   *core.DateTime `json:"end_time"`
	}{
		embed:     embed(*g),
		StartTime: core.NewDateTime(g.StartTime),
		EndTime:   core.NewDateTime(g.EndTime),
	}
	return json.Marshal(marshaler)
}

func (g *GetStatusTimeseriesResult) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Status object
type Status struct {
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// Account associated with this status. Use the expand=accounts parameter with the List API to expand the Account to the full object
	AccountId AccountId `json:"account_id" url:"account_id"`
	// When using the expand option on the List API, the full account object is included in the response
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// Integration associated with this status. Use the expand=integrations parameter with the List API to expand the Account to the full object
	IntegrationId IntegrationId `json:"integration_id" url:"integration_id"`
	// When using the expand option on the List API, the full integration object is included in the response
	Integration *Integration `json:"integration,omitempty" url:"integration,omitempty"`
	// The current status of the notification.
	Status string `json:"status" url:"status"`
	// Request count
	Requests int64 `json:"requests" url:"requests"`
	// Failed count
	Failed int64 `json:"failed" url:"failed"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time" url:"cpu_time"`
	// Database operations count
	DbOps int64 `json:"db_ops" url:"db_ops"`
	// API operations count
	ApiOps int64 `json:"api_ops" url:"api_ops"`
	// API input byte count
	InBytes int64 `json:"in_bytes" url:"in_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Status) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Status) UnmarshalJSON(data []byte) error {
	type embed Status
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Status(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Status) MarshalJSON() ([]byte, error) {
	type embed Status
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
		UpdatedAt: core.NewDateTime(s.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *Status) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Status event object
type StatusEvent struct {
	// Account owner
	AccountId AccountId `json:"account_id" url:"account_id"`
	// Integration object
	IntegrationId IntegrationId `json:"integration_id" url:"integration_id"`
	// Time created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Error message
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Request number
	Request int64 `json:"request" url:"request"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StatusEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StatusEvent) UnmarshalJSON(data []byte) error {
	type embed StatusEvent
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = StatusEvent(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StatusEvent) MarshalJSON() ([]byte, error) {
	type embed StatusEvent
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *StatusEvent) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Status timeseries object
type TimeseriesResult struct {
	// Interval time
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Succeeded count
	Succeeded int64 `json:"succeeded" url:"succeeded"`
	// Failed count
	Failed int64 `json:"failed" url:"failed"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time" url:"cpu_time"`
	// API input byte count
	InBytes int64 `json:"in_bytes" url:"in_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeseriesResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeseriesResult) UnmarshalJSON(data []byte) error {
	type embed TimeseriesResult
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TimeseriesResult(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeseriesResult) MarshalJSON() ([]byte, error) {
	type embed TimeseriesResult
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TimeseriesResult) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Token struct {
	// Secret value for the token; used for authentication when making requests.
	Secret string `json:"secret" url:"secret"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires" url:"expires"`
	// Permissions granted to this token.
	Permissions *Permission `json:"permissions" url:"permissions"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Token) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Token) UnmarshalJSON(data []byte) error {
	type embed Token
	var unmarshaler = struct {
		embed
		Expires *core.DateTime `json:"expires"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Token(unmarshaler.embed)
	t.Expires = unmarshaler.Expires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Token) MarshalJSON() ([]byte, error) {
	type embed Token
	var marshaler = struct {
		embed
		Expires *core.DateTime `json:"expires"`
	}{
		embed:   embed(*t),
		Expires: core.NewDateTime(t.Expires),
	}
	return json.Marshal(marshaler)
}

func (t *Token) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TokenOwnerType string

const (
	TokenOwnerTypeOrganization TokenOwnerType = "organization"
	TokenOwnerTypeIntegration  TokenOwnerType = "integration"
)

func NewTokenOwnerTypeFromString(s string) (TokenOwnerType, error) {
	switch s {
	case "organization":
		return TokenOwnerTypeOrganization, nil
	case "integration":
		return TokenOwnerTypeIntegration, nil
	}
	var t TokenOwnerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TokenOwnerType) Ptr() *TokenOwnerType {
	return &t
}

type TokenPair struct {
	// Access token contains the bearer secret
	Access *Token `json:"access" url:"access"`
	// Refresh token used for RefreshToken API
	Refresh *Token `json:"refresh" url:"refresh"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenPair) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenPair) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenPair
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenPair(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenPair) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type RefreshToken struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        TokenId   `json:"id" url:"id"`
	// Member Id
	MemberId *Id `json:"member_id,omitempty" url:"member_id,omitempty"`
	// ID of the entity that owns this token
	OwnerId Id `json:"owner_id" url:"owner_id"`
	// Type of the entity that owns this token
	OwnerType TokenOwnerType `json:"owner_type" url:"owner_type"`
	// Time when this token expires and can no longer be used again.
	Expires time.Time `json:"expires" url:"expires"`
	// Token time-to-live
	TokenTtl string `json:"token_ttl" url:"token_ttl"`
	// Primary running access and refresh tokens
	Primary *TokenPair `json:"primary" url:"primary"`
	// Temporary secondary TokenPair created after a RefreshToken operation
	Secondary *TokenPair `json:"secondary,omitempty" url:"secondary,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefreshToken) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefreshToken) UnmarshalJSON(data []byte) error {
	type embed RefreshToken
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RefreshToken(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.Time()
	r.UpdatedAt = unmarshaler.UpdatedAt.Time()
	r.Expires = unmarshaler.Expires.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefreshToken) MarshalJSON() ([]byte, error) {
	type embed RefreshToken
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
		Expires   *core.DateTime `json:"expires"`
	}{
		embed:     embed(*r),
		CreatedAt: core.NewDateTime(r.CreatedAt),
		UpdatedAt: core.NewDateTime(r.UpdatedAt),
		Expires:   core.NewDateTime(r.Expires),
	}
	return json.Marshal(marshaler)
}

func (r *RefreshToken) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Transforms data collected before it is sent to the target Integration.
type Transform struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time   `json:"updated_at" url:"updated_at"`
	Id        TransformId `json:"id" url:"id"`
	// Account that manages this Transform.
	AccountId AccountId `json:"account_id" url:"account_id"`
	// Human friendly display name for this Transform.
	Fullname string `json:"fullname" url:"fullname"`
	// JSON Patch transform to apply (rfc6902).
	Patch []byte `json:"patch" url:"patch"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Transform) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Transform) UnmarshalJSON(data []byte) error {
	type embed Transform
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Transform(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Transform) MarshalJSON() ([]byte, error) {
	type embed Transform
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*t),
		CreatedAt: core.NewDateTime(t.CreatedAt),
		UpdatedAt: core.NewDateTime(t.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (t *Transform) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Usage struct {
	IntegrationId     Id      `json:"integration_id" url:"integration_id"`
	RequestsCount     float64 `json:"requests_count" url:"requests_count"`
	CpuTimeSeconds    float64 `json:"cpu_time_seconds" url:"cpu_time_seconds"`
	DbOperationsCount float64 `json:"db_operations_count" url:"db_operations_count"`
	IntOpsCount       float64 `json:"int_ops_count" url:"int_ops_count"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *Usage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Usage) UnmarshalJSON(data []byte) error {
	type unmarshaler Usage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Usage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *Usage) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
