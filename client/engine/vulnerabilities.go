// This file was auto-generated by Fern from our API Definition.

package engine

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/synqly/go-sdk/client/engine/core"
	scanactivity "github.com/synqly/go-sdk/client/engine/ocsf/v110/scanactivity"
)

type QueryAssetsRequest struct {
	// Number of assets to return. Defaults to 50.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Start search from cursor position.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Filter results by this query. For more information on filtering, refer to the Vulnerability Filtering Guide.
	// Defaults to no filter. If used more than once, the queries are ANDed together.
	Filter []*string `json:"-" url:"filter,omitempty"`
}

type QueryFindingsRequest struct {
	// Number of finding reports to return. Defaults to 50.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Start search from cursor position.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Filter results by this query. For more information on filtering, refer to the Vulnerability Filtering Guide.
	// Defaults to no filter. If used more than once, the queries are ANDed together.
	Filter []*string `json:"-" url:"filter,omitempty"`
}

type QueryScansRequest struct {
	// Number of scans to return. Defaults to 50.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Start search from cursor position.
	Cursor *string `json:"-" url:"cursor,omitempty"`
}

type CreateAssetRequest struct {
	// Asset to create in the vulnerability scanning system.
	Asset Asset `json:"asset" url:"asset"`
	// Name of the source that created the asset.
	SourceName string `json:"source_name" url:"source_name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAssetRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAssetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAssetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAssetRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateAssetRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateFindingsRequest struct {
	Findings []SecurityFinding `json:"findings" url:"findings"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateFindingsRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFindingsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateFindingsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateFindingsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateFindingsRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateFindingsResponse struct {
	// Specifies the status of the create/import findings job, which can be COMPLETE or PENDING.
	Status QueryStatus `json:"status" url:"status"`
	// Provides additional details about any errors encountered during the create/import operation.
	Errors []*CreateFindingsError `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateFindingsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFindingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateFindingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateFindingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateFindingsResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GetScanActivityResponse struct {
	Result *scanactivity.ScanActivity `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetScanActivityResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetScanActivityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetScanActivityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetScanActivityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetScanActivityResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type QueryAssetsResponse struct {
	Result []Asset `json:"result" url:"result"`
	// Cursor to use to retrieve the next page of results.
	Cursor string `json:"cursor" url:"cursor"`
	// If the provider supports asynchronous queries and the query is still running, this field will be `PENDING` until the query is complete. In this case, the client should retry using the provided cursor.
	Status QueryStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryAssetsResponse) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryAssetsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryAssetsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryAssetsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryAssetsResponse) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryFindingsResponse struct {
	Result []SecurityFinding `json:"result" url:"result"`
	// Cursor to use to retrieve the next page of results.
	Cursor string `json:"cursor" url:"cursor"`
	// If the provider supports asynchronous queries and the query is still running, this field will be `PENDING` until the query is complete. In this case, the client should retry using the provided cursor.
	Status QueryStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryFindingsResponse) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryFindingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryFindingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryFindingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryFindingsResponse) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryScansResponse struct {
	Result []*ScanConfiguration `json:"result" url:"result"`
	Cursor string               `json:"cursor" url:"cursor"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryScansResponse) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryScansResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryScansResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryScansResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryScansResponse) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}
