// This file was auto-generated by Fern from our API Definition.

package engine

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/synqly/go-sdk/client/engine/core"
	latest "github.com/synqly/go-sdk/client/engine/ocsf/latest"
	accountchange "github.com/synqly/go-sdk/client/engine/ocsf/v130/accountchange"
	apiactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/apiactivity"
	applicationlifecycle "github.com/synqly/go-sdk/client/engine/ocsf/v130/applicationlifecycle"
	authentication "github.com/synqly/go-sdk/client/engine/ocsf/v130/authentication"
	authorizesession "github.com/synqly/go-sdk/client/engine/ocsf/v130/authorizesession"
	baseevent "github.com/synqly/go-sdk/client/engine/ocsf/v130/baseevent"
	compliancefinding "github.com/synqly/go-sdk/client/engine/ocsf/v130/compliancefinding"
	configstate "github.com/synqly/go-sdk/client/engine/ocsf/v130/configstate"
	detectionfinding "github.com/synqly/go-sdk/client/engine/ocsf/v130/detectionfinding"
	dnsactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/dnsactivity"
	fileactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/fileactivity"
	groupmanagement "github.com/synqly/go-sdk/client/engine/ocsf/v130/groupmanagement"
	incidentfinding "github.com/synqly/go-sdk/client/engine/ocsf/v130/incidentfinding"
	inventoryinfo "github.com/synqly/go-sdk/client/engine/ocsf/v130/inventoryinfo"
	moduleactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/moduleactivity"
	networkactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/networkactivity"
	processactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/processactivity"
	scanactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/scanactivity"
	scheduledjobactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/scheduledjobactivity"
	securityfinding "github.com/synqly/go-sdk/client/engine/ocsf/v130/securityfinding"
	softwareinfo "github.com/synqly/go-sdk/client/engine/ocsf/v130/softwareinfo"
	useraccessmanagement "github.com/synqly/go-sdk/client/engine/ocsf/v130/useraccessmanagement"
	vulnerabilityfinding "github.com/synqly/go-sdk/client/engine/ocsf/v130/vulnerabilityfinding"
	webresourceaccessactivity "github.com/synqly/go-sdk/client/engine/ocsf/v130/webresourceaccessactivity"
	applicationsecurityposturefinding "github.com/synqly/go-sdk/client/engine/ocsf/v150/applicationsecurityposturefinding"
	time "time"
)

// An application describes the details for an inventoried application as reported by an Application Security tool or other Developer-centric tooling. Applications can be defined as Github repositories or other code-centric resources.
type AppSecApplication struct {
	// The criticality of the application as defined by the event source.
	Criticality *string `json:"criticality,omitempty" url:"criticality,omitempty"`
	// Additional data describing the application.
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`
	// A description or commentary for an application, usually retrieved from an upstream system.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The name of the related application or associated resource group.
	Group *applicationsecurityposturefinding.Group `json:"group,omitempty" url:"group,omitempty"`
	// The fully qualified name of the application.
	Hostname *applicationsecurityposturefinding.Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The list of labels associated to the application.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The name of the application.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The identity of the service or user account that owns the application.
	Owner *applicationsecurityposturefinding.User `json:"owner,omitempty" url:"owner,omitempty"`
	// The cloud region of the resource.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// A graph representation showing how this application relates to and interacts with other entities in the environment. This can include parent/child relationships, dependencies, or other connections.
	ResourceRelationship *applicationsecurityposturefinding.Graph `json:"resource_relationship,omitempty" url:"resource_relationship,omitempty"`
	// The risk level, normalized to the caption of the risk_level_id value.
	RiskLevel *string `json:"risk_level,omitempty" url:"risk_level,omitempty"`
	// The normalized risk level id.
	RiskLevelId *applicationsecurityposturefinding.ApplicationRiskLevelId `json:"risk_level_id,omitempty" url:"risk_level_id,omitempty"`
	// The risk score as reported by the event source.
	RiskScore *int `json:"risk_score,omitempty" url:"risk_score,omitempty"`
	// The Software Bill of Materials (SBOM) associated with the application
	Sbom *applicationsecurityposturefinding.Sbom `json:"sbom,omitempty" url:"sbom,omitempty"`
	// The list of tags; <code>{key:value}</code> pairs associated to the application.
	Tags []*applicationsecurityposturefinding.KeyValueObject `json:"tags,omitempty" url:"tags,omitempty"`
	// The type of application as defined by the event source, e.g., <code>GitHub</code>, <code>Azure Logic App</code>, or <code>Amazon Elastic BeanStalk</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique identifier for the application.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An alternative or contextual identifier for the application, such as a configuration, organization, or license UID.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The URL of the application.
	Url *applicationsecurityposturefinding.Url `json:"url,omitempty" url:"url,omitempty"`
	// The semantic version of the application, e.g., <code>1.7.4</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// An attribute that describes the type of the application's unique identifier as defined by the provider. This may be used to help find the application in the provider's user interface. Note that the uid attribute is used as the primary identifier for the application for the purposes of the Synqly API.
	UidType *AppSecApplicationUidType `json:"uid_type,omitempty" url:"uid_type,omitempty"`
	// An attribute that describes the type of the application's alternate unique identifier as defined by the provider. This may be used to help find the application in the provider's user interface.
	UidAltType *string `json:"uid_alt_type,omitempty" url:"uid_alt_type,omitempty"`
	// The attributes that are not mapped to the application schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppSecApplication) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppSecApplication) UnmarshalJSON(data []byte) error {
	type unmarshaler AppSecApplication
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppSecApplication(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AppSecApplication) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppSecApplicationUidType string

const (
	AppSecApplicationUidTypeProviderRelease     AppSecApplicationUidType = "provider_release"
	AppSecApplicationUidTypeProviderApplication AppSecApplicationUidType = "provider_application"
)

func NewAppSecApplicationUidTypeFromString(s string) (AppSecApplicationUidType, error) {
	switch s {
	case "provider_release":
		return AppSecApplicationUidTypeProviderRelease, nil
	case "provider_application":
		return AppSecApplicationUidTypeProviderApplication, nil
	}
	var t AppSecApplicationUidType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppSecApplicationUidType) Ptr() *AppSecApplicationUidType {
	return &a
}

type AppSecFindingResult struct {
	Application *AppSecApplication   `json:"application" url:"application"`
	Finding     AppSecPostureFinding `json:"finding" url:"finding"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppSecFindingResult) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppSecFindingResult) UnmarshalJSON(data []byte) error {
	type unmarshaler AppSecFindingResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppSecFindingResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AppSecFindingResult) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppSecGetApplicationFindingDetailsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// Details of the application finding
	Result map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppSecGetApplicationFindingDetailsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppSecGetApplicationFindingDetailsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler AppSecGetApplicationFindingDetailsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppSecGetApplicationFindingDetailsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AppSecGetApplicationFindingDetailsResponseGeneric) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// An application security posture finding
type AppSecPostureFinding = latest.ApplicationSecurityPostureFinding

type AppSecQueryApplicationFindingsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of application findings
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppSecQueryApplicationFindingsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppSecQueryApplicationFindingsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler AppSecQueryApplicationFindingsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppSecQueryApplicationFindingsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AppSecQueryApplicationFindingsResponseGeneric) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppSecQueryApplicationsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of applications
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppSecQueryApplicationsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppSecQueryApplicationsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler AppSecQueryApplicationsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppSecQueryApplicationsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AppSecQueryApplicationsResponseGeneric) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppSecQueryFindingsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of findings and applications results
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppSecQueryFindingsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppSecQueryFindingsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler AppSecQueryFindingsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppSecQueryFindingsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AppSecQueryFindingsResponseGeneric) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type CreateDeviceRequestGeneric struct {
	// Device object to create
	Device map[string]interface{} `json:"device" url:"device"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDeviceRequestGeneric) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeviceRequestGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateDeviceRequestGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateDeviceRequestGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateDeviceRequestGeneric) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeviceResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta   *MetaResponse          `json:"meta,omitempty" url:"meta,omitempty"`
	Device map[string]interface{} `json:"device" url:"device"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDeviceResponseGeneric) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeviceResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateDeviceResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateDeviceResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateDeviceResponseGeneric) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Device inventory information. Represented by OCSF Device Inventory Info class (class_uid 5001).
type Device = *inventoryinfo.InventoryInfo

type GetLabelsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string                   `json:"cursor" url:"cursor"`
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLabelsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLabelsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLabelsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLabelsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetLabelsResponseGeneric) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Label struct {
	Value  string `json:"value" url:"value"`
	Device Device `json:"device" url:"device"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Label) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Label) UnmarshalJSON(data []byte) error {
	type unmarshaler Label
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Label(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *Label) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type QueryDevicesResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of devices
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryDevicesResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryDevicesResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryDevicesResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryDevicesResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryDevicesResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type ActionId string

const (
	ActionIdQuery  ActionId = "query"
	ActionIdRead   ActionId = "read"
	ActionIdCreate ActionId = "create"
	ActionIdUpdate ActionId = "update"
	ActionIdDelete ActionId = "delete"
	ActionIdPatch  ActionId = "patch"
)

func NewActionIdFromString(s string) (ActionId, error) {
	switch s {
	case "query":
		return ActionIdQuery, nil
	case "read":
		return ActionIdRead, nil
	case "create":
		return ActionIdCreate, nil
	case "update":
		return ActionIdUpdate, nil
	case "delete":
		return ActionIdDelete, nil
	case "patch":
		return ActionIdPatch, nil
	}
	var t ActionId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionId) Ptr() *ActionId {
	return &a
}

type Base struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Base) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Base) UnmarshalJSON(data []byte) error {
	type embed Base
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Base(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *Base) MarshalJSON() ([]byte, error) {
	type embed Base
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *Base) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Id = string

type ParameterLocation string

const (
	ParameterLocationHeader ParameterLocation = "header"
	ParameterLocationPath   ParameterLocation = "path"
	ParameterLocationQuery  ParameterLocation = "query"
	ParameterLocationBody   ParameterLocation = "body"
)

func NewParameterLocationFromString(s string) (ParameterLocation, error) {
	switch s {
	case "header":
		return ParameterLocationHeader, nil
	case "path":
		return ParameterLocationPath, nil
	case "query":
		return ParameterLocationQuery, nil
	case "body":
		return ParameterLocationBody, nil
	}
	var t ParameterLocation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ParameterLocation) Ptr() *ParameterLocation {
	return &p
}

type PatchOp string

const (
	PatchOpAdd     PatchOp = "add"
	PatchOpCopy    PatchOp = "copy"
	PatchOpMove    PatchOp = "move"
	PatchOpRemove  PatchOp = "remove"
	PatchOpReplace PatchOp = "replace"
	PatchOpTest    PatchOp = "test"
)

func NewPatchOpFromString(s string) (PatchOp, error) {
	switch s {
	case "add":
		return PatchOpAdd, nil
	case "copy":
		return PatchOpCopy, nil
	case "move":
		return PatchOpMove, nil
	case "remove":
		return PatchOpRemove, nil
	case "replace":
		return PatchOpReplace, nil
	case "test":
		return PatchOpTest, nil
	}
	var t PatchOp
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PatchOp) Ptr() *PatchOp {
	return &p
}

// Generic base type for problems in Synqly. This object carries both machine-readable data as well as information intended for display purposes.
type Problem struct {
	// A short, display-friendly summary of the problem.
	Message string `json:"message" url:"message"`
	// A display-friendly and more detailed explanation of the problem. It may offer additional contextual detail, but may also be just a generic description of the problem.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// A display-friendly explanation for how to remediate the problem. This field may be omitted in case there are multiple problems, each with its own remediation, or if no remediation is possible.
	Remediation *string `json:"remediation,omitempty" url:"remediation,omitempty"`
	// Additional context providing further detail about the problem, such as a problematic input parameter and/or a list of related resources.
	Context *ProblemContext `json:"context,omitempty" url:"context,omitempty"`
	Type    *ProblemType    `json:"type,omitempty" url:"type,omitempty"`
	// The date and time the problem occurred.
	OccurredAt time.Time `json:"occurred_at" url:"occurred_at"`
	// The HTTP status code of the problem. Matches the HTTP response code sent by the server.
	Status int `json:"status" url:"status"`
	// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	Instance string `json:"instance" url:"instance"`
	// A list of the root cause(s) for this problem occurrence. Includes at minimum one root cause, and is otherwise an unordered list of causes.
	Cause []*ProblemCause `json:"cause,omitempty" url:"cause,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Problem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Problem) UnmarshalJSON(data []byte) error {
	type embed Problem
	var unmarshaler = struct {
		embed
		OccurredAt *core.DateTime `json:"occurred_at"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Problem(unmarshaler.embed)
	p.OccurredAt = unmarshaler.OccurredAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Problem) MarshalJSON() ([]byte, error) {
	type embed Problem
	var marshaler = struct {
		embed
		OccurredAt *core.DateTime `json:"occurred_at"`
	}{
		embed:      embed(*p),
		OccurredAt: core.NewDateTime(p.OccurredAt),
	}
	return json.Marshal(marshaler)
}

func (p *Problem) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProblemCause struct {
	// A short, display-friendly summary of the problem.
	Message string `json:"message" url:"message"`
	// A display-friendly and more detailed explanation of the problem. It may offer additional contextual detail, but may also be just a generic description of the problem.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// A display-friendly explanation for how to remediate the problem. This field may be omitted in case there are multiple problems, each with its own remediation, or if no remediation is possible.
	Remediation *string `json:"remediation,omitempty" url:"remediation,omitempty"`
	// Additional context providing further detail about the problem, such as a problematic input parameter and/or a list of related resources.
	Context *ProblemContext `json:"context,omitempty" url:"context,omitempty"`
	Type    ProblemType     `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProblemCause) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProblemCause) UnmarshalJSON(data []byte) error {
	type unmarshaler ProblemCause
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProblemCause(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProblemCause) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProblemContext struct {
	// If the problem is related to a `query`, `header`, `path` or `body` parameter, this field will describe the problematic parameter and where to find it.
	Parameter *ProblematicParameter `json:"parameter,omitempty" url:"parameter,omitempty"`
	Resources []*ResourceReference  `json:"resources,omitempty" url:"resources,omitempty"`
	// If available this represents the underlying raw error, for example an error response from a Provider.
	RawError *string `json:"raw_error,omitempty" url:"raw_error,omitempty"`
	// If available this represents the underlying details from the provider. May include the error message, status code, and other details.
	ProviderDetails map[string]string `json:"provider_details,omitempty" url:"provider_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProblemContext) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProblemContext) UnmarshalJSON(data []byte) error {
	type unmarshaler ProblemContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProblemContext(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProblemContext) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProblemDetails struct {
	// A short, display-friendly summary of the problem.
	Message string `json:"message" url:"message"`
	// A display-friendly and more detailed explanation of the problem. It may offer additional contextual detail, but may also be just a generic description of the problem.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// A display-friendly explanation for how to remediate the problem. This field may be omitted in case there are multiple problems, each with its own remediation, or if no remediation is possible.
	Remediation *string `json:"remediation,omitempty" url:"remediation,omitempty"`
	// Additional context providing further detail about the problem, such as a problematic input parameter and/or a list of related resources.
	Context *ProblemContext `json:"context,omitempty" url:"context,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProblemDetails) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProblemDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ProblemDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProblemDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProblemDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProblemRelation string

const (
	ProblemRelationAffected ProblemRelation = "affected"
	ProblemRelationCause    ProblemRelation = "cause"
)

func NewProblemRelationFromString(s string) (ProblemRelation, error) {
	switch s {
	case "affected":
		return ProblemRelationAffected, nil
	case "cause":
		return ProblemRelationCause, nil
	}
	var t ProblemRelation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProblemRelation) Ptr() *ProblemRelation {
	return &p
}

// A URI reference that identifies the type of problem that occurred. When the URI scheme is HTTP(s), it may or may not be possible to deference the URL to a display-friendly description of the problem type.
type ProblemType = string

type ProblematicParameter struct {
	// If the `location` of the parameter is `body`, this value is always a JSON Pointer, otherwise it's the name of the parameter.
	Id string `json:"id" url:"id"`
	// The location of the parameter. Possible values are `query`, `header`, `path` or `body`.
	Location ParameterLocation `json:"location" url:"location"`
	// The given value of the parameter.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProblematicParameter) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProblematicParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler ProblematicParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProblematicParameter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProblematicParameter) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ResourceId string

const (
	ResourceIdAlerts                 ResourceId = "alerts"
	ResourceIdApplications           ResourceId = "applications"
	ResourceIdAuditLogs              ResourceId = "audit_logs"
	ResourceIdComments               ResourceId = "comments"
	ResourceIdDevices                ResourceId = "devices"
	ResourceIdEvents                 ResourceId = "events"
	ResourceIdEvidence               ResourceId = "evidence"
	ResourceIdFindings               ResourceId = "findings"
	ResourceIdGroups                 ResourceId = "groups"
	ResourceIdInvestigations         ResourceId = "investigations"
	ResourceIdIocs                   ResourceId = "iocs"
	ResourceIdLogProviders           ResourceId = "log_providers"
	ResourceIdPostureScores          ResourceId = "posture_scores"
	ResourceIdProjects               ResourceId = "projects"
	ResourceIdScans                  ResourceId = "scans"
	ResourceIdScanActivities         ResourceId = "scan_activities"
	ResourceIdThreats                ResourceId = "threats"
	ResourceIdTickets                ResourceId = "tickets"
	ResourceIdUsers                  ResourceId = "users"
	ResourceIdCompliance             ResourceId = "compliance"
	ResourceIdCloudresourceinventory ResourceId = "cloudresourceinventory"
)

func NewResourceIdFromString(s string) (ResourceId, error) {
	switch s {
	case "alerts":
		return ResourceIdAlerts, nil
	case "applications":
		return ResourceIdApplications, nil
	case "audit_logs":
		return ResourceIdAuditLogs, nil
	case "comments":
		return ResourceIdComments, nil
	case "devices":
		return ResourceIdDevices, nil
	case "events":
		return ResourceIdEvents, nil
	case "evidence":
		return ResourceIdEvidence, nil
	case "findings":
		return ResourceIdFindings, nil
	case "groups":
		return ResourceIdGroups, nil
	case "investigations":
		return ResourceIdInvestigations, nil
	case "iocs":
		return ResourceIdIocs, nil
	case "log_providers":
		return ResourceIdLogProviders, nil
	case "posture_scores":
		return ResourceIdPostureScores, nil
	case "projects":
		return ResourceIdProjects, nil
	case "scans":
		return ResourceIdScans, nil
	case "scan_activities":
		return ResourceIdScanActivities, nil
	case "threats":
		return ResourceIdThreats, nil
	case "tickets":
		return ResourceIdTickets, nil
	case "users":
		return ResourceIdUsers, nil
	case "compliance":
		return ResourceIdCompliance, nil
	case "cloudresourceinventory":
		return ResourceIdCloudresourceinventory, nil
	}
	var t ResourceId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResourceId) Ptr() *ResourceId {
	return &r
}

type ResourceReference struct {
	// Type of the related resource.
	Type ResourceType `json:"type" url:"type"`
	// ID of the related resource.
	Id string `json:"id" url:"id"`
	// The way in which the resource relates to the problem.
	Rel ProblemRelation `json:"rel" url:"rel"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResourceReference) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResourceReference) UnmarshalJSON(data []byte) error {
	type unmarshaler ResourceReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResourceReference(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *ResourceReference) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResourceType string

const (
	ResourceTypeAccount             ResourceType = "account"
	ResourceTypeBridge              ResourceType = "bridge"
	ResourceTypeCredential          ResourceType = "credential"
	ResourceTypeIntegrationPoint    ResourceType = "integration_point"
	ResourceTypeIntegration         ResourceType = "integration"
	ResourceTypeMember              ResourceType = "member"
	ResourceTypeOperation           ResourceType = "operation"
	ResourceTypeOrganizationWebhook ResourceType = "organization_webhook"
	ResourceTypeRole                ResourceType = "role"
	ResourceTypeSubOrg              ResourceType = "sub_org"
	ResourceTypeToken               ResourceType = "token"
	ResourceTypeTransform           ResourceType = "transform"
)

func NewResourceTypeFromString(s string) (ResourceType, error) {
	switch s {
	case "account":
		return ResourceTypeAccount, nil
	case "bridge":
		return ResourceTypeBridge, nil
	case "credential":
		return ResourceTypeCredential, nil
	case "integration_point":
		return ResourceTypeIntegrationPoint, nil
	case "integration":
		return ResourceTypeIntegration, nil
	case "member":
		return ResourceTypeMember, nil
	case "operation":
		return ResourceTypeOperation, nil
	case "organization_webhook":
		return ResourceTypeOrganizationWebhook, nil
	case "role":
		return ResourceTypeRole, nil
	case "sub_org":
		return ResourceTypeSubOrg, nil
	case "token":
		return ResourceTypeToken, nil
	case "transform":
		return ResourceTypeTransform, nil
	}
	var t ResourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResourceType) Ptr() *ResourceType {
	return &r
}

// Application information represented by the extended OCSF Software Info event. The Product object describes characteristics of a software product.
type Application = *softwareinfo.SoftwareInfo

type ConnectionState string

const (
	ConnectionStateConnect    ConnectionState = "Connect"
	ConnectionStateDisconnect ConnectionState = "Disconnect"
)

func NewConnectionStateFromString(s string) (ConnectionState, error) {
	switch s {
	case "Connect":
		return ConnectionStateConnect, nil
	case "Disconnect":
		return ConnectionStateDisconnect, nil
	}
	var t ConnectionState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionState) Ptr() *ConnectionState {
	return &c
}

type CreateIocsRequestGeneric struct {
	// The list of iocs to create
	Indicators []map[string]interface{} `json:"indicators" url:"indicators"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateIocsRequestGeneric) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateIocsRequestGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateIocsRequestGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateIocsRequestGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateIocsRequestGeneric) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateIocsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// A list of the indicators that were created
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateIocsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateIocsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateIocsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateIocsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateIocsResponseGeneric) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type GetEndpointResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// A single endpoint assets that match the Id.
	Result map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEndpointResponseGeneric) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEndpointResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEndpointResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEndpointResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetEndpointResponseGeneric) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The posture score of an endpoint asset.
type PostureScore = *configstate.ConfigState

type QueryAlertsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of alerts that match the query.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryAlertsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryAlertsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryAlertsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryAlertsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryAlertsResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryApplicationsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of applications that match the query.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryApplicationsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryApplicationsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryApplicationsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryApplicationsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryApplicationsResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryEdrEventsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of EDR events that match the query.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryEdrEventsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryEdrEventsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryEdrEventsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryEdrEventsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryEdrEventsResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryEndpointsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of endpoint assets that match the query.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryEndpointsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryEndpointsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryEndpointsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryEndpointsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryEndpointsResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryIocsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of iocs that match the query.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryIocsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryIocsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryIocsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryIocsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryIocsResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryPostureScoreResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of posture scores that match the query.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryPostureScoreResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryPostureScoreResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryPostureScoreResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryPostureScoreResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryPostureScoreResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryThreatsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of threats that match the query.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryThreatsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryThreatsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryThreatsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryThreatsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryThreatsResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Threat event information represented by OCSF Threat object. The Threat object describes characteristics of a threat event.
type ThreatEvent = *detectionfinding.DetectionFinding

type ApiHasStatus struct {
	// If the provider supports asynchronous queries and the query is still running, this field will be `PENDING` until the query is complete. In this case, the client should retry using the provided cursor.
	Status QueryStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiHasStatus) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiHasStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiHasStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiHasStatus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *ApiHasStatus) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiQueryResponse struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiQueryResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiQueryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiQueryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiQueryResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *ApiQueryResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiResponse struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApiResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *ApiResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BaseResourceRequest struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BaseResourceRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseResourceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseResourceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseResourceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BaseResourceRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type MetaApi struct {
	Response *MetaApiResponse `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaApi) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaApi) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaApi(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaApi) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetaApiPrimaryResponse struct {
	// The endpoint URL of the primary API request made to fulfill the response.
	Endpoint string `json:"endpoint" url:"endpoint"`
	// The response from the primary API request.
	Response string `json:"response" url:"response"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaApiPrimaryResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaApiPrimaryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaApiPrimaryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaApiPrimaryResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaApiPrimaryResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetaApiResponse struct {
	Primary *MetaApiPrimaryResponse `json:"primary,omitempty" url:"primary,omitempty"`
	// All responses from backing API calls, indexed by endpoint URL.
	List map[string][]string `json:"list,omitempty" url:"list,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaApiResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaApiResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaApiResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetaResponse struct {
	// Statistics about items contained in the response.
	Stats *MetaStats `json:"stats,omitempty" url:"stats,omitempty"`
	// Information about backing API requests made to fulfill the response.
	Api *MetaApi `json:"api,omitempty" url:"api,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetaStats struct {
	// A count of total response times. If present "\*" will be all items, or they can be faceted into specific categories.
	Count map[string]int64 `json:"count,omitempty" url:"count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaStats) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaStats) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaStats
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaStats(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaStats) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The Object type is used to represent an object with arbitrary fields. The keys are strings and the values are any type.
type Object = map[string]interface{}

// Represents a possible option from a set of choices, such as an enum value. The choices may have separate display names and IDs.
type OptionValue struct {
	Id   Id     `json:"id" url:"id"`
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OptionValue) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OptionValue) UnmarshalJSON(data []byte) error {
	type unmarshaler OptionValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OptionValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OptionValue) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderOptions string

const (
	OrderOptionsAsc  OrderOptions = "asc"
	OrderOptionsDesc OrderOptions = "desc"
)

func NewOrderOptionsFromString(s string) (OrderOptions, error) {
	switch s {
	case "asc":
		return OrderOptionsAsc, nil
	case "desc":
		return OrderOptionsDesc, nil
	}
	var t OrderOptions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderOptions) Ptr() *OrderOptions {
	return &o
}

type QueryStatus string

const (
	QueryStatusPending  QueryStatus = "PENDING"
	QueryStatusComplete QueryStatus = "COMPLETE"
)

func NewQueryStatusFromString(s string) (QueryStatus, error) {
	switch s {
	case "PENDING":
		return QueryStatusPending, nil
	case "COMPLETE":
		return QueryStatusComplete, nil
	}
	var t QueryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QueryStatus) Ptr() *QueryStatus {
	return &q
}

type Event struct {
	ClassName                 string
	AccountChange             *accountchange.AccountChange
	ApiActivity               *apiactivity.ApiActivity
	Authentication            *authentication.Authentication
	AuthorizeSession          *authorizesession.AuthorizeSession
	BaseEvent                 *baseevent.BaseEvent
	ComplianceFinding         *compliancefinding.ComplianceFinding
	DeviceConfigState         *configstate.ConfigState
	DetectionFinding          *detectionfinding.DetectionFinding
	DnsActivity               *dnsactivity.DnsActivity
	FileSystemActivity        *fileactivity.FileActivity
	GroupManagement           *groupmanagement.GroupManagement
	IncidentFinding           *incidentfinding.IncidentFinding
	DeviceInventoryInfo       *inventoryinfo.InventoryInfo
	ModuleActivity            *moduleactivity.ModuleActivity
	NetworkActivity           *networkactivity.NetworkActivity
	ProcessActivity           *processactivity.ProcessActivity
	ScanActivity              *scanactivity.ScanActivity
	ScheduledJobActivity      *scheduledjobactivity.ScheduledJobActivity
	SecurityFinding           *securityfinding.SecurityFinding
	SoftwareInfo              *softwareinfo.SoftwareInfo
	UserAccessManagement      *useraccessmanagement.UserAccess
	VulnerabilityFinding      *vulnerabilityfinding.VulnerabilityFinding
	WebResourceAccessActivity *webresourceaccessactivity.WebResourceAccessActivity
	ApplicationLifecycle      *applicationlifecycle.ApplicationLifecycle
}

func (e *Event) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ClassName string `json:"class_name"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.ClassName = unmarshaler.ClassName
	if unmarshaler.ClassName == "" {
		return fmt.Errorf("%T did not include discriminant class_name", e)
	}
	switch unmarshaler.ClassName {
	case "Account Change":
		value := new(accountchange.AccountChange)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AccountChange = value
	case "API Activity":
		value := new(apiactivity.ApiActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ApiActivity = value
	case "Authentication":
		value := new(authentication.Authentication)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Authentication = value
	case "Authorize Session":
		value := new(authorizesession.AuthorizeSession)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AuthorizeSession = value
	case "Base Event":
		value := new(baseevent.BaseEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.BaseEvent = value
	case "Compliance Finding":
		value := new(compliancefinding.ComplianceFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ComplianceFinding = value
	case "Device Config State":
		value := new(configstate.ConfigState)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DeviceConfigState = value
	case "Detection Finding":
		value := new(detectionfinding.DetectionFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DetectionFinding = value
	case "DNS Activity":
		value := new(dnsactivity.DnsActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DnsActivity = value
	case "File System Activity":
		value := new(fileactivity.FileActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileSystemActivity = value
	case "Group Management":
		value := new(groupmanagement.GroupManagement)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.GroupManagement = value
	case "Incident Finding":
		value := new(incidentfinding.IncidentFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.IncidentFinding = value
	case "Device Inventory Info":
		value := new(inventoryinfo.InventoryInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DeviceInventoryInfo = value
	case "Module Activity":
		value := new(moduleactivity.ModuleActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ModuleActivity = value
	case "Network Activity":
		value := new(networkactivity.NetworkActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.NetworkActivity = value
	case "Process Activity":
		value := new(processactivity.ProcessActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ProcessActivity = value
	case "Scan Activity":
		value := new(scanactivity.ScanActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ScanActivity = value
	case "Scheduled Job Activity":
		value := new(scheduledjobactivity.ScheduledJobActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ScheduledJobActivity = value
	case "Security Finding":
		value := new(securityfinding.SecurityFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecurityFinding = value
	case "Software Info":
		value := new(softwareinfo.SoftwareInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SoftwareInfo = value
	case "User Access Management":
		value := new(useraccessmanagement.UserAccess)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UserAccessManagement = value
	case "Vulnerability Finding":
		value := new(vulnerabilityfinding.VulnerabilityFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.VulnerabilityFinding = value
	case "Web Resource Access Activity":
		value := new(webresourceaccessactivity.WebResourceAccessActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WebResourceAccessActivity = value
	case "Application Lifecycle":
		value := new(applicationlifecycle.ApplicationLifecycle)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ApplicationLifecycle = value
	}
	return nil
}

func (e Event) MarshalJSON() ([]byte, error) {
	if e.AccountChange != nil {
		return core.MarshalJSONWithExtraProperty(e.AccountChange, "class_name", "Account Change")
	}
	if e.ApiActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ApiActivity, "class_name", "API Activity")
	}
	if e.Authentication != nil {
		return core.MarshalJSONWithExtraProperty(e.Authentication, "class_name", "Authentication")
	}
	if e.AuthorizeSession != nil {
		return core.MarshalJSONWithExtraProperty(e.AuthorizeSession, "class_name", "Authorize Session")
	}
	if e.BaseEvent != nil {
		return core.MarshalJSONWithExtraProperty(e.BaseEvent, "class_name", "Base Event")
	}
	if e.ComplianceFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.ComplianceFinding, "class_name", "Compliance Finding")
	}
	if e.DeviceConfigState != nil {
		return core.MarshalJSONWithExtraProperty(e.DeviceConfigState, "class_name", "Device Config State")
	}
	if e.DetectionFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.DetectionFinding, "class_name", "Detection Finding")
	}
	if e.DnsActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.DnsActivity, "class_name", "DNS Activity")
	}
	if e.FileSystemActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.FileSystemActivity, "class_name", "File System Activity")
	}
	if e.GroupManagement != nil {
		return core.MarshalJSONWithExtraProperty(e.GroupManagement, "class_name", "Group Management")
	}
	if e.IncidentFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.IncidentFinding, "class_name", "Incident Finding")
	}
	if e.DeviceInventoryInfo != nil {
		return core.MarshalJSONWithExtraProperty(e.DeviceInventoryInfo, "class_name", "Device Inventory Info")
	}
	if e.ModuleActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ModuleActivity, "class_name", "Module Activity")
	}
	if e.NetworkActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.NetworkActivity, "class_name", "Network Activity")
	}
	if e.ProcessActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ProcessActivity, "class_name", "Process Activity")
	}
	if e.ScanActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ScanActivity, "class_name", "Scan Activity")
	}
	if e.ScheduledJobActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ScheduledJobActivity, "class_name", "Scheduled Job Activity")
	}
	if e.SecurityFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.SecurityFinding, "class_name", "Security Finding")
	}
	if e.SoftwareInfo != nil {
		return core.MarshalJSONWithExtraProperty(e.SoftwareInfo, "class_name", "Software Info")
	}
	if e.UserAccessManagement != nil {
		return core.MarshalJSONWithExtraProperty(e.UserAccessManagement, "class_name", "User Access Management")
	}
	if e.VulnerabilityFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.VulnerabilityFinding, "class_name", "Vulnerability Finding")
	}
	if e.WebResourceAccessActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.WebResourceAccessActivity, "class_name", "Web Resource Access Activity")
	}
	if e.ApplicationLifecycle != nil {
		return core.MarshalJSONWithExtraProperty(e.ApplicationLifecycle, "class_name", "Application Lifecycle")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EventVisitor interface {
	VisitAccountChange(*accountchange.AccountChange) error
	VisitApiActivity(*apiactivity.ApiActivity) error
	VisitAuthentication(*authentication.Authentication) error
	VisitAuthorizeSession(*authorizesession.AuthorizeSession) error
	VisitBaseEvent(*baseevent.BaseEvent) error
	VisitComplianceFinding(*compliancefinding.ComplianceFinding) error
	VisitDeviceConfigState(*configstate.ConfigState) error
	VisitDetectionFinding(*detectionfinding.DetectionFinding) error
	VisitDnsActivity(*dnsactivity.DnsActivity) error
	VisitFileSystemActivity(*fileactivity.FileActivity) error
	VisitGroupManagement(*groupmanagement.GroupManagement) error
	VisitIncidentFinding(*incidentfinding.IncidentFinding) error
	VisitDeviceInventoryInfo(*inventoryinfo.InventoryInfo) error
	VisitModuleActivity(*moduleactivity.ModuleActivity) error
	VisitNetworkActivity(*networkactivity.NetworkActivity) error
	VisitProcessActivity(*processactivity.ProcessActivity) error
	VisitScanActivity(*scanactivity.ScanActivity) error
	VisitScheduledJobActivity(*scheduledjobactivity.ScheduledJobActivity) error
	VisitSecurityFinding(*securityfinding.SecurityFinding) error
	VisitSoftwareInfo(*softwareinfo.SoftwareInfo) error
	VisitUserAccessManagement(*useraccessmanagement.UserAccess) error
	VisitVulnerabilityFinding(*vulnerabilityfinding.VulnerabilityFinding) error
	VisitWebResourceAccessActivity(*webresourceaccessactivity.WebResourceAccessActivity) error
	VisitApplicationLifecycle(*applicationlifecycle.ApplicationLifecycle) error
}

func (e *Event) Accept(visitor EventVisitor) error {
	if e.AccountChange != nil {
		return visitor.VisitAccountChange(e.AccountChange)
	}
	if e.ApiActivity != nil {
		return visitor.VisitApiActivity(e.ApiActivity)
	}
	if e.Authentication != nil {
		return visitor.VisitAuthentication(e.Authentication)
	}
	if e.AuthorizeSession != nil {
		return visitor.VisitAuthorizeSession(e.AuthorizeSession)
	}
	if e.BaseEvent != nil {
		return visitor.VisitBaseEvent(e.BaseEvent)
	}
	if e.ComplianceFinding != nil {
		return visitor.VisitComplianceFinding(e.ComplianceFinding)
	}
	if e.DeviceConfigState != nil {
		return visitor.VisitDeviceConfigState(e.DeviceConfigState)
	}
	if e.DetectionFinding != nil {
		return visitor.VisitDetectionFinding(e.DetectionFinding)
	}
	if e.DnsActivity != nil {
		return visitor.VisitDnsActivity(e.DnsActivity)
	}
	if e.FileSystemActivity != nil {
		return visitor.VisitFileSystemActivity(e.FileSystemActivity)
	}
	if e.GroupManagement != nil {
		return visitor.VisitGroupManagement(e.GroupManagement)
	}
	if e.IncidentFinding != nil {
		return visitor.VisitIncidentFinding(e.IncidentFinding)
	}
	if e.DeviceInventoryInfo != nil {
		return visitor.VisitDeviceInventoryInfo(e.DeviceInventoryInfo)
	}
	if e.ModuleActivity != nil {
		return visitor.VisitModuleActivity(e.ModuleActivity)
	}
	if e.NetworkActivity != nil {
		return visitor.VisitNetworkActivity(e.NetworkActivity)
	}
	if e.ProcessActivity != nil {
		return visitor.VisitProcessActivity(e.ProcessActivity)
	}
	if e.ScanActivity != nil {
		return visitor.VisitScanActivity(e.ScanActivity)
	}
	if e.ScheduledJobActivity != nil {
		return visitor.VisitScheduledJobActivity(e.ScheduledJobActivity)
	}
	if e.SecurityFinding != nil {
		return visitor.VisitSecurityFinding(e.SecurityFinding)
	}
	if e.SoftwareInfo != nil {
		return visitor.VisitSoftwareInfo(e.SoftwareInfo)
	}
	if e.UserAccessManagement != nil {
		return visitor.VisitUserAccessManagement(e.UserAccessManagement)
	}
	if e.VulnerabilityFinding != nil {
		return visitor.VisitVulnerabilityFinding(e.VulnerabilityFinding)
	}
	if e.WebResourceAccessActivity != nil {
		return visitor.VisitWebResourceAccessActivity(e.WebResourceAccessActivity)
	}
	if e.ApplicationLifecycle != nil {
		return visitor.VisitApplicationLifecycle(e.ApplicationLifecycle)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type IntegrationTicketWhen string

const (
	IntegrationTicketWhenAfter   IntegrationTicketWhen = "after"
	IntegrationTicketWhenAsync   IntegrationTicketWhen = "async"
	IntegrationTicketWhenBefore  IntegrationTicketWhen = "before"
	IntegrationTicketWhenDisplay IntegrationTicketWhen = "display"
)

func NewIntegrationTicketWhenFromString(s string) (IntegrationTicketWhen, error) {
	switch s {
	case "after":
		return IntegrationTicketWhenAfter, nil
	case "async":
		return IntegrationTicketWhenAsync, nil
	case "before":
		return IntegrationTicketWhenBefore, nil
	case "display":
		return IntegrationTicketWhenDisplay, nil
	}
	var t IntegrationTicketWhen
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationTicketWhen) Ptr() *IntegrationTicketWhen {
	return &i
}

type TicketingWebhookResponse struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// The ID of the ticket in the ticketing system.
	TicketId *string `json:"ticket_id,omitempty" url:"ticket_id,omitempty"`
	// Date pertiment to webhook operation e.g. if its TicketCreated would be creation date. This comes directly from the ticketing system without any date formatting changes.
	EntityDate *string `json:"entity_date,omitempty" url:"entity_date,omitempty"`
	// The priority of the ticket.
	Priority *Priority `json:"priority,omitempty" url:"priority,omitempty"`
	// Short Description of the ticket in the ticketing system.
	ShortDescription *string `json:"short_description,omitempty" url:"short_description,omitempty"`
	// The Raw JSON that was sent by the ticketing system for this webhook event.
	RawPayload string `json:"raw_payload" url:"raw_payload"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingWebhookResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingWebhookResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingWebhookResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingWebhookResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingWebhookResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type GetGroupMembersResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of users wrapped in the OCSF Entity Management event of type Read that are members in the group referenced by ID.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetGroupMembersResponseGeneric) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetGroupMembersResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler GetGroupMembersResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetGroupMembersResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetGroupMembersResponseGeneric) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetGroupResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta   *MetaResponse          `json:"meta,omitempty" url:"meta,omitempty"`
	Result map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetGroupResponseGeneric) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetGroupResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler GetGroupResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetGroupResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetGroupResponseGeneric) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetUserResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta   *MetaResponse          `json:"meta,omitempty" url:"meta,omitempty"`
	Result map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetUserResponseGeneric) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetUserResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler GetUserResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetUserResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetUserResponseGeneric) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type QueryGroupsResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List groups wrapped in the OCSF Entity Management event of type Read.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryGroupsResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryGroupsResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryGroupsResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryGroupsResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryGroupsResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryIdentityAuditLogResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of events from the audit log. Each event will be one of the OCSF Types Account Change, Authentication, or Group Management.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryIdentityAuditLogResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryIdentityAuditLogResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryIdentityAuditLogResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryIdentityAuditLogResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryIdentityAuditLogResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type QueryUsersResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List users wrapped in the OCSF Entity Management event of type Read.
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryUsersResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryUsersResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryUsersResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryUsersResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryUsersResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Integration webhook
type IntegrationWebHook struct {
	Id IntegrationWebHookId `json:"id" url:"id"`
	// The user who created the webHook.
	Creator string `json:"creator" url:"creator"`
	// Status of the WebHook.
	Enabled bool `json:"enabled" url:"enabled"`
	// List of events that trigger the WebHook.
	Events []string `json:"events" url:"events"`
	// A name for the WebHook.
	Name string `json:"name" url:"name"`
	// The content of the webHook, this can be a URL or a specific code, it depends on the provider.
	Value string `json:"value" url:"value"`
	// The date the WebHook was created.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The date the WebHook was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The attributes that are not mapped to the WebHook schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationWebHook) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationWebHook) UnmarshalJSON(data []byte) error {
	type embed IntegrationWebHook
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = IntegrationWebHook(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *IntegrationWebHook) MarshalJSON() ([]byte, error) {
	type embed IntegrationWebHook
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*i),
		CreatedAt: core.NewDateTime(i.CreatedAt),
		UpdatedAt: core.NewOptionalDateTime(i.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (i *IntegrationWebHook) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Unique identifier for a integration webHook
type IntegrationWebHookId = Id

// Notification object
type Notification struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time      `json:"updated_at" url:"updated_at"`
	Id        NotificationId `json:"id" url:"id"`
	// Notification summary.
	Summary string `json:"summary" url:"summary"`
	// Notification priority
	Priority *Priority `json:"priority,omitempty" url:"priority,omitempty"`
	// Notification status
	NotificationStatus *NotificationStatus `json:"notification_status,omitempty" url:"notification_status,omitempty"`
	// Notification project
	Project *string `json:"project,omitempty" url:"project,omitempty"`
	// The current status of the notification.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// Notification description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The notification's type.
	IssueType *string `json:"issue_type,omitempty" url:"issue_type,omitempty"`
	// The user who created this notification.
	Creator *string `json:"creator,omitempty" url:"creator,omitempty"`
	// Who notification is assigned to.
	Assignee *string `json:"assignee,omitempty" url:"assignee,omitempty"`
	// The notification contact information.
	Contact *string `json:"contact,omitempty" url:"contact,omitempty"`
	// Associate tags with Notification
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *Notification) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *Notification) UnmarshalJSON(data []byte) error {
	type embed Notification
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = Notification(unmarshaler.embed)
	n.CreatedAt = unmarshaler.CreatedAt.Time()
	n.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *Notification) MarshalJSON() ([]byte, error) {
	type embed Notification
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*n),
		CreatedAt: core.NewDateTime(n.CreatedAt),
		UpdatedAt: core.NewDateTime(n.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (n *Notification) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationStatus string

const (
	NotificationStatusOpen   NotificationStatus = "OPEN"
	NotificationStatusClosed NotificationStatus = "CLOSED"
)

func NewNotificationStatusFromString(s string) (NotificationStatus, error) {
	switch s {
	case "OPEN":
		return NotificationStatusOpen, nil
	case "CLOSED":
		return NotificationStatusClosed, nil
	}
	var t NotificationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationStatus) Ptr() *NotificationStatus {
	return &n
}

type Operation struct {
	// ID of the operation
	Id AsyncOperationRequestId `json:"id" url:"id"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// Account ID containing the integration.
	AccountId Id `json:"account_id" url:"account_id"`
	// Integration ID to use for the operation.
	IntegrationId Id `json:"integration_id" url:"integration_id"`
	// Run now or on the specified schedule.
	Schedule *OperationSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// Name of the operation that will be run for this operation.
	Operation string `json:"operation" url:"operation"`
	// Parameters for the operation that will be run for this operation.
	Input *OperationInput `json:"input" url:"input"`
	// Status of the operation
	Status OperationStatus `json:"status" url:"status"`
	// Errors that occurred during the operation
	Errors []*OperationError `json:"errors,omitempty" url:"errors,omitempty"`
	// Cpu time in microseconds
	CpuTime int64 `json:"cpu_time" url:"cpu_time"`
	// Number of bytes sent to sink integration
	InBytes int64 `json:"in_bytes" url:"in_bytes"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Operation) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Operation) UnmarshalJSON(data []byte) error {
	type embed Operation
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Operation(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Operation) MarshalJSON() ([]byte, error) {
	type embed Operation
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *Operation) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OperationError struct {
	// Error message
	Message string `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OperationError) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OperationError) UnmarshalJSON(data []byte) error {
	type unmarshaler OperationError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OperationError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OperationError) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OperationInput struct {
	// Limit the number of results returned by the operation. If not specified, the operation will return all results.
	Filters []string `json:"filters,omitempty" url:"filters,omitempty"`
	// Limit query results by these filters.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OperationInput) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OperationInput) UnmarshalJSON(data []byte) error {
	type unmarshaler OperationInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OperationInput(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OperationInput) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OperationSchedule struct {
	// Run now or on the specified time.
	RunAt *time.Time `json:"run_at,omitempty" url:"run_at,omitempty"`
	// Set the interval duration for recuring operations. (minimum 1h)
	Interval *string `json:"interval,omitempty" url:"interval,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OperationSchedule) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OperationSchedule) UnmarshalJSON(data []byte) error {
	type embed OperationSchedule
	var unmarshaler = struct {
		embed
		RunAt *core.DateTime `json:"run_at,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OperationSchedule(unmarshaler.embed)
	o.RunAt = unmarshaler.RunAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OperationSchedule) MarshalJSON() ([]byte, error) {
	type embed OperationSchedule
	var marshaler = struct {
		embed
		RunAt *core.DateTime `json:"run_at,omitempty"`
	}{
		embed: embed(*o),
		RunAt: core.NewOptionalDateTime(o.RunAt),
	}
	return json.Marshal(marshaler)
}

func (o *OperationSchedule) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OperationStatus string

const (
	OperationStatusScheduled  OperationStatus = "SCHEDULED"
	OperationStatusProcessing OperationStatus = "PROCESSING"
	OperationStatusCancelled  OperationStatus = "CANCELLED"
	OperationStatusComplete   OperationStatus = "COMPLETE"
)

func NewOperationStatusFromString(s string) (OperationStatus, error) {
	switch s {
	case "SCHEDULED":
		return OperationStatusScheduled, nil
	case "PROCESSING":
		return OperationStatusProcessing, nil
	case "CANCELLED":
		return OperationStatusCancelled, nil
	case "COMPLETE":
		return OperationStatusComplete, nil
	}
	var t OperationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OperationStatus) Ptr() *OperationStatus {
	return &o
}

type OperationId string

const (
	OperationIdAppsecGetApplicationFindingDetails       OperationId = "appsec_get_application_finding_details"
	OperationIdAppsecQueryApplicationFindings           OperationId = "appsec_query_application_findings"
	OperationIdAppsecQueryApplications                  OperationId = "appsec_query_applications"
	OperationIdAppsecQueryFindings                      OperationId = "appsec_query_findings"
	OperationIdAssetsCreateAsset                        OperationId = "assets_create_asset"
	OperationIdAssetsGetLabels                          OperationId = "assets_get_labels"
	OperationIdAssetsQueryDevices                       OperationId = "assets_query_devices"
	OperationIdCloudsecurityQueryCloudResourceInventory OperationId = "cloudsecurity_query_cloud_resource_inventory"
	OperationIdCloudsecurityQueryComplianceFindings     OperationId = "cloudsecurity_query_compliance_findings"
	OperationIdCloudsecurityQueryEvents                 OperationId = "cloudsecurity_query_events"
	OperationIdCloudsecurityQueryIoms                   OperationId = "cloudsecurity_query_ioms"
	OperationIdEdrCreateIocs                            OperationId = "edr_create_iocs"
	OperationIdEdrDeleteIocs                            OperationId = "edr_delete_iocs"
	OperationIdEdrGetEndpoint                           OperationId = "edr_get_endpoint"
	OperationIdEdrNetworkQuarantine                     OperationId = "edr_network_quarantine"
	OperationIdEdrQueryAlerts                           OperationId = "edr_query_alerts"
	OperationIdEdrQueryApplications                     OperationId = "edr_query_applications"
	OperationIdEdrQueryEdrEvents                        OperationId = "edr_query_edr_events"
	OperationIdEdrQueryEndpoints                        OperationId = "edr_query_endpoints"
	OperationIdEdrQueryIocs                             OperationId = "edr_query_iocs"
	OperationIdEdrQueryPostureScore                     OperationId = "edr_query_posture_score"
	OperationIdEdrQueryThreatevents                     OperationId = "edr_query_threatevents"
	OperationIdIdentityDisableUser                      OperationId = "identity_disable_user"
	OperationIdIdentityEnableUser                       OperationId = "identity_enable_user"
	OperationIdIdentityExpireAllUserSessions            OperationId = "identity_expire_all_user_sessions"
	OperationIdIdentityForceUserPasswordReset           OperationId = "identity_force_user_password_reset"
	OperationIdIdentityGetGroup                         OperationId = "identity_get_group"
	OperationIdIdentityGetGroupMembers                  OperationId = "identity_get_group_members"
	OperationIdIdentityGetUser                          OperationId = "identity_get_user"
	OperationIdIdentityQueryAuditLog                    OperationId = "identity_query_audit_log"
	OperationIdIdentityQueryGroups                      OperationId = "identity_query_groups"
	OperationIdIdentityQueryUsers                       OperationId = "identity_query_users"
	OperationIdNotificationsClearMessage                OperationId = "notifications_clear_message"
	OperationIdNotificationsCreateMessage               OperationId = "notifications_create_message"
	OperationIdNotificationsGetMessage                  OperationId = "notifications_get_message"
	OperationIdSiemGetEvidence                          OperationId = "siem_get_evidence"
	OperationIdSiemGetInvestigation                     OperationId = "siem_get_investigation"
	OperationIdSiemPatchInvestigation                   OperationId = "siem_patch_investigation"
	OperationIdSiemPostEvents                           OperationId = "siem_post_events"
	OperationIdSiemQueryAlerts                          OperationId = "siem_query_alerts"
	OperationIdSiemQueryEvents                          OperationId = "siem_query_events"
	OperationIdSiemQueryInvestigations                  OperationId = "siem_query_investigations"
	OperationIdSiemQueryLogProviders                    OperationId = "siem_query_log_providers"
	OperationIdSinkPostEvents                           OperationId = "sink_post_events"
	OperationIdStorageDeleteFile                        OperationId = "storage_delete_file"
	OperationIdStorageDownloadFile                      OperationId = "storage_download_file"
	OperationIdStorageListFiles                         OperationId = "storage_list_files"
	OperationIdStorageUploadFile                        OperationId = "storage_upload_file"
	OperationIdTicketingCreateAttachment                OperationId = "ticketing_create_attachment"
	OperationIdTicketingCreateComment                   OperationId = "ticketing_create_comment"
	OperationIdTicketingCreateNote                      OperationId = "ticketing_create_note"
	OperationIdTicketingCreateTicket                    OperationId = "ticketing_create_ticket"
	OperationIdTicketingDeleteAttachment                OperationId = "ticketing_delete_attachment"
	OperationIdTicketingDeleteComment                   OperationId = "ticketing_delete_comment"
	OperationIdTicketingDeleteNote                      OperationId = "ticketing_delete_note"
	OperationIdTicketingDownloadAttachment              OperationId = "ticketing_download_attachment"
	OperationIdTicketingGetTicket                       OperationId = "ticketing_get_ticket"
	OperationIdTicketingListAttachmentsMetadata         OperationId = "ticketing_list_attachments_metadata"
	OperationIdTicketingListComments                    OperationId = "ticketing_list_comments"
	OperationIdTicketingListNotes                       OperationId = "ticketing_list_notes"
	OperationIdTicketingListOnCall                      OperationId = "ticketing_list_on_call"
	OperationIdTicketingListProjects                    OperationId = "ticketing_list_projects"
	OperationIdTicketingListRemoteFields                OperationId = "ticketing_list_remote_fields"
	OperationIdTicketingPatchNote                       OperationId = "ticketing_patch_note"
	OperationIdTicketingPatchTicket                     OperationId = "ticketing_patch_ticket"
	OperationIdTicketingQueryEscalationPolicies         OperationId = "ticketing_query_escalation_policies"
	OperationIdTicketingQueryTickets                    OperationId = "ticketing_query_tickets"
	OperationIdVulnerabilitiesCreateAsset               OperationId = "vulnerabilities_create_asset"
	OperationIdVulnerabilitiesCreateFindings            OperationId = "vulnerabilities_create_findings"
	OperationIdVulnerabilitiesGetScanActivity           OperationId = "vulnerabilities_get_scan_activity"
	OperationIdVulnerabilitiesQueryAssets               OperationId = "vulnerabilities_query_assets"
	OperationIdVulnerabilitiesQueryFindings             OperationId = "vulnerabilities_query_findings"
	OperationIdVulnerabilitiesQueryScans                OperationId = "vulnerabilities_query_scans"
	OperationIdVulnerabilitiesUpdateAsset               OperationId = "vulnerabilities_update_asset"
	OperationIdVulnerabilitiesUpdateFinding             OperationId = "vulnerabilities_update_finding"
)

func NewOperationIdFromString(s string) (OperationId, error) {
	switch s {
	case "appsec_get_application_finding_details":
		return OperationIdAppsecGetApplicationFindingDetails, nil
	case "appsec_query_application_findings":
		return OperationIdAppsecQueryApplicationFindings, nil
	case "appsec_query_applications":
		return OperationIdAppsecQueryApplications, nil
	case "appsec_query_findings":
		return OperationIdAppsecQueryFindings, nil
	case "assets_create_asset":
		return OperationIdAssetsCreateAsset, nil
	case "assets_get_labels":
		return OperationIdAssetsGetLabels, nil
	case "assets_query_devices":
		return OperationIdAssetsQueryDevices, nil
	case "cloudsecurity_query_cloud_resource_inventory":
		return OperationIdCloudsecurityQueryCloudResourceInventory, nil
	case "cloudsecurity_query_compliance_findings":
		return OperationIdCloudsecurityQueryComplianceFindings, nil
	case "cloudsecurity_query_events":
		return OperationIdCloudsecurityQueryEvents, nil
	case "cloudsecurity_query_ioms":
		return OperationIdCloudsecurityQueryIoms, nil
	case "edr_create_iocs":
		return OperationIdEdrCreateIocs, nil
	case "edr_delete_iocs":
		return OperationIdEdrDeleteIocs, nil
	case "edr_get_endpoint":
		return OperationIdEdrGetEndpoint, nil
	case "edr_network_quarantine":
		return OperationIdEdrNetworkQuarantine, nil
	case "edr_query_alerts":
		return OperationIdEdrQueryAlerts, nil
	case "edr_query_applications":
		return OperationIdEdrQueryApplications, nil
	case "edr_query_edr_events":
		return OperationIdEdrQueryEdrEvents, nil
	case "edr_query_endpoints":
		return OperationIdEdrQueryEndpoints, nil
	case "edr_query_iocs":
		return OperationIdEdrQueryIocs, nil
	case "edr_query_posture_score":
		return OperationIdEdrQueryPostureScore, nil
	case "edr_query_threatevents":
		return OperationIdEdrQueryThreatevents, nil
	case "identity_disable_user":
		return OperationIdIdentityDisableUser, nil
	case "identity_enable_user":
		return OperationIdIdentityEnableUser, nil
	case "identity_expire_all_user_sessions":
		return OperationIdIdentityExpireAllUserSessions, nil
	case "identity_force_user_password_reset":
		return OperationIdIdentityForceUserPasswordReset, nil
	case "identity_get_group":
		return OperationIdIdentityGetGroup, nil
	case "identity_get_group_members":
		return OperationIdIdentityGetGroupMembers, nil
	case "identity_get_user":
		return OperationIdIdentityGetUser, nil
	case "identity_query_audit_log":
		return OperationIdIdentityQueryAuditLog, nil
	case "identity_query_groups":
		return OperationIdIdentityQueryGroups, nil
	case "identity_query_users":
		return OperationIdIdentityQueryUsers, nil
	case "notifications_clear_message":
		return OperationIdNotificationsClearMessage, nil
	case "notifications_create_message":
		return OperationIdNotificationsCreateMessage, nil
	case "notifications_get_message":
		return OperationIdNotificationsGetMessage, nil
	case "siem_get_evidence":
		return OperationIdSiemGetEvidence, nil
	case "siem_get_investigation":
		return OperationIdSiemGetInvestigation, nil
	case "siem_patch_investigation":
		return OperationIdSiemPatchInvestigation, nil
	case "siem_post_events":
		return OperationIdSiemPostEvents, nil
	case "siem_query_alerts":
		return OperationIdSiemQueryAlerts, nil
	case "siem_query_events":
		return OperationIdSiemQueryEvents, nil
	case "siem_query_investigations":
		return OperationIdSiemQueryInvestigations, nil
	case "siem_query_log_providers":
		return OperationIdSiemQueryLogProviders, nil
	case "sink_post_events":
		return OperationIdSinkPostEvents, nil
	case "storage_delete_file":
		return OperationIdStorageDeleteFile, nil
	case "storage_download_file":
		return OperationIdStorageDownloadFile, nil
	case "storage_list_files":
		return OperationIdStorageListFiles, nil
	case "storage_upload_file":
		return OperationIdStorageUploadFile, nil
	case "ticketing_create_attachment":
		return OperationIdTicketingCreateAttachment, nil
	case "ticketing_create_comment":
		return OperationIdTicketingCreateComment, nil
	case "ticketing_create_note":
		return OperationIdTicketingCreateNote, nil
	case "ticketing_create_ticket":
		return OperationIdTicketingCreateTicket, nil
	case "ticketing_delete_attachment":
		return OperationIdTicketingDeleteAttachment, nil
	case "ticketing_delete_comment":
		return OperationIdTicketingDeleteComment, nil
	case "ticketing_delete_note":
		return OperationIdTicketingDeleteNote, nil
	case "ticketing_download_attachment":
		return OperationIdTicketingDownloadAttachment, nil
	case "ticketing_get_ticket":
		return OperationIdTicketingGetTicket, nil
	case "ticketing_list_attachments_metadata":
		return OperationIdTicketingListAttachmentsMetadata, nil
	case "ticketing_list_comments":
		return OperationIdTicketingListComments, nil
	case "ticketing_list_notes":
		return OperationIdTicketingListNotes, nil
	case "ticketing_list_on_call":
		return OperationIdTicketingListOnCall, nil
	case "ticketing_list_projects":
		return OperationIdTicketingListProjects, nil
	case "ticketing_list_remote_fields":
		return OperationIdTicketingListRemoteFields, nil
	case "ticketing_patch_note":
		return OperationIdTicketingPatchNote, nil
	case "ticketing_patch_ticket":
		return OperationIdTicketingPatchTicket, nil
	case "ticketing_query_escalation_policies":
		return OperationIdTicketingQueryEscalationPolicies, nil
	case "ticketing_query_tickets":
		return OperationIdTicketingQueryTickets, nil
	case "vulnerabilities_create_asset":
		return OperationIdVulnerabilitiesCreateAsset, nil
	case "vulnerabilities_create_findings":
		return OperationIdVulnerabilitiesCreateFindings, nil
	case "vulnerabilities_get_scan_activity":
		return OperationIdVulnerabilitiesGetScanActivity, nil
	case "vulnerabilities_query_assets":
		return OperationIdVulnerabilitiesQueryAssets, nil
	case "vulnerabilities_query_findings":
		return OperationIdVulnerabilitiesQueryFindings, nil
	case "vulnerabilities_query_scans":
		return OperationIdVulnerabilitiesQueryScans, nil
	case "vulnerabilities_update_asset":
		return OperationIdVulnerabilitiesUpdateAsset, nil
	case "vulnerabilities_update_finding":
		return OperationIdVulnerabilitiesUpdateFinding, nil
	}
	var t OperationId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OperationId) Ptr() *OperationId {
	return &o
}

type CreateOperationResponseResult struct {
	Operation *Operation `json:"operation" url:"operation"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOperationResponseResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOperationResponseResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOperationResponseResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOperationResponseResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateOperationResponseResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type OperationWebhookPayload struct {
	// The event that triggered the webhook
	Event WebhookFilter `json:"event" url:"event"`
	// A unique identifier for this webhook event
	Nonce string `json:"nonce" url:"nonce"`
	// ID of the operation
	Id AsyncOperationRequestId `json:"id" url:"id"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// Run now or on the specified schedule.
	Schedule *OperationSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`
	// Name of the operation that will be run for this operation.
	Operation string `json:"operation" url:"operation"`
	// Account ID containing the integration.
	AccountId Id `json:"account_id" url:"account_id"`
	// Integration ID to use for the operation.
	IntegrationId Id `json:"integration_id" url:"integration_id"`
	// Input parameters for the operation that will be run for this operation.
	Input *OperationInput `json:"input" url:"input"`
	// Status of the operation
	Status OperationStatus `json:"status" url:"status"`
	// Errors that occurred during the operation
	Errors []*OperationError `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OperationWebhookPayload) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OperationWebhookPayload) UnmarshalJSON(data []byte) error {
	type embed OperationWebhookPayload
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OperationWebhookPayload(unmarshaler.embed)
	o.CreatedAt = unmarshaler.CreatedAt.Time()
	o.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *OperationWebhookPayload) MarshalJSON() ([]byte, error) {
	type embed OperationWebhookPayload
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*o),
		CreatedAt: core.NewDateTime(o.CreatedAt),
		UpdatedAt: core.NewDateTime(o.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (o *OperationWebhookPayload) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type WebhookFilter string

const (
	WebhookFilterAll               WebhookFilter = "all"
	WebhookFilterAccountCreate     WebhookFilter = "account_create"
	WebhookFilterAccountDelete     WebhookFilter = "account_delete"
	WebhookFilterAccountUpdate     WebhookFilter = "account_update"
	WebhookFilterIntegrationCreate WebhookFilter = "integration_create"
	WebhookFilterIntegrationDelete WebhookFilter = "integration_delete"
	WebhookFilterIntegrationUpdate WebhookFilter = "integration_update"
	WebhookFilterOperationComplete WebhookFilter = "operation_complete"
)

func NewWebhookFilterFromString(s string) (WebhookFilter, error) {
	switch s {
	case "all":
		return WebhookFilterAll, nil
	case "account_create":
		return WebhookFilterAccountCreate, nil
	case "account_delete":
		return WebhookFilterAccountDelete, nil
	case "account_update":
		return WebhookFilterAccountUpdate, nil
	case "integration_create":
		return WebhookFilterIntegrationCreate, nil
	case "integration_delete":
		return WebhookFilterIntegrationDelete, nil
	case "integration_update":
		return WebhookFilterIntegrationUpdate, nil
	case "operation_complete":
		return WebhookFilterOperationComplete, nil
	}
	var t WebhookFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookFilter) Ptr() *WebhookFilter {
	return &w
}

// Unique identifier for a Webhook
type WebhookId = Id

type Evidence struct {
	// Unique identifier for the investigation associated with the evidence
	InvestigationId string `json:"investigation_id" url:"investigation_id"`
	// Original response from the SIEM
	RawData string `json:"raw_data" url:"raw_data"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Evidence) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Evidence) UnmarshalJSON(data []byte) error {
	type unmarshaler Evidence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Evidence(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *Evidence) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type GetEvidenceResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// The evidence object
	Result map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEvidenceResponseGeneric) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEvidenceResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEvidenceResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEvidenceResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetEvidenceResponseGeneric) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInvestigationResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// The investigation object
	Result map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInvestigationResponseGeneric) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInvestigationResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInvestigationResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInvestigationResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GetInvestigationResponseGeneric) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Investigation struct {
	// Unique identifier for the investigation
	Id string `json:"id" url:"id"`
	// Custom mapped fields from the investigation
	CustomFields map[string]interface{} `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// Original response from the SIEM
	RawData string `json:"raw_data" url:"raw_data"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Investigation) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Investigation) UnmarshalJSON(data []byte) error {
	type unmarshaler Investigation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Investigation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *Investigation) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type LogProvider struct {
	// Some backing providers have multiple log source types. When available, this metadata provides an indication of the backing provider' log provider type.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// Name of the log provider, usable as a filter value for metadata.log_provider when querying for events.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LogProvider) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogProvider) UnmarshalJSON(data []byte) error {
	type unmarshaler LogProvider
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogProvider(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *LogProvider) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type QueryEventStatus string

const (
	// [deprecated] use `QueryStatusPending` instead
	QueryEventStatusPending QueryEventStatus = "PENDING"
	// [deprecated] use `QueryStatusComplete` instead
	QueryEventStatusComplete QueryEventStatus = "COMPLETE"
)

func NewQueryEventStatusFromString(s string) (QueryEventStatus, error) {
	switch s {
	case "PENDING":
		return QueryEventStatusPending, nil
	case "COMPLETE":
		return QueryEventStatusComplete, nil
	}
	var t QueryEventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QueryEventStatus) Ptr() *QueryEventStatus {
	return &q
}

type QueryInvestigationResponseGeneric struct {
	// Various metadata about the results organized by group, then type, then field.
	Meta *MetaResponse `json:"meta,omitempty" url:"meta,omitempty"`
	// Cursor to use to retrieve the next page of results
	Cursor string `json:"cursor" url:"cursor"`
	// List of investigations
	Result []map[string]interface{} `json:"result" url:"result"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QueryInvestigationResponseGeneric) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QueryInvestigationResponseGeneric) UnmarshalJSON(data []byte) error {
	type unmarshaler QueryInvestigationResponseGeneric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QueryInvestigationResponseGeneric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = nil
	return nil
}

func (q *QueryInvestigationResponseGeneric) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type StoragePath struct {
	Path string `json:"path" url:"path"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StoragePath) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StoragePath) UnmarshalJSON(data []byte) error {
	type unmarshaler StoragePath
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StoragePath(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StoragePath) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The actor object either relates gives a summary of an actor in an escalation policy or gives full details of an actor. This depends on the capabilities of the ticketing provider. An actor is someone or something that will be notifed when certain conditions are met. It can either be an agent, a group, or a schedule.
type Actor struct {
	Type            string
	Agent           *Agent
	AgentSummary    *AgentSummary
	GroupSummary    *GroupSummary
	ScheduleSummary *ScheduleSummary
}

func (a *Actor) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "agent":
		value := new(Agent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Agent = value
	case "agent_summary":
		value := new(AgentSummary)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.AgentSummary = value
	case "group_summary":
		value := new(GroupSummary)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.GroupSummary = value
	case "schedule_summary":
		value := new(ScheduleSummary)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.ScheduleSummary = value
	}
	return nil
}

func (a Actor) MarshalJSON() ([]byte, error) {
	if a.Agent != nil {
		return core.MarshalJSONWithExtraProperty(a.Agent, "type", "agent")
	}
	if a.AgentSummary != nil {
		return core.MarshalJSONWithExtraProperty(a.AgentSummary, "type", "agent_summary")
	}
	if a.GroupSummary != nil {
		return core.MarshalJSONWithExtraProperty(a.GroupSummary, "type", "group_summary")
	}
	if a.ScheduleSummary != nil {
		return core.MarshalJSONWithExtraProperty(a.ScheduleSummary, "type", "schedule_summary")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type ActorVisitor interface {
	VisitAgent(*Agent) error
	VisitAgentSummary(*AgentSummary) error
	VisitGroupSummary(*GroupSummary) error
	VisitScheduleSummary(*ScheduleSummary) error
}

func (a *Actor) Accept(visitor ActorVisitor) error {
	if a.Agent != nil {
		return visitor.VisitAgent(a.Agent)
	}
	if a.AgentSummary != nil {
		return visitor.VisitAgentSummary(a.AgentSummary)
	}
	if a.GroupSummary != nil {
		return visitor.VisitGroupSummary(a.GroupSummary)
	}
	if a.ScheduleSummary != nil {
		return visitor.VisitScheduleSummary(a.ScheduleSummary)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

// An agent is a human that can be notified when certain conditions are met
type Agent struct {
	Uid         Id      `json:"uid" url:"uid"`
	FullName    string  `json:"full_name" url:"full_name"`
	EmailAddr   *string `json:"email_addr,omitempty" url:"email_addr,omitempty"`
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	TimeZone    *string `json:"time_zone,omitempty" url:"time_zone,omitempty"`
	JobTitle    *string `json:"job_title,omitempty" url:"job_title,omitempty"`
	// The attributes that are not mapped to the comment schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Agent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Agent) UnmarshalJSON(data []byte) error {
	type unmarshaler Agent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Agent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Agent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The agent summary object gives a summary of an agent in an escalation policy. An agent is a human that can be notified when certain conditions are met
type AgentSummary struct {
	// Unique identifier for the agent.
	Id Id `json:"id" url:"id"`
	// Name of the agent.
	Name string `json:"name" url:"name"`
	// Indicates if the agent has additional properties that can be retrieved.
	AdditionalProperties bool `json:"additional_properties" url:"additional_properties"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AgentSummary) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentSummary(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AgentSummary) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Attachment struct {
	// The name of the file.
	FileName string `json:"file_name" url:"file_name"`
	// The type of the file.
	FileType string `json:"file_type" url:"file_type"`
	// File contents
	Content []byte `json:"content" url:"content"`
	// The attributes that are not mapped to the attachment schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Attachment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Attachment) UnmarshalJSON(data []byte) error {
	type unmarshaler Attachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Attachment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Attachment) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Attachment in a ticketing system
type AttachmentMetadata struct {
	// Unique identifier for this attachment.
	Id AttachmentId `json:"id" url:"id"`
	// The ticket this attachment is associated with.
	TicketId TicketId `json:"ticket_id" url:"ticket_id"`
	// The name of the file.
	FileName string `json:"file_name" url:"file_name"`
	// The type of the file.
	FileType string `json:"file_type" url:"file_type"`
	// The size of the file in bytes.
	FileSize *int `json:"file_size,omitempty" url:"file_size,omitempty"`
	// The date the attachment was created.
	CreatedDate time.Time `json:"created_date" url:"created_date"`
	// The user who created the attachment.
	Creator string `json:"creator" url:"creator"`
	// The attributes that are not mapped to the attachment metadata schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AttachmentMetadata) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttachmentMetadata) UnmarshalJSON(data []byte) error {
	type embed AttachmentMetadata
	var unmarshaler = struct {
		embed
		CreatedDate *core.DateTime `json:"created_date"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AttachmentMetadata(unmarshaler.embed)
	a.CreatedDate = unmarshaler.CreatedDate.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AttachmentMetadata) MarshalJSON() ([]byte, error) {
	type embed AttachmentMetadata
	var marshaler = struct {
		embed
		CreatedDate *core.DateTime `json:"created_date"`
	}{
		embed:       embed(*a),
		CreatedDate: core.NewDateTime(a.CreatedDate),
	}
	return json.Marshal(marshaler)
}

func (a *AttachmentMetadata) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Comment on a ticket.
type Comment struct {
	Id       CommentId `json:"id" url:"id"`
	TicketId TicketId  `json:"ticket_id" url:"ticket_id"`
	// The user who created the comment.
	Creator string `json:"creator" url:"creator"`
	// The content of the comment formatted as markdown.
	Content string `json:"content" url:"content"`
	// The date the comment was created.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The date the comment was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Custom mapped fields for this project.
	CustomFields map[string]interface{} `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The attributes that are not mapped to the comment schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Comment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Comment) UnmarshalJSON(data []byte) error {
	type embed Comment
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Comment(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Comment) MarshalJSON() ([]byte, error) {
	type embed Comment
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Comment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The escalation policy object describes an escalation policy for a ticket. It contains an id for the escalation policy, an optional name, an optional description, and a list of rules.
type EscalationPolicy struct {
	Id          Id                      `json:"id" url:"id"`
	Name        *string                 `json:"name,omitempty" url:"name,omitempty"`
	Description *string                 `json:"description,omitempty" url:"description,omitempty"`
	Rules       []*EscalationPolicyRule `json:"rules" url:"rules"`
	// The attributes that are not mapped to the comment schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EscalationPolicy) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EscalationPolicy) UnmarshalJSON(data []byte) error {
	type unmarshaler EscalationPolicy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EscalationPolicy(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EscalationPolicy) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The escalation policy rule object describes a rule for an escalation policy. It contains an optional id for the rule, a delay in seconds before the next actor is notified, and a list of actors.
type EscalationPolicyRule struct {
	Id           *Id      `json:"id,omitempty" url:"id,omitempty"`
	DelaySeconds int      `json:"delay_seconds" url:"delay_seconds"`
	Actors       []*Actor `json:"actors" url:"actors"`
	// The attributes that are not mapped to the comment schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EscalationPolicyRule) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EscalationPolicyRule) UnmarshalJSON(data []byte) error {
	type unmarshaler EscalationPolicyRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EscalationPolicyRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EscalationPolicyRule) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Unique identifier for a field mapping
type FieldMappingId = Id

// The group summary object gives a summary of a group in an escalation policy. A group is a collection of agents that can be notified when certain conditions are met
type GroupSummary struct {
	// Unique identifier for the group.
	Id Id `json:"id" url:"id"`
	// Name of the group.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates if the group has additional properties that can be retrieved.
	AdditionalProperties bool `json:"additional_properties" url:"additional_properties"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GroupSummary) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupSummary(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *GroupSummary) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Unique identifier for an issue type
type IssueTypeId = string

// Note on a ticket
type Note struct {
	Id       NoteId   `json:"id" url:"id"`
	TicketId TicketId `json:"ticket_id" url:"ticket_id"`
	// The content of the note formatted as markdown.
	Content string `json:"content" url:"content"`
	// The user who created the note.
	Creator string `json:"creator" url:"creator"`
	// The title of the note.
	Title string `json:"title" url:"title"`
	// The date the comment was created.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The date the comment was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Custom mapped fields for this note.
	CustomFields map[string]interface{} `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The attributes that are not mapped to the comment schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *Note) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *Note) UnmarshalJSON(data []byte) error {
	type embed Note
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = Note(unmarshaler.embed)
	n.CreatedAt = unmarshaler.CreatedAt.Time()
	n.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *Note) MarshalJSON() ([]byte, error) {
	type embed Note
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*n),
		CreatedAt: core.NewDateTime(n.CreatedAt),
		UpdatedAt: core.NewOptionalDateTime(n.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (n *Note) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type Priority string

const (
	PriorityUrgent   Priority = "URGENT"
	PriorityCritical Priority = "CRITICAL"
	PriorityHigh     Priority = "HIGH"
	PriorityMedium   Priority = "MEDIUM"
	PriorityModerate Priority = "MODERATE"
	PriorityLow      Priority = "LOW"
	PriorityPlanning Priority = "PLANNING"
)

func NewPriorityFromString(s string) (Priority, error) {
	switch s {
	case "URGENT":
		return PriorityUrgent, nil
	case "CRITICAL":
		return PriorityCritical, nil
	case "HIGH":
		return PriorityHigh, nil
	case "MEDIUM":
		return PriorityMedium, nil
	case "MODERATE":
		return PriorityModerate, nil
	case "LOW":
		return PriorityLow, nil
	case "PLANNING":
		return PriorityPlanning, nil
	}
	var t Priority
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Priority) Ptr() *Priority {
	return &p
}

// Project in a ticketing system
type Project struct {
	// Unique identifier for this project. Use this id in the `project` field of a `Ticket`.
	Id string `json:"id" url:"id"`
	// Name of the project
	Name string `json:"name" url:"name"`
	// Custom mapped fields for this project.
	CustomFields map[string]interface{} `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The attributes that are not mapped to the project schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Project) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Project) UnmarshalJSON(data []byte) error {
	type unmarshaler Project
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Project(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Project) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Unique identifier for a project
type ProjectId = Id

type RemoteField struct {
	// Remote ID of the field.
	FieldId string `json:"field_id" url:"field_id"`
	// Schema of the field.
	Schema *RemoteFieldSchema `json:"schema,omitempty" url:"schema,omitempty"`
	// Scope of remote field - standard or some kind of customization?
	FieldScope RemoteFieldScope `json:"field_scope" url:"field_scope"`
	// Name of field in the remote ticketing provider.
	ProviderFieldName string `json:"provider_field_name" url:"provider_field_name"`
	// Path to the field in the remote ticketing provider. Uses dot notation for nested fields.
	ProviderFieldPath *string `json:"provider_field_path,omitempty" url:"provider_field_path,omitempty"`
	// Project id to which this field is scoped to
	ProjectId *string `json:"project_id,omitempty" url:"project_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RemoteField) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteField) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RemoteField) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldSchema struct {
	FieldTypeId RemoteFieldTypeId `json:"field_type_id" url:"field_type_id"`
	FieldType   *string           `json:"field_Type,omitempty" url:"field_Type,omitempty"`
	// Display names for possible values the enum can take on.
	EnumValues []string `json:"enum_values,omitempty" url:"enum_values,omitempty"`
	// Possible values the enum can take on. For providers which don't distinguish between ID and display name, the ID and display name should be set to the same value.
	EnumOptionValues []*OptionValue `json:"enum_option_values,omitempty" url:"enum_option_values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RemoteFieldSchema) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteFieldSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldSchema(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RemoteFieldSchema) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldScope string

const (
	RemoteFieldScopeStandard          RemoteFieldScope = "standard"
	RemoteFieldScopeIntegrationCustom RemoteFieldScope = "integration_custom"
	RemoteFieldScopeProjectCustom     RemoteFieldScope = "project_custom"
	RemoteFieldScopeTicketCustom      RemoteFieldScope = "ticket_custom"
	RemoteFieldScopeUnknown           RemoteFieldScope = "unknown"
)

func NewRemoteFieldScopeFromString(s string) (RemoteFieldScope, error) {
	switch s {
	case "standard":
		return RemoteFieldScopeStandard, nil
	case "integration_custom":
		return RemoteFieldScopeIntegrationCustom, nil
	case "project_custom":
		return RemoteFieldScopeProjectCustom, nil
	case "ticket_custom":
		return RemoteFieldScopeTicketCustom, nil
	case "unknown":
		return RemoteFieldScopeUnknown, nil
	}
	var t RemoteFieldScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RemoteFieldScope) Ptr() *RemoteFieldScope {
	return &r
}

type RemoteFieldTypeId string

const (
	RemoteFieldTypeIdString RemoteFieldTypeId = "string"
	RemoteFieldTypeIdNumber RemoteFieldTypeId = "number"
	RemoteFieldTypeIdEnum   RemoteFieldTypeId = "enum"
	RemoteFieldTypeIdOther  RemoteFieldTypeId = "other"
)

func NewRemoteFieldTypeIdFromString(s string) (RemoteFieldTypeId, error) {
	switch s {
	case "string":
		return RemoteFieldTypeIdString, nil
	case "number":
		return RemoteFieldTypeIdNumber, nil
	case "enum":
		return RemoteFieldTypeIdEnum, nil
	case "other":
		return RemoteFieldTypeIdOther, nil
	}
	var t RemoteFieldTypeId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RemoteFieldTypeId) Ptr() *RemoteFieldTypeId {
	return &r
}

// The schedule summary object gives a summary of a schedule in an escalation policy. A schedule is a collection of agents that are notified at specific times
type ScheduleSummary struct {
	// Unique identifier for the schedule.
	Id Id `json:"id" url:"id"`
	// Name of the schedule.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates if the schedule has additional properties that can be retrieved.
	AdditionalProperties bool `json:"additional_properties" url:"additional_properties"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScheduleSummary) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduleSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleSummary(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *ScheduleSummary) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Status = string

// Ticketing ticket
type Ticket struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        TicketId  `json:"id" url:"id"`
	// Ticket summary.
	Summary string `json:"summary" url:"summary"`
	// User who created this ticket.
	Creator *string `json:"creator,omitempty" url:"creator,omitempty"`
	// Who ticket is assigned to.
	Assignee *string `json:"assignee,omitempty" url:"assignee,omitempty"`
	// Ticket contact information.
	Contact *string `json:"contact,omitempty" url:"contact,omitempty"`
	// Ticket description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The priority of the Ticket
	Priority *Priority `json:"priority,omitempty" url:"priority,omitempty"`
	// The ticket's due date.
	DueDate *time.Time `json:"due_date,omitempty" url:"due_date,omitempty"`
	// The ticket's complete date.
	CompletionDate *time.Time `json:"completion_date,omitempty" url:"completion_date,omitempty"`
	// The current status of the ticket.
	Status *Status `json:"status,omitempty" url:"status,omitempty"`
	// The ticket project.
	Project *ProjectId `json:"project,omitempty" url:"project,omitempty"`
	// The ticket's type.
	IssueType *IssueTypeId `json:"issue_type,omitempty" url:"issue_type,omitempty"`
	// Associate tags with Ticket
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// Metadata of attachments associated with the ticket
	Attachments []*AttachmentMetadata `json:"attachments,omitempty" url:"attachments,omitempty"`
	// Custom fields for this ticket, keys are the custom field names.
	CustomFields map[string]interface{} `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The attributes that are not mapped to the ticket schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Ticket) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Ticket) UnmarshalJSON(data []byte) error {
	type embed Ticket
	var unmarshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"created_at"`
		UpdatedAt      *core.DateTime `json:"updated_at"`
		DueDate        *core.DateTime `json:"due_date,omitempty"`
		CompletionDate *core.DateTime `json:"completion_date,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Ticket(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	t.DueDate = unmarshaler.DueDate.TimePtr()
	t.CompletionDate = unmarshaler.CompletionDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Ticket) MarshalJSON() ([]byte, error) {
	type embed Ticket
	var marshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"created_at"`
		UpdatedAt      *core.DateTime `json:"updated_at"`
		DueDate        *core.DateTime `json:"due_date,omitempty"`
		CompletionDate *core.DateTime `json:"completion_date,omitempty"`
	}{
		embed:          embed(*t),
		CreatedAt:      core.NewDateTime(t.CreatedAt),
		UpdatedAt:      core.NewDateTime(t.UpdatedAt),
		DueDate:        core.NewOptionalDateTime(t.DueDate),
		CompletionDate: core.NewOptionalDateTime(t.CompletionDate),
	}
	return json.Marshal(marshaler)
}

func (t *Ticket) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Unique identifier for a value mapping
type ValueMappingId = Id

type CreateAssetDevice struct {
	// ID of the device.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// Status of the creation of the asset in the providers system.
	Status CreateAssetStatus `json:"status" url:"status"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAssetDevice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAssetDevice) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAssetDevice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAssetDevice(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateAssetDevice) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateAssetStatus string

const (
	CreateAssetStatusUnknown  CreateAssetStatus = "Unknown"
	CreateAssetStatusPending  CreateAssetStatus = "Pending"
	CreateAssetStatusComplete CreateAssetStatus = "Complete"
)

func NewCreateAssetStatusFromString(s string) (CreateAssetStatus, error) {
	switch s {
	case "Unknown":
		return CreateAssetStatusUnknown, nil
	case "Pending":
		return CreateAssetStatusPending, nil
	case "Complete":
		return CreateAssetStatusComplete, nil
	}
	var t CreateAssetStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateAssetStatus) Ptr() *CreateAssetStatus {
	return &c
}

type CreateFindingsError struct {
	// A descriptive error message providing more information about the issue.
	Message string `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateFindingsError) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFindingsError) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateFindingsError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateFindingsError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateFindingsError) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EventId = Id

type NucleusFindingState struct {
	// Due date for the finding.
	DueDate *time.Time `json:"due_date,omitempty" url:"due_date,omitempty"`
	// Comment to add to the finding.
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NucleusFindingState) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NucleusFindingState) UnmarshalJSON(data []byte) error {
	type embed NucleusFindingState
	var unmarshaler = struct {
		embed
		DueDate *core.DateTime `json:"due_date,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NucleusFindingState(unmarshaler.embed)
	n.DueDate = unmarshaler.DueDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NucleusFindingState) MarshalJSON() ([]byte, error) {
	type embed NucleusFindingState
	var marshaler = struct {
		embed
		DueDate *core.DateTime `json:"due_date,omitempty"`
	}{
		embed:   embed(*n),
		DueDate: core.NewOptionalDateTime(n.DueDate),
	}
	return json.Marshal(marshaler)
}

func (n *NucleusFindingState) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type ProviderSpecificFindingState struct {
	Type    string
	Nucleus *NucleusFindingState
}

func (p *ProviderSpecificFindingState) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "nucleus":
		value := new(NucleusFindingState)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Nucleus = value
	}
	return nil
}

func (p ProviderSpecificFindingState) MarshalJSON() ([]byte, error) {
	if p.Nucleus != nil {
		return core.MarshalJSONWithExtraProperty(p.Nucleus, "type", "nucleus")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type ProviderSpecificFindingStateVisitor interface {
	VisitNucleus(*NucleusFindingState) error
}

func (p *ProviderSpecificFindingState) Accept(visitor ProviderSpecificFindingStateVisitor) error {
	if p.Nucleus != nil {
		return visitor.VisitNucleus(p.Nucleus)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

// Configuration options of a scan.
type ScanConfiguration struct {
	// ID of the scan.
	Uid string `json:"uid" url:"uid"`
	// Name of the scan.
	Name string `json:"name" url:"name"`
	// Time when the scan was created.
	CreationTime *int `json:"creation_time,omitempty" url:"creation_time,omitempty"`
	// Time when the scan was last modified.
	LastModifiedTime *int `json:"last_modified_time,omitempty" url:"last_modified_time,omitempty"`
	// User that owns the scan.
	Owner *User `json:"owner,omitempty" url:"owner,omitempty"`
	// Schedule of the scan if it is a recurring scan.
	Schedule *ScanSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScanConfiguration) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScanConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler ScanConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScanConfiguration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *ScanConfiguration) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScanDayOption string

const (
	ScanDayOptionMonday    ScanDayOption = "Monday"
	ScanDayOptionTuesday   ScanDayOption = "Tuesday"
	ScanDayOptionWednesday ScanDayOption = "Wednesday"
	ScanDayOptionThursday  ScanDayOption = "Thursday"
	ScanDayOptionFriday    ScanDayOption = "Friday"
	ScanDayOptionSaturday  ScanDayOption = "Saturday"
	ScanDayOptionSunday    ScanDayOption = "Sunday"
)

func NewScanDayOptionFromString(s string) (ScanDayOption, error) {
	switch s {
	case "Monday":
		return ScanDayOptionMonday, nil
	case "Tuesday":
		return ScanDayOptionTuesday, nil
	case "Wednesday":
		return ScanDayOptionWednesday, nil
	case "Thursday":
		return ScanDayOptionThursday, nil
	case "Friday":
		return ScanDayOptionFriday, nil
	case "Saturday":
		return ScanDayOptionSaturday, nil
	case "Sunday":
		return ScanDayOptionSunday, nil
	}
	var t ScanDayOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScanDayOption) Ptr() *ScanDayOption {
	return &s
}

type ScanFrequencyOption string

const (
	ScanFrequencyOptionOnce    ScanFrequencyOption = "once"
	ScanFrequencyOptionDaily   ScanFrequencyOption = "daily"
	ScanFrequencyOptionWeekly  ScanFrequencyOption = "weekly"
	ScanFrequencyOptionMonthly ScanFrequencyOption = "monthly"
	ScanFrequencyOptionYearly  ScanFrequencyOption = "yearly"
	ScanFrequencyOptionUnknown ScanFrequencyOption = "unknown"
)

func NewScanFrequencyOptionFromString(s string) (ScanFrequencyOption, error) {
	switch s {
	case "once":
		return ScanFrequencyOptionOnce, nil
	case "daily":
		return ScanFrequencyOptionDaily, nil
	case "weekly":
		return ScanFrequencyOptionWeekly, nil
	case "monthly":
		return ScanFrequencyOptionMonthly, nil
	case "yearly":
		return ScanFrequencyOptionYearly, nil
	case "unknown":
		return ScanFrequencyOptionUnknown, nil
	}
	var t ScanFrequencyOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScanFrequencyOption) Ptr() *ScanFrequencyOption {
	return &s
}

type ScanSchedule struct {
	// Time of the day when the scan are repeated. For scans that are executed once, this is the time when the scan was started. This is formatted as `HH:MM:SS`.
	Time string `json:"time" url:"time"`
	// Periodicity of the scan; for example, weekly, means that the scan will be repeated every `repeat_interval` weeks.
	Frequency ScanFrequencyOption `json:"frequency" url:"frequency"`
	// Number of days, weeks, months, or years between scans. For example, `1` means that the scan will be repeated once every `frequency` period.
	RepeatInterval int `json:"repeat_interval" url:"repeat_interval"`
	// Days of the week when the scan will be repeated. For example, `["monday", "friday"]`
	// means that the scan will be repeated on Monday and Friday on the schedule defined by
	// `frequency` and `repeat_interval`.
	Days []string `json:"days,omitempty" url:"days,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScanSchedule) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScanSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler ScanSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScanSchedule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *ScanSchedule) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Result of a vulnerability scan. Represented by OCSF Security Finding class (class_uid 2001).
type SecurityFinding = *securityfinding.SecurityFinding

type User struct {
	// ID of the user.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = nil
	return nil
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Values supported by using severity as a filter. Supports `[eq]` and `[in]` operators.
// For example, `severity[eq]critical` or `severity[in]critical, high`.
type VulnerabilitySeverityFilterValue string

const (
	// Action is required immediately and the scope is broad.
	VulnerabilitySeverityFilterValueCritical VulnerabilitySeverityFilterValue = "critical"
	// Action is required immediately.
	VulnerabilitySeverityFilterValueHigh VulnerabilitySeverityFilterValue = "high"
	// Action is required but the situation is not serious at this time.
	VulnerabilitySeverityFilterValueMedium VulnerabilitySeverityFilterValue = "medium"
	// The user decides if action is needed.
	VulnerabilitySeverityFilterValueLow VulnerabilitySeverityFilterValue = "low"
	// Informational message. No action required.
	VulnerabilitySeverityFilterValueInfo VulnerabilitySeverityFilterValue = "info"
)

func NewVulnerabilitySeverityFilterValueFromString(s string) (VulnerabilitySeverityFilterValue, error) {
	switch s {
	case "critical":
		return VulnerabilitySeverityFilterValueCritical, nil
	case "high":
		return VulnerabilitySeverityFilterValueHigh, nil
	case "medium":
		return VulnerabilitySeverityFilterValueMedium, nil
	case "low":
		return VulnerabilitySeverityFilterValueLow, nil
	case "info":
		return VulnerabilitySeverityFilterValueInfo, nil
	}
	var t VulnerabilitySeverityFilterValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VulnerabilitySeverityFilterValue) Ptr() *VulnerabilitySeverityFilterValue {
	return &v
}

// The normalized state identifier of a security finding
type VulnerabilityStateFilterValue string

const (
	VulnerabilityStateFilterValueUnknown    VulnerabilityStateFilterValue = "Unknown"
	VulnerabilityStateFilterValueNew        VulnerabilityStateFilterValue = "New"
	VulnerabilityStateFilterValueInProgress VulnerabilityStateFilterValue = "InProgress"
	VulnerabilityStateFilterValueResolved   VulnerabilityStateFilterValue = "Resolved"
	VulnerabilityStateFilterValueOther      VulnerabilityStateFilterValue = "Other"
)

func NewVulnerabilityStateFilterValueFromString(s string) (VulnerabilityStateFilterValue, error) {
	switch s {
	case "Unknown":
		return VulnerabilityStateFilterValueUnknown, nil
	case "New":
		return VulnerabilityStateFilterValueNew, nil
	case "InProgress":
		return VulnerabilityStateFilterValueInProgress, nil
	case "Resolved":
		return VulnerabilityStateFilterValueResolved, nil
	case "Other":
		return VulnerabilityStateFilterValueOther, nil
	}
	var t VulnerabilityStateFilterValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VulnerabilityStateFilterValue) Ptr() *VulnerabilityStateFilterValue {
	return &v
}
