// This file was auto-generated by Fern from our API Definition.

package engine

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/synqly/go-sdk/client/engine/core"
	accountchange "github.com/synqly/go-sdk/client/engine/ocsf/v110/accountchange"
	apiactivity "github.com/synqly/go-sdk/client/engine/ocsf/v110/apiactivity"
	authentication "github.com/synqly/go-sdk/client/engine/ocsf/v110/authentication"
	compliancefinding "github.com/synqly/go-sdk/client/engine/ocsf/v110/compliancefinding"
	fileactivity "github.com/synqly/go-sdk/client/engine/ocsf/v110/fileactivity"
	groupmanagement "github.com/synqly/go-sdk/client/engine/ocsf/v110/groupmanagement"
	moduleactivity "github.com/synqly/go-sdk/client/engine/ocsf/v110/moduleactivity"
	networkactivity "github.com/synqly/go-sdk/client/engine/ocsf/v110/networkactivity"
	processactivity "github.com/synqly/go-sdk/client/engine/ocsf/v110/processactivity"
	scheduledjobactivity "github.com/synqly/go-sdk/client/engine/ocsf/v110/scheduledjobactivity"
	securityfinding "github.com/synqly/go-sdk/client/engine/ocsf/v110/securityfinding"
	webresourceaccessactivity "github.com/synqly/go-sdk/client/engine/ocsf/v110/webresourceaccessactivity"
	configstate "github.com/synqly/go-sdk/client/engine/ocsf/v130/configstate"
	detectionfinding "github.com/synqly/go-sdk/client/engine/ocsf/v130/detectionfinding"
	incidentfinding "github.com/synqly/go-sdk/client/engine/ocsf/v130/incidentfinding"
	inventoryinfo "github.com/synqly/go-sdk/client/engine/ocsf/v130/inventoryinfo"
	softwareinfo "github.com/synqly/go-sdk/client/engine/ocsf/v130/softwareinfo"
	vulnerabilityfinding "github.com/synqly/go-sdk/client/engine/ocsf/v130/vulnerabilityfinding"
	time "time"
)

// Device inventory information. Represented by OCSF Device Inventory Info class (class_uid 5001).
type Device = *inventoryinfo.InventoryInfo

type Base struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Base) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Base) UnmarshalJSON(data []byte) error {
	type embed Base
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Base(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *Base) MarshalJSON() ([]byte, error) {
	type embed Base
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewDateTime(b.CreatedAt),
		UpdatedAt: core.NewDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *Base) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BaseResourceRequest struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BaseResourceRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseResourceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseResourceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseResourceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = nil
	return nil
}

func (b *BaseResourceRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ErrorBody struct {
	Status     int           `json:"status" url:"status"`
	Message    *string       `json:"message,omitempty" url:"message,omitempty"`
	Errors     []string      `json:"errors,omitempty" url:"errors,omitempty"`
	Parameters []*ErrorParam `json:"parameters,omitempty" url:"parameters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ErrorBody) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorBody(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *ErrorBody) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorParam struct {
	Name  string `json:"name" url:"name"`
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ErrorParam) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorParam) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorParam
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorParam(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *ErrorParam) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type MetaApi struct {
	Response *MetaApiResponse `json:"response,omitempty" url:"response,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaApi) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaApi) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaApi(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaApi) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetaApiPrimaryResponse struct {
	// The endpoint URL of the primary API request made to fulfill the response.
	Endpoint string `json:"endpoint" url:"endpoint"`
	// The response from the primary API request.
	Response string `json:"response" url:"response"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaApiPrimaryResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaApiPrimaryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaApiPrimaryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaApiPrimaryResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaApiPrimaryResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetaApiResponse struct {
	Primary *MetaApiPrimaryResponse `json:"primary,omitempty" url:"primary,omitempty"`
	// All responses from backing API calls, indexed by endpoint URL.
	List map[string][]string `json:"list,omitempty" url:"list,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaApiResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaApiResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaApiResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaApiResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaApiResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetaResponse struct {
	// Statistics about items contained in the response.
	Stats *MetaStats `json:"stats,omitempty" url:"stats,omitempty"`
	// Information about backing API requests made to fulfill the response.
	Api *MetaApi `json:"api,omitempty" url:"api,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetaStats struct {
	// A count of total response times. If present "\*" will be all items, or they can be faceted into specific categories.
	Count map[string]int64 `json:"count,omitempty" url:"count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetaStats) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetaStats) UnmarshalJSON(data []byte) error {
	type unmarshaler MetaStats
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetaStats(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MetaStats) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The Object type is used to represent an object with arbitrary fields. The keys are strings and the values are any type.
type Object = map[string]interface{}

type OrderOptions string

const (
	OrderOptionsAsc  OrderOptions = "asc"
	OrderOptionsDesc OrderOptions = "desc"
)

func NewOrderOptionsFromString(s string) (OrderOptions, error) {
	switch s {
	case "asc":
		return OrderOptionsAsc, nil
	case "desc":
		return OrderOptionsDesc, nil
	}
	var t OrderOptions
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderOptions) Ptr() *OrderOptions {
	return &o
}

type PatchOp string

const (
	PatchOpAdd     PatchOp = "add"
	PatchOpCopy    PatchOp = "copy"
	PatchOpMove    PatchOp = "move"
	PatchOpRemove  PatchOp = "remove"
	PatchOpReplace PatchOp = "replace"
	PatchOpTest    PatchOp = "test"
)

func NewPatchOpFromString(s string) (PatchOp, error) {
	switch s {
	case "add":
		return PatchOpAdd, nil
	case "copy":
		return PatchOpCopy, nil
	case "move":
		return PatchOpMove, nil
	case "remove":
		return PatchOpRemove, nil
	case "replace":
		return PatchOpReplace, nil
	case "test":
		return PatchOpTest, nil
	}
	var t PatchOp
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PatchOp) Ptr() *PatchOp {
	return &p
}

type QueryStatus string

const (
	QueryStatusPending  QueryStatus = "PENDING"
	QueryStatusComplete QueryStatus = "COMPLETE"
)

func NewQueryStatusFromString(s string) (QueryStatus, error) {
	switch s {
	case "PENDING":
		return QueryStatusPending, nil
	case "COMPLETE":
		return QueryStatusComplete, nil
	}
	var t QueryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QueryStatus) Ptr() *QueryStatus {
	return &q
}

// Application information represented by the extended OCSF Software Info event. The Product object describes characteristics of a software product.
type Application = *softwareinfo.SoftwareInfo

type ConnectionState string

const (
	ConnectionStateConnect    ConnectionState = "Connect"
	ConnectionStateDisconnect ConnectionState = "Disconnect"
)

func NewConnectionStateFromString(s string) (ConnectionState, error) {
	switch s {
	case "Connect":
		return ConnectionStateConnect, nil
	case "Disconnect":
		return ConnectionStateDisconnect, nil
	}
	var t ConnectionState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionState) Ptr() *ConnectionState {
	return &c
}

// The posture score of an endpoint asset.
type PostureScore = *configstate.ConfigState

// Threat event information represented by OCSF Threat object. The Threat object describes characteristics of a threat event.
type ThreatEvent = *detectionfinding.DetectionFinding

type Event struct {
	ClassName                 string
	AccountChange             *accountchange.AccountChange
	ApiActivity               *apiactivity.ApiActivity
	Authentication            *authentication.Authentication
	ComplianceFinding         *compliancefinding.ComplianceFinding
	DetectionFinding          *detectionfinding.DetectionFinding
	FileActivity              *fileactivity.FileActivity
	GroupManagement           *groupmanagement.GroupManagement
	IncidentFinding           *incidentfinding.IncidentFinding
	InventoryInfo             *inventoryinfo.InventoryInfo
	ModuleActivity            *moduleactivity.ModuleActivity
	NetworkActivity           *networkactivity.NetworkActivity
	ProcessActivity           *processactivity.ProcessActivity
	ScheduledJobActivity      *scheduledjobactivity.ScheduledJobActivity
	SecurityFinding           *securityfinding.SecurityFinding
	VulnerabilityFinding      *vulnerabilityfinding.VulnerabilityFinding
	WebResourceAccessActivity *webresourceaccessactivity.WebResourceAccessActivity
}

func (e *Event) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ClassName string `json:"class_name"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.ClassName = unmarshaler.ClassName
	if unmarshaler.ClassName == "" {
		return fmt.Errorf("%T did not include discriminant class_name", e)
	}
	switch unmarshaler.ClassName {
	case "Account Change":
		value := new(accountchange.AccountChange)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.AccountChange = value
	case "API Activity":
		value := new(apiactivity.ApiActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ApiActivity = value
	case "Authentication":
		value := new(authentication.Authentication)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Authentication = value
	case "Compliance Finding":
		value := new(compliancefinding.ComplianceFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ComplianceFinding = value
	case "Detection Finding":
		value := new(detectionfinding.DetectionFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DetectionFinding = value
	case "File Activity":
		value := new(fileactivity.FileActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.FileActivity = value
	case "Group Management":
		value := new(groupmanagement.GroupManagement)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.GroupManagement = value
	case "Incident Finding":
		value := new(incidentfinding.IncidentFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.IncidentFinding = value
	case "Inventory Info":
		value := new(inventoryinfo.InventoryInfo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.InventoryInfo = value
	case "Module Activity":
		value := new(moduleactivity.ModuleActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ModuleActivity = value
	case "Network Activity":
		value := new(networkactivity.NetworkActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.NetworkActivity = value
	case "Process Activity":
		value := new(processactivity.ProcessActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ProcessActivity = value
	case "Scheduled Job Activity":
		value := new(scheduledjobactivity.ScheduledJobActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.ScheduledJobActivity = value
	case "Security Finding":
		value := new(securityfinding.SecurityFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SecurityFinding = value
	case "Vulnerability Finding":
		value := new(vulnerabilityfinding.VulnerabilityFinding)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.VulnerabilityFinding = value
	case "Web Resource Access Activity":
		value := new(webresourceaccessactivity.WebResourceAccessActivity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.WebResourceAccessActivity = value
	}
	return nil
}

func (e Event) MarshalJSON() ([]byte, error) {
	if e.AccountChange != nil {
		return core.MarshalJSONWithExtraProperty(e.AccountChange, "class_name", "Account Change")
	}
	if e.ApiActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ApiActivity, "class_name", "API Activity")
	}
	if e.Authentication != nil {
		return core.MarshalJSONWithExtraProperty(e.Authentication, "class_name", "Authentication")
	}
	if e.ComplianceFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.ComplianceFinding, "class_name", "Compliance Finding")
	}
	if e.DetectionFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.DetectionFinding, "class_name", "Detection Finding")
	}
	if e.FileActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.FileActivity, "class_name", "File Activity")
	}
	if e.GroupManagement != nil {
		return core.MarshalJSONWithExtraProperty(e.GroupManagement, "class_name", "Group Management")
	}
	if e.IncidentFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.IncidentFinding, "class_name", "Incident Finding")
	}
	if e.InventoryInfo != nil {
		return core.MarshalJSONWithExtraProperty(e.InventoryInfo, "class_name", "Inventory Info")
	}
	if e.ModuleActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ModuleActivity, "class_name", "Module Activity")
	}
	if e.NetworkActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.NetworkActivity, "class_name", "Network Activity")
	}
	if e.ProcessActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ProcessActivity, "class_name", "Process Activity")
	}
	if e.ScheduledJobActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.ScheduledJobActivity, "class_name", "Scheduled Job Activity")
	}
	if e.SecurityFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.SecurityFinding, "class_name", "Security Finding")
	}
	if e.VulnerabilityFinding != nil {
		return core.MarshalJSONWithExtraProperty(e.VulnerabilityFinding, "class_name", "Vulnerability Finding")
	}
	if e.WebResourceAccessActivity != nil {
		return core.MarshalJSONWithExtraProperty(e.WebResourceAccessActivity, "class_name", "Web Resource Access Activity")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EventVisitor interface {
	VisitAccountChange(*accountchange.AccountChange) error
	VisitApiActivity(*apiactivity.ApiActivity) error
	VisitAuthentication(*authentication.Authentication) error
	VisitComplianceFinding(*compliancefinding.ComplianceFinding) error
	VisitDetectionFinding(*detectionfinding.DetectionFinding) error
	VisitFileActivity(*fileactivity.FileActivity) error
	VisitGroupManagement(*groupmanagement.GroupManagement) error
	VisitIncidentFinding(*incidentfinding.IncidentFinding) error
	VisitInventoryInfo(*inventoryinfo.InventoryInfo) error
	VisitModuleActivity(*moduleactivity.ModuleActivity) error
	VisitNetworkActivity(*networkactivity.NetworkActivity) error
	VisitProcessActivity(*processactivity.ProcessActivity) error
	VisitScheduledJobActivity(*scheduledjobactivity.ScheduledJobActivity) error
	VisitSecurityFinding(*securityfinding.SecurityFinding) error
	VisitVulnerabilityFinding(*vulnerabilityfinding.VulnerabilityFinding) error
	VisitWebResourceAccessActivity(*webresourceaccessactivity.WebResourceAccessActivity) error
}

func (e *Event) Accept(visitor EventVisitor) error {
	if e.AccountChange != nil {
		return visitor.VisitAccountChange(e.AccountChange)
	}
	if e.ApiActivity != nil {
		return visitor.VisitApiActivity(e.ApiActivity)
	}
	if e.Authentication != nil {
		return visitor.VisitAuthentication(e.Authentication)
	}
	if e.ComplianceFinding != nil {
		return visitor.VisitComplianceFinding(e.ComplianceFinding)
	}
	if e.DetectionFinding != nil {
		return visitor.VisitDetectionFinding(e.DetectionFinding)
	}
	if e.FileActivity != nil {
		return visitor.VisitFileActivity(e.FileActivity)
	}
	if e.GroupManagement != nil {
		return visitor.VisitGroupManagement(e.GroupManagement)
	}
	if e.IncidentFinding != nil {
		return visitor.VisitIncidentFinding(e.IncidentFinding)
	}
	if e.InventoryInfo != nil {
		return visitor.VisitInventoryInfo(e.InventoryInfo)
	}
	if e.ModuleActivity != nil {
		return visitor.VisitModuleActivity(e.ModuleActivity)
	}
	if e.NetworkActivity != nil {
		return visitor.VisitNetworkActivity(e.NetworkActivity)
	}
	if e.ProcessActivity != nil {
		return visitor.VisitProcessActivity(e.ProcessActivity)
	}
	if e.ScheduledJobActivity != nil {
		return visitor.VisitScheduledJobActivity(e.ScheduledJobActivity)
	}
	if e.SecurityFinding != nil {
		return visitor.VisitSecurityFinding(e.SecurityFinding)
	}
	if e.VulnerabilityFinding != nil {
		return visitor.VisitVulnerabilityFinding(e.VulnerabilityFinding)
	}
	if e.WebResourceAccessActivity != nil {
		return visitor.VisitWebResourceAccessActivity(e.WebResourceAccessActivity)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type TicketingWebhookResponse struct {
	// The ID of the ticket in the ticketing system.
	TicketId *string `json:"ticket_id,omitempty" url:"ticket_id,omitempty"`
	// Date pertiment to webhook operation e.g. if its TicketCreated would be creation date. This comes directly from the ticketing system without any date formatting changes.
	EntityDate *string `json:"entity_date,omitempty" url:"entity_date,omitempty"`
	// The priority of the ticket.
	Priority *Priority `json:"priority,omitempty" url:"priority,omitempty"`
	// Short Description of the ticket in the ticketing system.
	ShortDescription *string `json:"short_description,omitempty" url:"short_description,omitempty"`
	// The Raw JSON that was sent by the ticketing system for this webhook event.
	RawPayload string `json:"raw_payload" url:"raw_payload"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TicketingWebhookResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TicketingWebhookResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TicketingWebhookResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TicketingWebhookResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TicketingWebhookResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Notification object
type Notification struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time      `json:"updated_at" url:"updated_at"`
	Id        NotificationId `json:"id" url:"id"`
	// Notification summary.
	Summary string `json:"summary" url:"summary"`
	// Notification priority
	Priority *Priority `json:"priority,omitempty" url:"priority,omitempty"`
	// Notification status
	NotificationStatus *NotificationStatus `json:"notification_status,omitempty" url:"notification_status,omitempty"`
	// Notification project
	Project *string `json:"project,omitempty" url:"project,omitempty"`
	// The current status of the notification.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// Notification description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The notification's type.
	IssueType *string `json:"issue_type,omitempty" url:"issue_type,omitempty"`
	// The user who created this notification.
	Creator *string `json:"creator,omitempty" url:"creator,omitempty"`
	// Who notification is assigned to.
	Assignee *string `json:"assignee,omitempty" url:"assignee,omitempty"`
	// The notification contact information.
	Contact *string `json:"contact,omitempty" url:"contact,omitempty"`
	// Associate tags with Notification
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *Notification) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *Notification) UnmarshalJSON(data []byte) error {
	type embed Notification
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = Notification(unmarshaler.embed)
	n.CreatedAt = unmarshaler.CreatedAt.Time()
	n.UpdatedAt = unmarshaler.UpdatedAt.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *Notification) MarshalJSON() ([]byte, error) {
	type embed Notification
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*n),
		CreatedAt: core.NewDateTime(n.CreatedAt),
		UpdatedAt: core.NewDateTime(n.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (n *Notification) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NotificationStatus string

const (
	NotificationStatusOpen   NotificationStatus = "OPEN"
	NotificationStatusClosed NotificationStatus = "CLOSED"
)

func NewNotificationStatusFromString(s string) (NotificationStatus, error) {
	switch s {
	case "OPEN":
		return NotificationStatusOpen, nil
	case "CLOSED":
		return NotificationStatusClosed, nil
	}
	var t NotificationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NotificationStatus) Ptr() *NotificationStatus {
	return &n
}

type Evidence struct {
	// Unique identifier for the investigation associated with the evidence
	InvestigationId string `json:"investigation_id" url:"investigation_id"`
	// Original response from the SIEM
	RawData string `json:"raw_data" url:"raw_data"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Evidence) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Evidence) UnmarshalJSON(data []byte) error {
	type unmarshaler Evidence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Evidence(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *Evidence) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Investigation struct {
	// Unique identifier for the investigation
	Id string `json:"id" url:"id"`
	// Original response from the SIEM
	RawData string `json:"raw_data" url:"raw_data"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Investigation) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Investigation) UnmarshalJSON(data []byte) error {
	type unmarshaler Investigation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Investigation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *Investigation) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type LogProvider struct {
	// Some backing providers have multiple log source types. When available, this metadata provides an indication of the backing provider' log provider type.
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// Name of the log provider, usable as a filter value for metadata.log_provider when querying for events.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LogProvider) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LogProvider) UnmarshalJSON(data []byte) error {
	type unmarshaler LogProvider
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogProvider(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *LogProvider) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type QueryEventStatus string

const (
	// [deprecated] use `QueryStatusPending` instead
	QueryEventStatusPending QueryEventStatus = "PENDING"
	// [deprecated] use `QueryStatusComplete` instead
	QueryEventStatusComplete QueryEventStatus = "COMPLETE"
)

func NewQueryEventStatusFromString(s string) (QueryEventStatus, error) {
	switch s {
	case "PENDING":
		return QueryEventStatusPending, nil
	case "COMPLETE":
		return QueryEventStatusComplete, nil
	}
	var t QueryEventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QueryEventStatus) Ptr() *QueryEventStatus {
	return &q
}

type StoragePath struct {
	Path string `json:"path" url:"path"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StoragePath) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StoragePath) UnmarshalJSON(data []byte) error {
	type unmarshaler StoragePath
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StoragePath(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *StoragePath) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Attachment struct {
	// The name of the file.
	FileName string `json:"file_name" url:"file_name"`
	// The type of the file.
	FileType string `json:"file_type" url:"file_type"`
	// File contents
	Content []byte `json:"content" url:"content"`
	// The attributes that are not mapped to the attachment schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Attachment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Attachment) UnmarshalJSON(data []byte) error {
	type unmarshaler Attachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Attachment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Attachment) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Attachment in a ticketing system
type AttachmentMetadata struct {
	// Unique identifier for this attachment.
	Id AttachmentId `json:"id" url:"id"`
	// The ticket this attachment is associated with.
	TicketId TicketId `json:"ticket_id" url:"ticket_id"`
	// The name of the file.
	FileName string `json:"file_name" url:"file_name"`
	// The type of the file.
	FileType string `json:"file_type" url:"file_type"`
	// The size of the file in bytes.
	FileSize *int `json:"file_size,omitempty" url:"file_size,omitempty"`
	// The date the attachment was created.
	CreatedDate time.Time `json:"created_date" url:"created_date"`
	// The user who created the attachment.
	Creator string `json:"creator" url:"creator"`
	// The attributes that are not mapped to the attachment metadata schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AttachmentMetadata) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttachmentMetadata) UnmarshalJSON(data []byte) error {
	type embed AttachmentMetadata
	var unmarshaler = struct {
		embed
		CreatedDate *core.DateTime `json:"created_date"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AttachmentMetadata(unmarshaler.embed)
	a.CreatedDate = unmarshaler.CreatedDate.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AttachmentMetadata) MarshalJSON() ([]byte, error) {
	type embed AttachmentMetadata
	var marshaler = struct {
		embed
		CreatedDate *core.DateTime `json:"created_date"`
	}{
		embed:       embed(*a),
		CreatedDate: core.NewDateTime(a.CreatedDate),
	}
	return json.Marshal(marshaler)
}

func (a *AttachmentMetadata) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Comment on a ticket.
type Comment struct {
	Id       CommentId `json:"id" url:"id"`
	TicketId TicketId  `json:"ticket_id" url:"ticket_id"`
	// The user who created the comment.
	Creator string `json:"creator" url:"creator"`
	// The content of the comment formatted as markdown.
	Content string `json:"content" url:"content"`
	// The date the comment was created.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The date the comment was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The attributes that are not mapped to the comment schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Comment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Comment) UnmarshalJSON(data []byte) error {
	type embed Comment
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Comment(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Comment) MarshalJSON() ([]byte, error) {
	type embed Comment
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Comment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Unique identifier for a field mapping
type FieldMappingId = Id

// Unique identifier for an issue type
type IssueTypeId = string

type Priority string

const (
	PriorityUrgent Priority = "URGENT"
	PriorityHigh   Priority = "HIGH"
	PriorityMedium Priority = "MEDIUM"
	PriorityLow    Priority = "LOW"
)

func NewPriorityFromString(s string) (Priority, error) {
	switch s {
	case "URGENT":
		return PriorityUrgent, nil
	case "HIGH":
		return PriorityHigh, nil
	case "MEDIUM":
		return PriorityMedium, nil
	case "LOW":
		return PriorityLow, nil
	}
	var t Priority
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Priority) Ptr() *Priority {
	return &p
}

// Project in a ticketing system
type Project struct {
	// Unique identifier for this project. Use this id in the `project` field of a `Ticket`.
	Id string `json:"id" url:"id"`
	// Name of the project
	Name string `json:"name" url:"name"`
	// The attributes that are not mapped to the project schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Project) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Project) UnmarshalJSON(data []byte) error {
	type unmarshaler Project
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Project(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Project) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Unique identifier for a project
type ProjectId = Id

type RemoteField struct {
	// Remote ID of the field.
	FieldId string `json:"field_id" url:"field_id"`
	// Schema of the field.
	Schema *RemoteFieldSchema `json:"schema,omitempty" url:"schema,omitempty"`
	// Scope of remote field - standard or some kind of customization?
	FieldScope RemoteFieldScope `json:"field_scope" url:"field_scope"`
	// Name of field in the remote ticketing provider.
	ProviderFieldName string `json:"provider_field_name" url:"provider_field_name"`
	// Path to the field in the remote ticketing provider. Uses dot notation for nested fields.
	ProviderFieldPath *string `json:"provider_field_path,omitempty" url:"provider_field_path,omitempty"`
	// Project id to which this field is scoped to
	ProjectId *string `json:"project_id,omitempty" url:"project_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RemoteField) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteField) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RemoteField) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldSchema struct {
	FieldTypeId RemoteFieldTypeId `json:"field_type_id" url:"field_type_id"`
	FieldType   *string           `json:"field_Type,omitempty" url:"field_Type,omitempty"`
	EnumValues  []string          `json:"enum_values,omitempty" url:"enum_values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RemoteFieldSchema) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoteFieldSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoteFieldSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoteFieldSchema(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *RemoteFieldSchema) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RemoteFieldScope string

const (
	RemoteFieldScopeStandard          RemoteFieldScope = "standard"
	RemoteFieldScopeIntegrationCustom RemoteFieldScope = "integration_custom"
	RemoteFieldScopeProjectCustom     RemoteFieldScope = "project_custom"
	RemoteFieldScopeTicketCustom      RemoteFieldScope = "ticket_custom"
	RemoteFieldScopeUnknown           RemoteFieldScope = "unknown"
)

func NewRemoteFieldScopeFromString(s string) (RemoteFieldScope, error) {
	switch s {
	case "standard":
		return RemoteFieldScopeStandard, nil
	case "integration_custom":
		return RemoteFieldScopeIntegrationCustom, nil
	case "project_custom":
		return RemoteFieldScopeProjectCustom, nil
	case "ticket_custom":
		return RemoteFieldScopeTicketCustom, nil
	case "unknown":
		return RemoteFieldScopeUnknown, nil
	}
	var t RemoteFieldScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RemoteFieldScope) Ptr() *RemoteFieldScope {
	return &r
}

type RemoteFieldTypeId string

const (
	RemoteFieldTypeIdString RemoteFieldTypeId = "string"
	RemoteFieldTypeIdNumber RemoteFieldTypeId = "number"
	RemoteFieldTypeIdEnum   RemoteFieldTypeId = "enum"
	RemoteFieldTypeIdOther  RemoteFieldTypeId = "other"
)

func NewRemoteFieldTypeIdFromString(s string) (RemoteFieldTypeId, error) {
	switch s {
	case "string":
		return RemoteFieldTypeIdString, nil
	case "number":
		return RemoteFieldTypeIdNumber, nil
	case "enum":
		return RemoteFieldTypeIdEnum, nil
	case "other":
		return RemoteFieldTypeIdOther, nil
	}
	var t RemoteFieldTypeId
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RemoteFieldTypeId) Ptr() *RemoteFieldTypeId {
	return &r
}

type Status = string

// Ticketing ticket
type Ticket struct {
	// Human-readable name for this resource
	Name string `json:"name" url:"name"`
	// Time object was originally created
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// Last time object was updated
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	Id        TicketId  `json:"id" url:"id"`
	// Ticket summary.
	Summary string `json:"summary" url:"summary"`
	// User who created this ticket.
	Creator *string `json:"creator,omitempty" url:"creator,omitempty"`
	// Who ticket is assigned to.
	Assignee *string `json:"assignee,omitempty" url:"assignee,omitempty"`
	// Ticket contact information.
	Contact *string `json:"contact,omitempty" url:"contact,omitempty"`
	// Ticket description.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The priority of the Ticket
	Priority *Priority `json:"priority,omitempty" url:"priority,omitempty"`
	// The ticket's due date.
	DueDate *time.Time `json:"due_date,omitempty" url:"due_date,omitempty"`
	// The ticket's complete date.
	CompletionDate *time.Time `json:"completion_date,omitempty" url:"completion_date,omitempty"`
	// The current status of the ticket.
	Status *Status `json:"status,omitempty" url:"status,omitempty"`
	// The ticket project.
	Project *ProjectId `json:"project,omitempty" url:"project,omitempty"`
	// The ticket's type.
	IssueType *IssueTypeId `json:"issue_type,omitempty" url:"issue_type,omitempty"`
	// Associate tags with Ticket
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// Metadata of attachments associated with the ticket
	Attachments []*AttachmentMetadata `json:"attachments,omitempty" url:"attachments,omitempty"`
	// Custom fields for this ticket, keys are the custom field names.
	CustomFields map[string]interface{} `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The attributes that are not mapped to the ticket schema. The names and values of those attributes are specific to the provider.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Ticket) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Ticket) UnmarshalJSON(data []byte) error {
	type embed Ticket
	var unmarshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"created_at"`
		UpdatedAt      *core.DateTime `json:"updated_at"`
		DueDate        *core.DateTime `json:"due_date,omitempty"`
		CompletionDate *core.DateTime `json:"completion_date,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Ticket(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.UpdatedAt = unmarshaler.UpdatedAt.Time()
	t.DueDate = unmarshaler.DueDate.TimePtr()
	t.CompletionDate = unmarshaler.CompletionDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Ticket) MarshalJSON() ([]byte, error) {
	type embed Ticket
	var marshaler = struct {
		embed
		CreatedAt      *core.DateTime `json:"created_at"`
		UpdatedAt      *core.DateTime `json:"updated_at"`
		DueDate        *core.DateTime `json:"due_date,omitempty"`
		CompletionDate *core.DateTime `json:"completion_date,omitempty"`
	}{
		embed:          embed(*t),
		CreatedAt:      core.NewDateTime(t.CreatedAt),
		UpdatedAt:      core.NewDateTime(t.UpdatedAt),
		DueDate:        core.NewOptionalDateTime(t.DueDate),
		CompletionDate: core.NewOptionalDateTime(t.CompletionDate),
	}
	return json.Marshal(marshaler)
}

func (t *Ticket) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Unique identifier for a value mapping
type ValueMappingId = Id

// Asset in a vulnerability scanning system. Represented by OCSF Device Inventory Info class (class_uid 5001).
type Asset = *inventoryinfo.InventoryInfo

type CreateAssetDevice struct {
	// ID of the device.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateAssetDevice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateAssetDevice) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateAssetDevice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateAssetDevice(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateAssetDevice) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateFindingsError struct {
	// A descriptive error message providing more information about the issue.
	Message string `json:"message" url:"message"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateFindingsError) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFindingsError) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateFindingsError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateFindingsError(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CreateFindingsError) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EventId = Id

// Configuration options of a scan.
type ScanConfiguration struct {
	// ID of the scan.
	Uid string `json:"uid" url:"uid"`
	// Name of the scan.
	Name string `json:"name" url:"name"`
	// Time when the scan was created.
	CreationTime *int `json:"creation_time,omitempty" url:"creation_time,omitempty"`
	// Time when the scan was last modified.
	LastModifiedTime *int `json:"last_modified_time,omitempty" url:"last_modified_time,omitempty"`
	// User that owns the scan.
	Owner *User `json:"owner,omitempty" url:"owner,omitempty"`
	// Schedule of the scan if it is a recurring scan.
	Schedule *ScanSchedule `json:"schedule,omitempty" url:"schedule,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScanConfiguration) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScanConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler ScanConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScanConfiguration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *ScanConfiguration) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScanDayOption string

const (
	ScanDayOptionMonday    ScanDayOption = "Monday"
	ScanDayOptionTuesday   ScanDayOption = "Tuesday"
	ScanDayOptionWednesday ScanDayOption = "Wednesday"
	ScanDayOptionThursday  ScanDayOption = "Thursday"
	ScanDayOptionFriday    ScanDayOption = "Friday"
	ScanDayOptionSaturday  ScanDayOption = "Saturday"
	ScanDayOptionSunday    ScanDayOption = "Sunday"
)

func NewScanDayOptionFromString(s string) (ScanDayOption, error) {
	switch s {
	case "Monday":
		return ScanDayOptionMonday, nil
	case "Tuesday":
		return ScanDayOptionTuesday, nil
	case "Wednesday":
		return ScanDayOptionWednesday, nil
	case "Thursday":
		return ScanDayOptionThursday, nil
	case "Friday":
		return ScanDayOptionFriday, nil
	case "Saturday":
		return ScanDayOptionSaturday, nil
	case "Sunday":
		return ScanDayOptionSunday, nil
	}
	var t ScanDayOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScanDayOption) Ptr() *ScanDayOption {
	return &s
}

type ScanFrequencyOption string

const (
	ScanFrequencyOptionOnce    ScanFrequencyOption = "once"
	ScanFrequencyOptionDaily   ScanFrequencyOption = "daily"
	ScanFrequencyOptionWeekly  ScanFrequencyOption = "weekly"
	ScanFrequencyOptionMonthly ScanFrequencyOption = "monthly"
	ScanFrequencyOptionYearly  ScanFrequencyOption = "yearly"
	ScanFrequencyOptionUnknown ScanFrequencyOption = "unknown"
)

func NewScanFrequencyOptionFromString(s string) (ScanFrequencyOption, error) {
	switch s {
	case "once":
		return ScanFrequencyOptionOnce, nil
	case "daily":
		return ScanFrequencyOptionDaily, nil
	case "weekly":
		return ScanFrequencyOptionWeekly, nil
	case "monthly":
		return ScanFrequencyOptionMonthly, nil
	case "yearly":
		return ScanFrequencyOptionYearly, nil
	case "unknown":
		return ScanFrequencyOptionUnknown, nil
	}
	var t ScanFrequencyOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScanFrequencyOption) Ptr() *ScanFrequencyOption {
	return &s
}

type ScanSchedule struct {
	// Time of the day when the scan are repeated. For scans that are executed once, this is the time when the scan was started. This is formatted as `HH:MM:SS`.
	Time string `json:"time" url:"time"`
	// Periodicity of the scan; for example, weekly, means that the scan will be repeated every `repeat_interval` weeks.
	Frequency ScanFrequencyOption `json:"frequency" url:"frequency"`
	// Number of days, weeks, months, or years between scans. For example, `1` means that the scan will be repeated once every `frequency` period.
	RepeatInterval int `json:"repeat_interval" url:"repeat_interval"`
	// Days of the week when the scan will be repeated. For example, `["monday", "friday"]`
	// means that the scan will be repeated on Monday and Friday on the schedule defined by
	// `frequency` and `repeat_interval`.
	Days []string `json:"days,omitempty" url:"days,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ScanSchedule) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScanSchedule) UnmarshalJSON(data []byte) error {
	type unmarshaler ScanSchedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScanSchedule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *ScanSchedule) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Result of a vulnerability scan. Represented by OCSF Security Finding class (class_uid 2001).
type SecurityFinding = *securityfinding.SecurityFinding

type User struct {
	// ID of the user.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = nil
	return nil
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Values supported by using severity as a filter. Supports `[eq]` and `[in]` operators.
// For example, `severity[eq]critical` or `severity[in]critical, high`.
type VulnerabilitySeverityFilterValue string

const (
	VulnerabilitySeverityFilterValueCritical VulnerabilitySeverityFilterValue = "critical"
	VulnerabilitySeverityFilterValueHigh     VulnerabilitySeverityFilterValue = "high"
	VulnerabilitySeverityFilterValueMedium   VulnerabilitySeverityFilterValue = "medium"
	VulnerabilitySeverityFilterValueLow      VulnerabilitySeverityFilterValue = "low"
	VulnerabilitySeverityFilterValueInfo     VulnerabilitySeverityFilterValue = "info"
)

func NewVulnerabilitySeverityFilterValueFromString(s string) (VulnerabilitySeverityFilterValue, error) {
	switch s {
	case "critical":
		return VulnerabilitySeverityFilterValueCritical, nil
	case "high":
		return VulnerabilitySeverityFilterValueHigh, nil
	case "medium":
		return VulnerabilitySeverityFilterValueMedium, nil
	case "low":
		return VulnerabilitySeverityFilterValueLow, nil
	case "info":
		return VulnerabilitySeverityFilterValueInfo, nil
	}
	var t VulnerabilitySeverityFilterValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VulnerabilitySeverityFilterValue) Ptr() *VulnerabilitySeverityFilterValue {
	return &v
}
