// This file was auto-generated by Fern from our API Definition.

package filehostingactivity

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/synqly/go-sdk/client/engine/core"
	time "time"
)

// Email address. For example:<br><code>john_doe@example.com</code>.
type EmailAddress = string

// File name. For example:<br><code>text-file.txt</code>.
type FileName = string

// The full path to the file. For example: For example:<br><code>c:\windows\system32\svchost.exe</code>.
type FilePath = string

// Hash. A unique value that corresponds to the content of the file, image, ja3_hash or hassh found in the schema. For example:<br> MD5: <code>3172ac7e2b55cbb81f04a6e65855a628</code>.
type Hash = string

// Unique name assigned to a device connected to a computer network. It may be a fully qualified domain name (FQDN). For example:<br><code>r2-d2.example.com.</code>,<br><code>mx.example.com</code>
type Hostname = string

// Internet Protocol address (IP address), in either IPv4 or IPv6 format. For example:<br><code>192.168.200.24</code>, <br> <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>.
type IpAddress = string

// Media Access Control (MAC) address. For example:<br><code>18:36:F3:98:4F:9A</code>.
type MacAddress = string

// The TCP/UDP port number. For example:<br><code>80</code>,<br><code>22</code>.
type Port = int

// Process name. For example:<br><code>Notepad</code>.
type ProcessName = string

// Resource unique identifier. For example, S3 Bucket name or EC2 Instance ID.
type ResourceUid = string

// The subnet represented in a CIDR notation, using the format network_address/prefix_length. The network_address can be in either IPv4 or IPv6 format. The prefix length indicates the number of bits used for the network portion, and the remaining bits are available for host addresses within that subnet. For example:<br><code>192.168.1.0/24</code>,<br><code>2001:0db8:85a3:0000::/64</code>
type Subnet = string

// The timestamp format is the number of milliseconds since the Epoch 01/01/1970 00:00:00 UTC. For example:<br><code>1618524549901</code>.
type Timestamp = int

// Uniform Resource Locator (URL) string. For example:<br><code>http://www.example.com/download/trouble.exe</code>.
type UrlString = string

// User name. For example:<br><code>john_doe</code>.
type UserName = string

// ActionId is an enum, and the following values are allowed.
// 0 - Unknown: The action was unknown. The <code>disposition_id</code> attribute may still be set to a non-unknown value, for example 'Custom Action', 'Challenge'.
// 1 - Allowed: The activity was allowed. The <code>disposition_id</code> attribute should be set to a value that conforms to this action, for example 'Allowed', 'Approved', 'Delayed', 'No Action', 'Count' etc.
// 2 - Denied: The attempted activity was denied. The <code>disposition_id</code> attribute should be set to a value that conforms to this action, for example 'Blocked', 'Rejected', 'Quarantined', 'Isolated', 'Dropped', 'Access Revoked, etc.
// 3 - Observed: The activity was observed, but neither explicitly allowed nor denied. This is common with IDS and EDR controls that report additional information on observed behavior such as TTPs. The <code>disposition_id</code> attribute should be set to a value that conforms to this action, for example 'Logged', 'Alert', 'Detected', 'Count', etc.
// 4 - Modified: The activity was modified, adjusted, or corrected. The <code>disposition_id</code> attribute should be set appropriately, for example 'Restored', 'Corrected', 'Delayed', 'Captcha', 'Tagged'.
// 99 - Other: The action is not mapped. See the <code>action</code> attribute which contains a data source specific value.
type ActionId = int

// ActivityId is an enum, and the following values are allowed.
// 0 - Unknown: The event activity is unknown.
// 1 - Upload: Upload a file.
// 2 - Download: Download a file.
// 3 - Update: Update a file.
// 4 - Delete: Delete a file.
// 5 - Rename: Rename a file.
// 6 - Copy: Copy a file.
// 7 - Move: Move a file.
// 8 - Restore: Restore a file.
// 9 - Preview: Preview a file.
// 10 - Lock: Lock a file.
// 11 - Unlock: Unlock a file.
// 12 - Share: Share a file.
// 13 - Unshare: Unshare a file.
// 14 - Open: Open a file.
// 15 - Sync: Mark a file or folder to sync with a computer.
// 16 - Unsync: Mark a file or folder to not sync with a computer.
// 17 - AccessCheck: Access check for a file. The <code>security_control</code> profile can be used to add the access check results.
// 99 - Other: The event activity is not mapped. See the <code>activity_name</code> attribute, which contains a data source specific value.
type ActivityId = int

// CategoryUid is an enum, and the following values are allowed.
// 6 - ApplicationActivity: Application Activity events report detailed information about the behavior of applications and services.
type CategoryUid = int

// ClassUid is an enum, and the following values are allowed.
// 6006 - FileHostingActivity: File Hosting Activity events report the actions taken by file management applications, including file sharing servers like Sharepoint and services such as Box, MS OneDrive, Google Drive, or network file share services.
type ClassUid = int

// ConfidenceId is an enum, and the following values are allowed.
// 0 - Unknown: The normalized confidence is unknown.
// 1 - Low
// 2 - Medium
// 3 - High
// 99 - Other: The confidence is not mapped to the defined enum values. See the <code>confidence</code> attribute, which contains a data source specific value.
type ConfidenceId = int

// DispositionId is an enum, and the following values are allowed.
// 0 - Unknown: The disposition is unknown.
// 1 - Allowed: Granted access or allowed the action to the protected resource.
// 2 - Blocked: Denied access or blocked the action to the protected resource.
// 3 - Quarantined: A suspicious file or other content was moved to a benign location.
// 4 - Isolated: A session was isolated on the network or within a browser.
// 5 - Deleted: A file or other content was deleted.
// 6 - Dropped: The request was detected as a threat and resulted in the connection being dropped.
// 7 - CustomAction: A custom action was executed such as running of a command script. Use the <code>message</code> attribute of the base class for details.
// 8 - Approved: A request or submission was approved. For example, when a form was properly filled out and submitted. This is distinct from <code>1</code> 'Allowed'.
// 9 - Restored: A quarantined file or other content was restored to its original location.
// 10 - Exonerated: A suspicious or risky entity was deemed to no longer be suspicious (re-scored).
// 11 - Corrected: A corrupt file or configuration was corrected.
// 12 - PartiallyCorrected: A corrupt file or configuration was partially corrected.
// 13 - Uncorrected: A corrupt file or configuration was not corrected.
// 14 - Delayed: An operation was delayed, for example if a restart was required to finish the operation.
// 15 - Detected: Suspicious activity or a policy violation was detected without further action.
// 16 - NoAction: The outcome of an operation had no action taken.
// 17 - Logged: The operation or action was logged without further action.
// 18 - Tagged: A file or other entity was marked with extended attributes.
// 19 - Alert: The request or activity was detected as a threat and resulted in a notification but request was not blocked.
// 20 - Count: Counted the request or activity but did not determine whether to allow it or block it.
// 21 - Reset: The request was detected as a threat and resulted in the connection being reset.
// 22 - Captcha: Required the end user to solve a CAPTCHA puzzle to prove that a human being is sending the request.
// 23 - Challenge: Ran a silent challenge that required the client session to verify that it's a browser, and not a bot.
// 24 - AccessRevoked: The requestor's access has been revoked due to security policy enforcements. Note: use the <code>Host</code> profile if the <code>User</code> or <code>Actor</code> requestor is not present in the event class.
// 25 - Rejected: A request or submission was rejected. For example, when a form was improperly filled out and submitted. This is distinct from <code>2</code> 'Blocked'.
// 26 - Unauthorized: An attempt to access a resource was denied due to an authorization check that failed. This is a more specific disposition than <code>2</code> 'Blocked' and can be complemented with the <code>authorizations</code> attribute for more detail.
// 27 - Error: An error occurred during the processing of the activity or request. Use the <code>message</code> attribute of the base class for details.
// 99 - Other: The disposition is not mapped. See the <code>disposition</code> attribute, which contains a data source specific value.
type DispositionId = int

// File Hosting Activity events report the actions taken by file management applications, including file sharing servers like Sharepoint and services such as Box, MS OneDrive, Google Drive, or network file share services.
type FileHosting struct {
	// The list of requested access rights.
	AccessList []string `json:"access_list,omitempty" url:"access_list,omitempty"`
	// The sum of hexadecimal values of requested access rights.
	AccessMask *int `json:"access_mask,omitempty" url:"access_mask,omitempty"`
	// The list of access check results.
	AccessResult interface{} `json:"access_result,omitempty" url:"access_result,omitempty"`
	// The normalized caption of <code>action_id</code>.
	Action *string `json:"action,omitempty" url:"action,omitempty"`
	// The action taken by a control or other policy-based system leading to an outcome or disposition. An unknown action may still correspond to a known disposition. Refer to <code>disposition_id</code> for the outcome of the action.
	ActionId *ActionId `json:"action_id,omitempty" url:"action_id,omitempty"`
	// The normalized identifier of the activity that triggered the event.
	ActivityId ActivityId `json:"activity_id" url:"activity_id"`
	// The event activity name, as defined by the activity_id.
	ActivityName *string `json:"activity_name,omitempty" url:"activity_name,omitempty"`
	// The actor that performed the activity on the target file.
	Actor *Actor `json:"actor,omitempty" url:"actor,omitempty"`
	// Describes details about a typical API (Application Programming Interface) call.
	Api *Api `json:"api,omitempty" url:"api,omitempty"`
	// An array of MITRE ATT&CK® objects describing identified tactics, techniques & sub-techniques. The objects are compatible with MITRE ATLAS™ tactics, techniques & sub-techniques.
	Attacks []*Attack `json:"attacks,omitempty" url:"attacks,omitempty"`
	// Provides details about an authorization, such as authorization outcome, and any associated policies related to the activity/event.
	Authorizations []*Authorization `json:"authorizations,omitempty" url:"authorizations,omitempty"`
	// The event category name, as defined by category_uid value: <code>Application Activity</code>.
	CategoryName *string `json:"category_name,omitempty" url:"category_name,omitempty"`
	// The category unique identifier of the event.
	CategoryUid CategoryUid `json:"category_uid" url:"category_uid"`
	// The unique identifier of a class. A class describes the attributes available in an event.
	ClassUid ClassUid `json:"class_uid" url:"class_uid"`
	// Describes details about the Cloud environment where the event was originally created or logged.
	Cloud *Cloud `json:"cloud,omitempty" url:"cloud,omitempty"`
	// The confidence, normalized to the caption of the confidence_id value. In the case of 'Other', it is defined by the event source.
	Confidence *string `json:"confidence,omitempty" url:"confidence,omitempty"`
	// The normalized confidence refers to the accuracy of the rule that created the finding. A rule with a low confidence means that the finding scope is wide and may create finding reports that may not be malicious in nature.
	ConfidenceId *ConfidenceId `json:"confidence_id,omitempty" url:"confidence_id,omitempty"`
	// The confidence score as reported by the event source.
	ConfidenceScore *int `json:"confidence_score,omitempty" url:"confidence_score,omitempty"`
	// The network connection information.
	ConnectionInfo *NetworkConnectionInfo `json:"connection_info,omitempty" url:"connection_info,omitempty"`
	// The number of times that events in the same logical group occurred during the event <strong>Start Time</strong> to <strong>End Time</strong> period.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// A list of custom fields
	CustomFields *Object `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// An addressable device, computer system or host.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// The disposition name, normalized to the caption of the disposition_id value. In the case of 'Other', it is defined by the event source.
	Disposition *string `json:"disposition,omitempty" url:"disposition,omitempty"`
	// Describes the outcome or action taken by a security control, such as access control checks, malware detections or various types of policy violations.
	DispositionId *DispositionId `json:"disposition_id,omitempty" url:"disposition_id,omitempty"`
	// The endpoint that received the activity on the target file.
	DstEndpoint *NetworkEndpoint `json:"dst_endpoint,omitempty" url:"dst_endpoint,omitempty"`
	// The event duration or aggregate time, the amount of time the event covers from <code>start_time</code> to <code>end_time</code> in milliseconds.
	Duration *int `json:"duration,omitempty" url:"duration,omitempty"`
	// The end time of a time period, or the time of the most recent event included in the aggregate event.
	EndTime *Timestamp `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The end time of a time period, or the time of the most recent event included in the aggregate event.
	EndTimeDt *time.Time `json:"end_time_dt,omitempty" url:"end_time_dt,omitempty"`
	// The additional information from an external data source, which is associated with the event or a finding. For example add location information for the IP address in the DNS answers:</p><code>[{"name": "answers.ip", "value": "92.24.47.250", "type": "location", "data": {"city": "Socotra", "continent": "Asia", "coordinates": [-25.4153, 17.0743], "country": "YE", "desc": "Yemen"}}]</code>
	Enrichments []*Enrichment `json:"enrichments,omitempty" url:"enrichments,omitempty"`
	// The share expiration time.
	ExpirationTime *Timestamp `json:"expiration_time,omitempty" url:"expiration_time,omitempty"`
	// The share expiration time.
	ExpirationTimeDt *time.Time `json:"expiration_time_dt,omitempty" url:"expiration_time_dt,omitempty"`
	// The file that is the target of the activity.
	File *File `json:"file" url:"file"`
	// The resulting file object when the activity was allowed and successful.
	FileResult *File `json:"file_result,omitempty" url:"file_result,omitempty"`
	// The firewall rule that pertains to the control that triggered the event, if applicable.
	FirewallRule *FirewallRule `json:"firewall_rule,omitempty" url:"firewall_rule,omitempty"`
	// Details about the underlying HTTP request.
	HttpRequest *HttpRequest `json:"http_request,omitempty" url:"http_request,omitempty"`
	// Details about the HTTP response, if available.
	HttpResponse *HttpResponse `json:"http_response,omitempty" url:"http_response,omitempty"`
	// Indicates that the event is considered to be an alertable signal. Should be set to <code>true</code> if <code>disposition_id = Alert</code> among other dispositions, and/or <code>risk_level_id</code> or <code>severity_id</code> of the event is elevated. Not all control events will be alertable, for example if <code>disposition_id = Exonerated</code> or <code>disposition_id = Allowed</code>.
	IsAlert *bool `json:"is_alert,omitempty" url:"is_alert,omitempty"`
	// A list of Malware objects, describing details about the identified malware.
	Malware []*Malware `json:"malware,omitempty" url:"malware,omitempty"`
	// Describes details about the scan job that identified malware on the target system.
	MalwareScanInfo *MalwareScanInfo `json:"malware_scan_info,omitempty" url:"malware_scan_info,omitempty"`
	// The description of the event/finding, as defined by the source.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// The metadata associated with the event or a finding.
	Metadata *Metadata `json:"metadata" url:"metadata"`
	// The observables associated with the event or a finding.
	Observables []*Observable `json:"observables,omitempty" url:"observables,omitempty"`
	// The OSINT (Open Source Intelligence) object contains details related to an indicator such as the indicator itself, related indicators, geolocation, registrar information, subdomains, analyst commentary, and other contextual information. This information can be used to further enrich a detection or finding by providing decisioning support to other analysts and engineers.
	Osint []*Osint `json:"osint,omitempty" url:"osint,omitempty"`
	// The policy that pertains to the control that triggered the event, if applicable. For example the name of an anti-malware policy or an access control policy.
	Policy *Policy `json:"policy,omitempty" url:"policy,omitempty"`
	// The raw event/finding data as received from the source.
	RawData *string `json:"raw_data,omitempty" url:"raw_data,omitempty"`
	// The hash, which describes the content of the raw_data field.
	RawDataHash *Fingerprint `json:"raw_data_hash,omitempty" url:"raw_data_hash,omitempty"`
	// The size of the raw data which was transformed into an OCSF event, in bytes.
	RawDataSize *int `json:"raw_data_size,omitempty" url:"raw_data_size,omitempty"`
	// Describes the risk associated with the finding.
	RiskDetails *string `json:"risk_details,omitempty" url:"risk_details,omitempty"`
	// The risk level, normalized to the caption of the risk_level_id value.
	RiskLevel *string `json:"risk_level,omitempty" url:"risk_level,omitempty"`
	// The normalized risk level id.
	RiskLevelId *RiskLevelId `json:"risk_level_id,omitempty" url:"risk_level_id,omitempty"`
	// The risk score as reported by the event source.
	RiskScore *int `json:"risk_score,omitempty" url:"risk_score,omitempty"`
	// The event/finding severity, normalized to the caption of the <code>severity_id</code> value. In the case of 'Other', it is defined by the source.
	Severity *string `json:"severity,omitempty" url:"severity,omitempty"`
	// <p>The normalized identifier of the event/finding severity.</p>The normalized severity is a measurement the effort and expense required to manage and resolve an event or incident. Smaller numerical values represent lower impact events, and larger numerical values represent higher impact events.
	SeverityId SeverityId `json:"severity_id" url:"severity_id"`
	// The share name.
	Share *string `json:"share,omitempty" url:"share,omitempty"`
	// The share type, normalized to the caption of the share_type_id value. In the case of 'Other', it is defined by the event source.
	ShareType *string `json:"share_type,omitempty" url:"share_type,omitempty"`
	// The normalized identifier of the share type.
	ShareTypeId *ShareTypeId `json:"share_type_id,omitempty" url:"share_type_id,omitempty"`
	// Information about how and with whom a resource was shared, such as sharing permissions and scope.
	Sharing *Sharing `json:"sharing,omitempty" url:"sharing,omitempty"`
	// The endpoint that performed the activity on the target file.
	SrcEndpoint *NetworkEndpoint `json:"src_endpoint" url:"src_endpoint"`
	// The start time of a time period, or the time of the least recent event included in the aggregate event.
	StartTime *Timestamp `json:"start_time,omitempty" url:"start_time,omitempty"`
	// The start time of a time period, or the time of the least recent event included in the aggregate event.
	StartTimeDt *time.Time `json:"start_time_dt,omitempty" url:"start_time_dt,omitempty"`
	// The event status, normalized to the caption of the status_id value. In the case of 'Other', it is defined by the event source.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The event status code, as reported by the event source.<br /><br />For example, in a Windows Failed Authentication event, this would be the value of 'Failure Code', e.g. 0x18.
	StatusCode *string `json:"status_code,omitempty" url:"status_code,omitempty"`
	// The status detail contains additional information about the event/finding outcome.
	StatusDetail *string `json:"status_detail,omitempty" url:"status_detail,omitempty"`
	// The normalized identifier of the event status.
	StatusId *StatusId `json:"status_id,omitempty" url:"status_id,omitempty"`
	// The normalized event occurrence time or the finding creation time.
	Time Timestamp `json:"time" url:"time"`
	// The normalized event occurrence time or the finding creation time.
	TimeDt *time.Time `json:"time_dt,omitempty" url:"time_dt,omitempty"`
	// The number of minutes that the reported event <code>time</code> is ahead or behind UTC, in the range -1,080 to +1,080.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The event/finding type name, as defined by the type_uid.
	TypeName *string `json:"type_name,omitempty" url:"type_name,omitempty"`
	// The event/finding type ID. It identifies the event's semantics and structure. The value is calculated by the logging system as: <code>class_uid \* 100 + activity_id</code>.
	TypeUid TypeUid `json:"type_uid" url:"type_uid"`
	// The attributes that are not mapped to the event schema. The names and values of those attributes are specific to the event source.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FileHosting) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FileHosting) UnmarshalJSON(data []byte) error {
	type embed FileHosting
	var unmarshaler = struct {
		embed
		EndTimeDt        *core.DateTime `json:"end_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
		StartTimeDt      *core.DateTime `json:"start_time_dt,omitempty"`
		TimeDt           *core.DateTime `json:"time_dt,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FileHosting(unmarshaler.embed)
	f.EndTimeDt = unmarshaler.EndTimeDt.TimePtr()
	f.ExpirationTimeDt = unmarshaler.ExpirationTimeDt.TimePtr()
	f.StartTimeDt = unmarshaler.StartTimeDt.TimePtr()
	f.TimeDt = unmarshaler.TimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = nil
	return nil
}

func (f *FileHosting) MarshalJSON() ([]byte, error) {
	type embed FileHosting
	var marshaler = struct {
		embed
		EndTimeDt        *core.DateTime `json:"end_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
		StartTimeDt      *core.DateTime `json:"start_time_dt,omitempty"`
		TimeDt           *core.DateTime `json:"time_dt,omitempty"`
	}{
		embed:            embed(*f),
		EndTimeDt:        core.NewOptionalDateTime(f.EndTimeDt),
		ExpirationTimeDt: core.NewOptionalDateTime(f.ExpirationTimeDt),
		StartTimeDt:      core.NewOptionalDateTime(f.StartTimeDt),
		TimeDt:           core.NewOptionalDateTime(f.TimeDt),
	}
	return json.Marshal(marshaler)
}

func (f *FileHosting) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// RiskLevelId is an enum, and the following values are allowed.
// 0 - Info
// 1 - Low
// 2 - Medium
// 3 - High
// 4 - Critical
// 99 - Other: The risk level is not mapped. See the <code>risk_level</code> attribute, which contains a data source specific value.
type RiskLevelId = int

// SeverityId is an enum, and the following values are allowed.
// 0 - Unknown: The event/finding severity is unknown.
// 1 - Informational: Informational message. No action required.
// 2 - Low: The user decides if action is needed.
// 3 - Medium: Action is required but the situation is not serious at this time.
// 4 - High: Action is required immediately.
// 5 - Critical: Action is required immediately and the scope is broad.
// 6 - Fatal: An error occurred but it is too late to take remedial action.
// 99 - Other: The event/finding severity is not mapped. See the <code>severity</code> attribute, which contains a data source specific value.
type SeverityId = int

// ShareTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The share type is unknown.
// 1 - File
// 2 - Pipe
// 3 - Print
// 99 - Other: The share type is not mapped. See the <code>share_type</code> attribute, which contains a data source specific value.
type ShareTypeId = int

// StatusId is an enum, and the following values are allowed.
// 0 - Unknown: The status is unknown.
// 1 - Success
// 2 - Failure
// 99 - Other: The status is not mapped. See the <code>status</code> attribute, which contains a data source specific value.
type StatusId = int

// TypeUid is an enum, and the following values are allowed.
// 600600 - Unknown
// 600601 - Upload: Upload a file.
// 600602 - Download: Download a file.
// 600603 - Update: Update a file.
// 600604 - Delete: Delete a file.
// 600605 - Rename: Rename a file.
// 600606 - Copy: Copy a file.
// 600607 - Move: Move a file.
// 600608 - Restore: Restore a file.
// 600609 - Preview: Preview a file.
// 600610 - Lock: Lock a file.
// 600611 - Unlock: Unlock a file.
// 600612 - Share: Share a file.
// 600613 - Unshare: Unshare a file.
// 600614 - Open: Open a file.
// 600615 - Sync: Mark a file or folder to sync with a computer.
// 600616 - Unsync: Mark a file or folder to not sync with a computer.
// 600617 - AccessCheck: Access check for a file. The <code>security_control</code> profile can be used to add the access check results.
// 600699 - Other
type TypeUid = int

// The Account object contains details about the account that initiated or performed a specific activity within a system or application. Additionally, the Account object refers to logical Cloud and Software-as-a-Service (SaaS) based containers such as AWS Accounts, Azure Subscriptions, Oracle Cloud Compartments, Google Cloud Projects, and otherwise.
type Account struct {
	// The list of labels associated to the account.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The name of the account (e.g. <code> GCP Project name </code>, <code> Linux Account name </code> or <code> AWS Account name</code>).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The list of tags; <code>{key:value}</code> pairs associated to the account.
	Tags []*KeyValueObject `json:"tags,omitempty" url:"tags,omitempty"`
	// The account type, normalized to the caption of 'account_type_id'. In the case of 'Other', it is defined by the event source.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The normalized account type identifier.
	TypeId *AccountTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique identifier of the account (e.g. <code> AWS Account ID </code>, <code> OCID </code>, <code> GCP Project ID </code>, <code> Azure Subscription ID </code>, <code> Google Workspace Customer ID </code>, or <code> M365 Tenant UID</code>).
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type unmarshaler Account
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Account(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Account) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// AccountTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The account type is unknown.
// 1 - LDAPAccount
// 2 - WindowsAccount
// 3 - AWSIAMUser
// 4 - AWSIAMRole
// 5 - GCPAccount
// 6 - AzureADAccount
// 7 - MacOSAccount
// 8 - AppleAccount
// 9 - LinuxAccount
// 10 - AWSAccount
// 11 - GCPProject
// 12 - OCICompartment
// 13 - AzureSubscription
// 14 - SalesforceAccount
// 15 - GoogleWorkspace
// 16 - ServicenowInstance
// 17 - M365Tenant
// 18 - EmailAccount
// 99 - Other: The account type is not mapped.
type AccountTypeId = int

// The Actor object contains details about the user, role, application, service, or process that initiated or performed a specific activity. Note that Actor is not the threat actor of a campaign but may be part of a campaign.
type Actor struct {
	// The actor type, normalized to the caption of the actor_type_id value. In the case of 'Other', it is defined by the data source.
	ActorType *string `json:"actor_type,omitempty" url:"actor_type,omitempty"`
	// The normalized identifier of the actor type.
	ActorTypeId *ActorActorTypeId `json:"actor_type_id,omitempty" url:"actor_type_id,omitempty"`
	// The client application or service that initiated the activity. This can be in conjunction with the <code>user</code> if present. Note that <code>app_name</code> is distinct from the <code>process</code> if present.
	AppName *string `json:"app_name,omitempty" url:"app_name,omitempty"`
	// The unique identifier of the client application or service that initiated the activity. This can be in conjunction with the <code>user</code> if present. Note that <code>app_name</code> is distinct from the <code>process.pid</code> or <code>process.uid</code> if present.
	AppUid *string `json:"app_uid,omitempty" url:"app_uid,omitempty"`
	// Provides details about an authorization, such as authorization outcome, and any associated policies related to the activity/event.
	Authorizations []*Authorization `json:"authorizations,omitempty" url:"authorizations,omitempty"`
	// Groups which are pertinent to the action. For example, the team name for Teams, where the user may not necessarily be a member of the group, but it is still relevant to the action taken.
	Groups []*Group `json:"groups,omitempty" url:"groups,omitempty"`
	// This object describes details about the Identity Provider used.
	Idp *Idp `json:"idp,omitempty" url:"idp,omitempty"`
	// The name of the service that invoked the activity as described in the event.
	InvokedBy *string `json:"invoked_by,omitempty" url:"invoked_by,omitempty"`
	// The process that initiated the activity.
	Process *Process `json:"process,omitempty" url:"process,omitempty"`
	// The user session from which the activity was initiated.
	Session *Session `json:"session,omitempty" url:"session,omitempty"`
	// The user that initiated the activity or the user context from which the activity was initiated.
	User *User `json:"user,omitempty" url:"user,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Actor) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Actor) UnmarshalJSON(data []byte) error {
	type unmarshaler Actor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Actor(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Actor) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// ActorActorTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The actor type is unknown.
// 1 - Internal: Internal actor.
// 2 - Guest: Guest actor.
// 3 - Federated: Federated actor.
// 99 - Other: The actor type is not mapped. See the actor_type attribute, which contains a data source specific value.
type ActorActorTypeId = int

// The Advisory object represents publicly disclosed cybersecurity vulnerabilities defined in a Security advisory. e.g. <code> Microsoft KB Article</code>, <code>Apple Security Advisory</code>, or a <code>GitHub Security Advisory (GHSA)</code>
type Advisory struct {
	// The average time to patch.
	AvgTimespan *Timespan `json:"avg_timespan,omitempty" url:"avg_timespan,omitempty"`
	// The Advisory bulletin identifier.
	Bulletin *string `json:"bulletin,omitempty" url:"bulletin,omitempty"`
	// The vendors classification of the Advisory.
	Classification *string `json:"classification,omitempty" url:"classification,omitempty"`
	// The time when the Advisory record was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the Advisory record was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// A brief description of the Advisory Record.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The install state of the Advisory.
	InstallState *string `json:"install_state,omitempty" url:"install_state,omitempty"`
	// The normalized install state ID of the Advisory.
	InstallStateId *AdvisoryInstallStateId `json:"install_state_id,omitempty" url:"install_state_id,omitempty"`
	// The Advisory has been replaced by another.
	IsSuperseded *bool `json:"is_superseded,omitempty" url:"is_superseded,omitempty"`
	// The time when the Advisory record was last updated.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The time when the Advisory record was last updated.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The operating system the Advisory applies to.
	Os *Os `json:"os,omitempty" url:"os,omitempty"`
	// The product where the vulnerability was discovered.
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// A list of reference URLs with additional information about the vulnerabilities disclosed in the Advisory.
	References []string `json:"references,omitempty" url:"references,omitempty"`
	// A list of Common Vulnerabilities and Exposures <a target='_blank' href='https://cve.mitre.org/'>(CVE)</a> identifiers related to the vulnerabilities disclosed in the Advisory.
	RelatedCves []*Cve `json:"related_cves,omitempty" url:"related_cves,omitempty"`
	// A list of Common Weakness Enumeration <a target='_blank' href='https://cwe.mitre.org/'>(CWE)</a> identifiers related to the vulnerabilities disclosed in the Advisory.
	RelatedCwes []*Cwe `json:"related_cwes,omitempty" url:"related_cwes,omitempty"`
	// The size in bytes for the Advisory. Usually populated for a KB Article patch.
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// The Advisory link from the source vendor.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// A title or a brief phrase summarizing the Advisory.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// The unique identifier assigned to the advisory or disclosed vulnerability, e.g, <code>GHSA-5mrr-rgp6-x4gr</code>.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Advisory) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Advisory) UnmarshalJSON(data []byte) error {
	type embed Advisory
	var unmarshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Advisory(unmarshaler.embed)
	a.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	a.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Advisory) MarshalJSON() ([]byte, error) {
	type embed Advisory
	var marshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:          embed(*a),
		CreatedTimeDt:  core.NewOptionalDateTime(a.CreatedTimeDt),
		ModifiedTimeDt: core.NewOptionalDateTime(a.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (a *Advisory) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// AdvisoryInstallStateId is an enum, and the following values are allowed.
// 0 - Unknown: The normalized install state is unknown.
// 1 - Installed: The item is installed.
// 2 - NotInstalled: The item is not installed.
// 3 - InstalledPendingReboot: The item is installed pending reboot operation.
// 99 - Other: The install state is not mapped. See the <code>install_state</code> attribute, which contains a data source specific value.
type AdvisoryInstallStateId = int

// The Affected Code object describes details about a code block identified as vulnerable.
type AffectedCode struct {
	// The column number of the last part of the assessed code identified as vulnerable.
	EndColumn *int `json:"end_column,omitempty" url:"end_column,omitempty"`
	// The line number of the last line of code block identified as vulnerable.
	EndLine *int `json:"end_line,omitempty" url:"end_line,omitempty"`
	// Details about the file that contains the affected code block.
	File *File `json:"file" url:"file"`
	// Details about the user that owns the affected file.
	Owner *User `json:"owner,omitempty" url:"owner,omitempty"`
	// Describes the recommended remediation steps to address identified issue(s).
	Remediation *Remediation `json:"remediation,omitempty" url:"remediation,omitempty"`
	// Details about the specific rule, e.g., those defined as part of a larger <code>policy</code>, that triggered the finding.
	Rule *Rule `json:"rule,omitempty" url:"rule,omitempty"`
	// The column number of the first part of the assessed code identified as vulnerable.
	StartColumn *int `json:"start_column,omitempty" url:"start_column,omitempty"`
	// The line number of the first line of code block identified as vulnerable.
	StartLine *int `json:"start_line,omitempty" url:"start_line,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AffectedCode) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AffectedCode) UnmarshalJSON(data []byte) error {
	type unmarshaler AffectedCode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AffectedCode(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AffectedCode) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The Affected Package object describes details about a software package identified as affected by a vulnerability/vulnerabilities.
type AffectedPackage struct {
	// Architecture is a shorthand name describing the type of computer hardware the packaged software is meant to run on.
	Architecture *string `json:"architecture,omitempty" url:"architecture,omitempty"`
	// The Common Platform Enumeration (CPE) name for the software package.
	CpeName *string `json:"cpe_name,omitempty" url:"cpe_name,omitempty"`
	// The software package epoch. Epoch is a way to define weighted dependencies based on version numbers.
	Epoch *int `json:"epoch,omitempty" url:"epoch,omitempty"`
	// The software package version in which a reported vulnerability was patched/fixed.
	FixedInVersion *string `json:"fixed_in_version,omitempty" url:"fixed_in_version,omitempty"`
	// Cryptographic hash to identify the binary instance of a software component. This can include any component such file, package, or library.
	Hash *Fingerprint `json:"hash,omitempty" url:"hash,omitempty"`
	// The software license applied to this package.
	License *string `json:"license,omitempty" url:"license,omitempty"`
	// The URL pointing to the license applied on package or software. This is typically a <code>LICENSE.md</code> file within a repository.
	LicenseUrl *UrlString `json:"license_url,omitempty" url:"license_url,omitempty"`
	// The software package name.
	Name string `json:"name" url:"name"`
	// The software packager manager utilized to manage a package on a system, e.g. npm, yum, dpkg etc.
	PackageManager *string `json:"package_manager,omitempty" url:"package_manager,omitempty"`
	// The URL of the package or library at the package manager, or the specific URL or URI of an internal package manager link such as <code>AWS CodeArtifact</code> or <code>Artifactory</code>.
	PackageManagerUrl *UrlString `json:"package_manager_url,omitempty" url:"package_manager_url,omitempty"`
	// The installation path of the affected package.
	Path *FilePath `json:"path,omitempty" url:"path,omitempty"`
	// A purl is a URL string used to identify and locate a software package in a mostly universal and uniform way across programming languages, package managers, packaging conventions, tools, APIs and databases.
	Purl *string `json:"purl,omitempty" url:"purl,omitempty"`
	// Release is the number of times a version of the software has been packaged.
	Release *string `json:"release,omitempty" url:"release,omitempty"`
	// Describes the recommended remediation steps to address identified issue(s).
	Remediation *Remediation `json:"remediation,omitempty" url:"remediation,omitempty"`
	// The link to the specific library or package such as within <code>GitHub</code>, this is different from the link to the package manager where the library or package is hosted.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The type of software package, normalized to the caption of the <code>type_id</code> value. In the case of 'Other', it is defined by the source.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The type of software package.
	TypeId *AffectedPackageTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// A unique identifier for the package or library reported by the source tool. E.g., the <code>libId</code> within the <code>sbom</code> field of an OX Security Issue or the SPDX <code>components.\*.bom-ref</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the vendor who published the software package.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`
	// The software package version.
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AffectedPackage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AffectedPackage) UnmarshalJSON(data []byte) error {
	type unmarshaler AffectedPackage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AffectedPackage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AffectedPackage) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// AffectedPackageTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Application: An application software package.
// 2 - OperatingSystem: An operating system software package.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type AffectedPackageTypeId = int

// An Agent (also known as a Sensor) is typically installed on an Operating System (OS) and serves as a specialized software component that can be designed to monitor, detect, collect, archive, or take action. These activities and possible actions are defined by the upstream system controlling the Agent and its intended purpose. For instance, an Agent can include Endpoint Detection & Response (EDR) agents, backup/disaster recovery sensors, Application Performance Monitoring or profiling sensors, and similar software.
type Agent struct {
	// The name of the agent or sensor. For example: <code>AWS SSM Agent</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The normalized caption of the type_id value for the agent or sensor. In the case of 'Other' or 'Unknown', it is defined by the event source.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The normalized representation of an agent or sensor. E.g., EDR, vulnerability management, APM, backup & recovery, etc.
	TypeId *AgentTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The UID of the agent or sensor, sometimes known as a Sensor ID or <code>aid</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An alternative or contextual identifier for the agent or sensor, such as a configuration, organization, or license UID.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The company or author who created the agent or sensor. For example: <code>Crowdstrike</code>.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`
	// The semantic version of the agent or sensor, e.g., <code>7.101.50.0</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Agent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Agent) UnmarshalJSON(data []byte) error {
	type unmarshaler Agent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Agent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Agent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// AgentTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - EndpointDetectionandResponse: Any EDR sensor or agent. Or any tool that provides similar threat detection, anti-malware, anti-ransomware, or similar capabilities. E.g., Crowdstrike Falcon, Microsoft Defender for Endpoint, Wazuh.
// 2 - DataLossPrevention: Any DLP sensor or agent. Or any tool that provides similar data classification, data loss detection, and/or data loss prevention capabilities. E.g., Forcepoint DLP, Microsoft Purview, Symantec DLP.
// 3 - Recovery: Any agent or sensor that provides backups, archival, or recovery capabilities. E.g., Azure Backup, AWS Backint Agent.
// 4 - Observability: Any agent or sensor that provides Application Performance Monitoring (APM), active tracing, profiling, or other observability use cases and optionally forwards the logs. E.g., New Relic Agent, Datadog Agent, Azure Monitor Agent.
// 5 - VulnerabilityManagement: Any agent or sensor that provides vulnerability management or scanning capabilities. E.g., Qualys VMDR, Microsoft Defender for Endpoint, Crowdstrike Spotlight, Amazon Inspector Agent.
// 6 - LogForwarding: Any agent or sensor that forwards logs to a 3rd party storage system such as a data lake or SIEM. E.g., Splunk Universal Forwarder, Tenzir, FluentBit, Amazon CloudWatch Agent, Amazon Kinesis Agent.
// 7 - MobileDeviceManagement: Any agent or sensor responsible for providing Mobile Device Management (MDM) or Mobile Enterprise Management (MEM) capabilities. E.g., JumpCloud Agent, Esper Agent, Jamf Pro binary.
// 8 - ConfigurationManagement: Any agent or sensor that provides configuration management of a device, such as scanning for software, license management, or applying configurations. E.g., AWS Systems Manager Agent, Flexera, ServiceNow MID Server.
// 9 - RemoteAccess: Any agent or sensor that provides remote access capabilities to a device. E.g., BeyondTrust, Amazon Systems Manager Agent, Verkada Agent.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type AgentTypeId = int

// The Analytic object contains details about the analytic technique used to analyze and derive insights from the data or information that led to the creation of a finding or conclusion.
type Analytic struct {
	// The algorithm used by the underlying analytic to generate the finding.
	Algorithm *string `json:"algorithm,omitempty" url:"algorithm,omitempty"`
	// The analytic category.
	Category *string `json:"category,omitempty" url:"category,omitempty"`
	// The description of the analytic that generated the finding.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The name of the analytic that generated the finding.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Other analytics related to this analytic.
	RelatedAnalytics []Object `json:"related_analytics,omitempty" url:"related_analytics,omitempty"`
	// The Analytic state.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// The Analytic state identifier.
	StateId *AnalyticStateId `json:"state_id,omitempty" url:"state_id,omitempty"`
	// The analytic type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The analytic type ID.
	TypeId AnalyticTypeId `json:"type_id" url:"type_id"`
	// The unique identifier of the analytic that generated the finding.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The analytic version. For example: <code>1.1</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Analytic) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Analytic) UnmarshalJSON(data []byte) error {
	type unmarshaler Analytic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Analytic(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Analytic) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// AnalyticStateId is an enum, and the following values are allowed.
// 0 - Unknown: The state is unknown.
// 1 - Active: The Analytic is active.
// 2 - Suppressed: The Analytic is suppressed. For example, a user/customer has suppressed a particular detection signature in a security product.
// 3 - Experimental: The Analytic is still under development and considered experimental.
// 99 - Other: The state is not mapped. See the <code>state</code> attribute, which contains a data source specific value.
type AnalyticStateId = int

// AnalyticTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Rule: A Rule in security analytics refers to predefined criteria or conditions set to monitor, alert, or enforce policies, playing a crucial role in access control, threat detection, and regulatory compliance across security systems.
// 2 - Behavioral: Behavioral analytics focus on monitoring and analyzing user or system actions to identify deviations from established patterns, aiding in the detection of insider threats, fraud, and advanced persistent threats (APTs).
// 3 - Statistical: Statistical analytics pertains to analyzing data patterns and anomalies using statistical models to predict, detect, and respond to potential threats, enhancing overall security posture through informed decision-making.
// 4 - ML*DL*: Learning (ML/DL) encompasses techniques that can "learn" from known data to create analytics that generalize to new data. There may be a statistical component to these techniques, but it is not a requirement.
// 5 - Fingerprinting: Fingerprinting is the technique of collecting detailed system data, including software versions and configurations, to enhance threat detection, data loss prevention (DLP), and endpoint detection and response (EDR) capabilities.
// 6 - Tagging: Tagging refers to the practice of assigning labels or identifiers to data, users, assets, or activities to monitor, control access, and facilitate incident response across various security domains such as DLP and EDR.
// 7 - KeywordMatch: Keyword Match involves scanning content for specific terms to identify sensitive information, potential threats, or policy violations, aiding in DLP and compliance monitoring.
// 8 - RegularExpressions: Regular Expressions are used to define complex search patterns for identifying, validating, and extracting specific data sets or threats within digital content, enhancing DLP, EDR, and threat detection mechanisms.
// 9 - ExactDataMatch: Exact Data Match is a precise comparison technique used to detect the unauthorized use or exposure of specific, sensitive information, crucial for enforcing DLP policies and protecting against data breaches.
// 10 - PartialDataMatch: Partial Data Match involves identifying instances where segments of sensitive information or patterns match, facilitating nuanced DLP and threat detection without requiring complete data conformity.
// 11 - IndexedDataMatch: Indexed Data Match refers to comparing content against a pre-compiled index of sensitive information to efficiently detect and prevent unauthorized access or breaches, streamlining DLP and compliance efforts.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type AnalyticTypeId = int

// The API, or Application Programming Interface, object represents information pertaining to an API request and response.
type Api struct {
	// The information pertaining to the API group.
	Group *Group `json:"group,omitempty" url:"group,omitempty"`
	// Verb/Operation associated with the request
	Operation string `json:"operation" url:"operation"`
	// Details pertaining to the API request.
	Request *Request `json:"request,omitempty" url:"request,omitempty"`
	// Details pertaining to the API response.
	Response *Response `json:"response,omitempty" url:"response,omitempty"`
	// The information pertaining to the API service.
	Service *Service `json:"service,omitempty" url:"service,omitempty"`
	// The version of the API service.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Api) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Api) UnmarshalJSON(data []byte) error {
	type unmarshaler Api
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Api(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Api) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The MITRE ATT&CK® & ATLAS™ object describes the tactic, technique, sub-technique & mitigation associated to an attack.
type Attack struct {
	// The Mitigation object describes the MITRE ATT&CK® or ATLAS™ Mitigation ID and/or name that is associated to an attack.
	Mitigation *Mitigation `json:"mitigation,omitempty" url:"mitigation,omitempty"`
	// The Sub-technique object describes the MITRE ATT&CK® or ATLAS™ Sub-technique ID and/or name associated to an attack.
	SubTechnique *SubTechnique `json:"sub_technique,omitempty" url:"sub_technique,omitempty"`
	// The Tactic object describes the MITRE ATT&CK® or ATLAS™ Tactic ID and/or name that is associated to an attack.
	Tactic *Tactic `json:"tactic,omitempty" url:"tactic,omitempty"`
	// The Tactic object describes the tactic ID and/or tactic name that are associated with the attack technique, as defined by <a target='_blank' href='https://attack.mitre.org/wiki/ATT&CK_Matrix'>ATT&CK® Matrix</a>.
	Tactics []*Tactic `json:"tactics,omitempty" url:"tactics,omitempty"`
	// The Technique object describes the MITRE ATT&CK® or ATLAS™ Technique ID and/or name associated to an attack.
	Technique *Technique `json:"technique,omitempty" url:"technique,omitempty"`
	// The ATT&CK® or ATLAS™ Matrix version.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Attack) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Attack) UnmarshalJSON(data []byte) error {
	type unmarshaler Attack
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Attack(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Attack) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// An Authentication Factor object describes a category of methods used for identity verification in an authentication attempt.
type AuthFactor struct {
	// Device used to complete an authentication request.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// The email address used in an email-based authentication factor.
	EmailAddr *EmailAddress `json:"email_addr,omitempty" url:"email_addr,omitempty"`
	// The type of authentication factor used in an authentication attempt.
	FactorType *string `json:"factor_type,omitempty" url:"factor_type,omitempty"`
	// The normalized identifier for the authentication factor.
	FactorTypeId AuthFactorFactorTypeId `json:"factor_type_id" url:"factor_type_id"`
	// Whether the authentication factor is an HMAC-based One-time Password (HOTP).
	IsHotp *bool `json:"is_hotp,omitempty" url:"is_hotp,omitempty"`
	// Whether the authentication factor is a Time-based One-time Password (TOTP).
	IsTotp *bool `json:"is_totp,omitempty" url:"is_totp,omitempty"`
	// The phone number used for a telephony-based authentication request.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The name of provider for an authentication factor.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// The question(s) provided to user for a question-based authentication factor.
	SecurityQuestions []string `json:"security_questions,omitempty" url:"security_questions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AuthFactor) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AuthFactor) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthFactor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthFactor(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AuthFactor) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// AuthFactorFactorTypeId is an enum, and the following values are allowed.
// 0 - Unknown
// 1 - SMS: User receives and inputs a code sent to their mobile device via SMS text message.
// 2 - SecurityQuestion: The user responds to a security question as part of a question-based authentication factor
// 3 - PhoneCall: System calls the user's registered phone number and requires the user to answer and provide a response.
// 4 - Biometric: Devices that verify identity-based on user's physical identifiers, such as fingerprint scanners or retina scanners.
// 5 - PushNotification: Push notification is sent to user's registered device and requires the user to acknowledge.
// 6 - HardwareToken: Physical device that generates a code to be used for authentication.
// 7 - OTP: Application generates a one-time password (OTP) for use in authentication.
// 8 - Email: A code or link is sent to a user's registered email address.
// 9 - U2F: Typically involves a hardware token, which the user physically interacts with to authenticate.
// 10 - WebAuthn: Web-based API that enables users to register devices as authentication factors.
// 11 - Password: The user enters a password that they have previously established.
// 99 - Other
type AuthFactorFactorTypeId = int

// The Authorization Result object provides details about the authorization outcome and associated policies related to activity.
type Authorization struct {
	// Authorization Result/outcome, e.g. allowed, denied.
	Decision *string `json:"decision,omitempty" url:"decision,omitempty"`
	// Details about the Identity/Access management policies that are applicable.
	Policy *Policy `json:"policy,omitempty" url:"policy,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Authorization) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Authorization) UnmarshalJSON(data []byte) error {
	type unmarshaler Authorization
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Authorization(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Authorization) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// An autonomous system (AS) is a collection of connected Internet Protocol (IP) routing prefixes under the control of one or more network operators on behalf of a single administrative entity or domain that presents a common, clearly defined routing policy to the internet.
type AutonomousSystem struct {
	// Organization name for the Autonomous System.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Unique number that the AS is identified by.
	Number *int `json:"number,omitempty" url:"number,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AutonomousSystem) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AutonomousSystem) UnmarshalJSON(data []byte) error {
	type unmarshaler AutonomousSystem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutonomousSystem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *AutonomousSystem) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Campaign represent organized efforts by threat actors to achieve malicious objectives over a period, often characterized by shared tactics, techniques, and procedures (TTPs).
type Campaign struct {
	// The name of a specific campaign associated with a cyber threat.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Campaign) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Campaign) UnmarshalJSON(data []byte) error {
	type unmarshaler Campaign
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Campaign(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Campaign) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Digital Certificate, also known as a Public Key Certificate, object contains information about the ownership and usage of a public key. It serves as a means to establish trust in the authenticity and integrity of the public key and the associated entity.
type Certificate struct {
	// The time when the certificate was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the certificate was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The expiration time of the certificate.
	ExpirationTime *Timestamp `json:"expiration_time,omitempty" url:"expiration_time,omitempty"`
	// The expiration time of the certificate.
	ExpirationTimeDt *time.Time `json:"expiration_time_dt,omitempty" url:"expiration_time_dt,omitempty"`
	// The fingerprint list of the certificate.
	Fingerprints []*Fingerprint `json:"fingerprints,omitempty" url:"fingerprints,omitempty"`
	// Denotes whether a digital certificate is self-signed or signed by a known certificate authority (CA).
	IsSelfSigned *bool `json:"is_self_signed,omitempty" url:"is_self_signed,omitempty"`
	// The certificate issuer distinguished name.
	Issuer string `json:"issuer" url:"issuer"`
	// The list of subject alternative names that are secured by a specific certificate.
	Sans []*San `json:"sans,omitempty" url:"sans,omitempty"`
	// The serial number of the certificate used to create the digital signature.
	SerialNumber string `json:"serial_number" url:"serial_number"`
	// The certificate subject distinguished name.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The unique identifier of the certificate.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The certificate version.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Certificate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Certificate) UnmarshalJSON(data []byte) error {
	type embed Certificate
	var unmarshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Certificate(unmarshaler.embed)
	c.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	c.ExpirationTimeDt = unmarshaler.ExpirationTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Certificate) MarshalJSON() ([]byte, error) {
	type embed Certificate
	var marshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
	}{
		embed:            embed(*c),
		CreatedTimeDt:    core.NewOptionalDateTime(c.CreatedTimeDt),
		ExpirationTimeDt: core.NewOptionalDateTime(c.ExpirationTimeDt),
	}
	return json.Marshal(marshaler)
}

func (c *Certificate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The CIS Control (aka Critical Security Control) object describes a prioritized set of actions to protect your organization and data from cyber-attack vectors. The <a target='_blank' href='https://www.cisecurity.org/controls'>CIS Controls</a> are defined by the Center for Internet Security.
type CisControl struct {
	// The CIS Control description. For example: <i>Uninstall or disable unnecessary services on enterprise assets and software, such as an unused file sharing service, web application module, or service function.</i>
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The CIS Control name. For example: <i>4.8 Uninstall or Disable Unnecessary Services on Enterprise Assets and Software.</i>
	Name string `json:"name" url:"name"`
	// The CIS Control version. For example: <i>v8</i>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CisControl) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CisControl) UnmarshalJSON(data []byte) error {
	type unmarshaler CisControl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CisControl(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *CisControl) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Cloud object contains information about a cloud or Software-as-a-Service account or similar construct, such as AWS Account ID, regions, organizations, folders, compartments, tenants, etc.
type Cloud struct {
	// The account object describes details about the account that was the source or target of the activity.
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// The canonical cloud partition name to which the region is assigned (e.g. AWS Partitions: aws, aws-cn, aws-us-gov).
	CloudPartition *string `json:"cloud_partition,omitempty" url:"cloud_partition,omitempty"`
	// Organization and org unit relevant to the event or object.
	Org *Organization `json:"org,omitempty" url:"org,omitempty"`
	// The unique identifier of a Cloud project.
	ProjectUid *string `json:"project_uid,omitempty" url:"project_uid,omitempty"`
	// The unique name of the Cloud services provider, such as AWS, MS Azure, GCP, etc.
	Provider string `json:"provider" url:"provider"`
	// The name of the cloud region, as defined by the cloud provider.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// The availability zone in the cloud region, as defined by the cloud provider.
	Zone *string `json:"zone,omitempty" url:"zone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Cloud) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Cloud) UnmarshalJSON(data []byte) error {
	type unmarshaler Cloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Cloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Cloud) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Container object describes an instance of a specific container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
type Container struct {
	// Commit hash of image created for docker or the SHA256 hash of the container. For example: <code>13550340a8681c84c861aac2e5b440161c2b33a3e4f302ac680ca5b686de48de</code>.
	Hash *Fingerprint `json:"hash,omitempty" url:"hash,omitempty"`
	// The container image used as a template to run the container.
	Image *Image `json:"image,omitempty" url:"image,omitempty"`
	// The list of labels associated to the container.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The container name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The network driver used by the container. For example, bridge, overlay, host, none, etc.
	NetworkDriver *string `json:"network_driver,omitempty" url:"network_driver,omitempty"`
	// The orchestrator managing the container, such as ECS, EKS, K8s, or OpenShift.
	Orchestrator *string `json:"orchestrator,omitempty" url:"orchestrator,omitempty"`
	// The unique identifier of the pod (or equivalent) that the container is executing on.
	PodUuid *string `json:"pod_uuid,omitempty" url:"pod_uuid,omitempty"`
	// The backend running the container, such as containerd or cri-o.
	Runtime *string `json:"runtime,omitempty" url:"runtime,omitempty"`
	// The size of the container image.
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// The tag used by the container. It can indicate version, format, OS.
	Tag *string `json:"tag,omitempty" url:"tag,omitempty"`
	// The list of tags; <code>{key:value}</code> pairs associated to the container.
	Tags []*KeyValueObject `json:"tags,omitempty" url:"tags,omitempty"`
	// The full container unique identifier for this instantiation of the container. For example: <code>ac2ea168264a08f9aaca0dfc82ff3551418dfd22d02b713142a6843caa2f61bf</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Container) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Container) UnmarshalJSON(data []byte) error {
	type unmarshaler Container
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Container(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Container) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Common Vulnerabilities and Exposures (CVE) object represents publicly disclosed cybersecurity vulnerabilities defined in CVE Program catalog (<a target='_blank' href='https://cve.mitre.org/'>CVE</a>). There is one CVE Record for each vulnerability in the catalog.
type Cve struct {
	// The Record Creation Date identifies when the CVE ID was issued to a CVE Numbering Authority (CNA) or the CVE Record was published on the CVE List. Note that the Record Creation Date does not necessarily indicate when this vulnerability was discovered, shared with the affected vendor, publicly disclosed, or updated in CVE.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The Record Creation Date identifies when the CVE ID was issued to a CVE Numbering Authority (CNA) or the CVE Record was published on the CVE List. Note that the Record Creation Date does not necessarily indicate when this vulnerability was discovered, shared with the affected vendor, publicly disclosed, or updated in CVE.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The CVSS object details Common Vulnerability Scoring System (<a target='_blank' href='https://www.first.org/cvss/'>CVSS</a>) scores from the advisory that are related to the vulnerability.
	Cvss []*Cvss `json:"cvss,omitempty" url:"cvss,omitempty"`
	// The CWE object represents a weakness in a software system that can be exploited by a threat actor to perform an attack. The CWE object is based on the <a target='_blank' href='https://cwe.mitre.org/'>Common Weakness Enumeration (CWE)</a> catalog.
	Cwe *Cwe `json:"cwe,omitempty" url:"cwe,omitempty"`
	// The <a target='_blank' href='https://cwe.mitre.org/'>Common Weakness Enumeration (CWE)</a> unique identifier. For example: <code>CWE-787</code>.
	CweUid *string `json:"cwe_uid,omitempty" url:"cwe_uid,omitempty"`
	// Common Weakness Enumeration (CWE) definition URL. For example: <code>https://cwe.mitre.org/data/definitions/787.html</code>.
	CweUrl *UrlString `json:"cwe_url,omitempty" url:"cwe_url,omitempty"`
	// A brief description of the CVE Record.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The Exploit Prediction Scoring System (EPSS) object describes the estimated probability a vulnerability will be exploited. EPSS is a community-driven effort to combine descriptive information about vulnerabilities (CVEs) with evidence of actual exploitation in-the-wild. (<a target='_blank' href='https://www.first.org/epss/'>EPSS</a>).
	Epss *Epss `json:"epss,omitempty" url:"epss,omitempty"`
	// The Record Modified Date identifies when the CVE record was last updated.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The Record Modified Date identifies when the CVE record was last updated.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The product where the vulnerability was discovered.
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// A list of reference URLs with additional information about the CVE Record.
	References []string `json:"references,omitempty" url:"references,omitempty"`
	// Describes the Common Weakness Enumeration <a target='_blank' href='https://cwe.mitre.org/'>(CWE)</a> details related to the CVE Record.
	RelatedCwes []*Cwe `json:"related_cwes,omitempty" url:"related_cwes,omitempty"`
	// A title or a brief phrase summarizing the CVE record.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// <p>The vulnerability type as selected from a large dropdown menu during CVE refinement.</p>Most frequently used vulnerability types are: <code>DoS</code>, <code>Code Execution</code>, <code>Overflow</code>, <code>Memory Corruption</code>, <code>Sql Injection</code>, <code>XSS</code>, <code>Directory Traversal</code>, <code>Http Response Splitting</code>, <code>Bypass something</code>, <code>Gain Information</code>, <code>Gain Privileges</code>, <code>CSRF</code>, <code>File Inclusion</code>. For more information see <a target='_blank' href='https://www.cvedetails.com/vulnerabilities-by-types.php'>Vulnerabilities By Type</a> distributions.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The Common Vulnerabilities and Exposures unique number assigned to a specific computer vulnerability. A CVE Identifier begins with 4 digits representing the year followed by a sequence of digits that acts as a unique identifier. For example: <code>CVE-2021-12345</code>.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Cve) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Cve) UnmarshalJSON(data []byte) error {
	type embed Cve
	var unmarshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Cve(unmarshaler.embed)
	c.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	c.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Cve) MarshalJSON() ([]byte, error) {
	type embed Cve
	var marshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:          embed(*c),
		CreatedTimeDt:  core.NewOptionalDateTime(c.CreatedTimeDt),
		ModifiedTimeDt: core.NewOptionalDateTime(c.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (c *Cve) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Common Vulnerability Scoring System (<a target='_blank' href='https://www.first.org/cvss/'>CVSS</a>) object provides a way to capture the principal characteristics of a vulnerability and produce a numerical score reflecting its severity.
type Cvss struct {
	// The CVSS base score. For example: <code>9.1</code>.
	BaseScore float64 `json:"base_score" url:"base_score"`
	// The CVSS depth represents a depth of the equation used to calculate CVSS score.
	Depth *CvssDepth `json:"depth,omitempty" url:"depth,omitempty"`
	// The Common Vulnerability Scoring System metrics. This attribute contains information on the CVE's impact. If the CVE has been analyzed, this attribute will contain any CVSSv2 or CVSSv3 information associated with the vulnerability. For example: <code>{ {"Access Vector", "Network"}, {"Access Complexity", "Low"}, ...}</code>.
	Metrics []*Metric `json:"metrics,omitempty" url:"metrics,omitempty"`
	// The CVSS overall score, impacted by base, temporal, and environmental metrics. For example: <code>9.1</code>.
	OverallScore *float64 `json:"overall_score,omitempty" url:"overall_score,omitempty"`
	// <p>The Common Vulnerability Scoring System (CVSS) Qualitative Severity Rating. A textual representation of the numeric score.</p><strong>CVSS v2.0</strong><ul><li>Low (0.0 – 3.9)</li><li>Medium (4.0 – 6.9)</li><li>High (7.0 – 10.0)</li></ul></p><strong>CVSS v3.0</strong><ul><li>None (0.0)</li><li>Low (0.1 - 3.9)</li><li>Medium (4.0 - 6.9)</li><li>High (7.0 - 8.9)</li><li>Critical (9.0 - 10.0)</li></ul>
	Severity *string `json:"severity,omitempty" url:"severity,omitempty"`
	// The source URL for the CVSS score. For example: <code>https://nvd.nist.gov/vuln/detail/CVE-2021-44228</code>
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The CVSS vector string is a text representation of a set of CVSS metrics. It is commonly used to record or transfer CVSS metric information in a concise form. For example: <code>3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H</code>.
	VectorString *string `json:"vector_string,omitempty" url:"vector_string,omitempty"`
	// The vendor that provided the CVSS score. For example: <code>NVD, REDHAT</code> etc.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`
	// The CVSS version. For example: <code>3.1</code>.
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Cvss) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Cvss) UnmarshalJSON(data []byte) error {
	type unmarshaler Cvss
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Cvss(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Cvss) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// CvssDepth is an enum, and the following values are allowed.
// Base - Base
// Environmental - Environmental
// Temporal - Temporal
type CvssDepth = string

// The CWE object represents a weakness in a software system that can be exploited by a threat actor to perform an attack. The CWE object is based on the <a target='_blank' href='https://cwe.mitre.org/'>Common Weakness Enumeration (CWE)</a> catalog.
type Cwe struct {
	// The caption assigned to the Common Weakness Enumeration unique identifier.
	Caption *string `json:"caption,omitempty" url:"caption,omitempty"`
	// URL pointing to the CWE Specification. For more information see <a target='_blank' href='https://cwe.mitre.org/'>CWE.</a>
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The Common Weakness Enumeration unique number assigned to a specific weakness. A CWE Identifier begins "CWE" followed by a sequence of digits that acts as a unique identifier. For example: <code>CWE-123</code>.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Cwe) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Cwe) UnmarshalJSON(data []byte) error {
	type unmarshaler Cwe
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Cwe(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Cwe) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The MITRE D3FEND™ Tactic object describes the tactic ID and/or name that is associated to an attack.
type D3FTactic struct {
	// The tactic name that is associated with the defensive technique. For example: <code>Isolate</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The versioned permalink of the defensive tactic. For example: <code>https://d3fend.mitre.org/tactic/d3f:Isolate/</code>.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The unique identifier of the defensive tactic.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *D3FTactic) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *D3FTactic) UnmarshalJSON(data []byte) error {
	type unmarshaler D3FTactic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = D3FTactic(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *D3FTactic) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The MITRE D3FEND™ Technique object describes the leaf defensive technique ID and/or name associated to a countermeasure.
type D3FTechnique struct {
	// The name of the defensive technique. For example: <code>IO Port Restriction</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The versioned permalink of the defensive technique. For example: <code>https://d3fend.mitre.org/technique/d3f:IOPortRestriction/</code>.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The unique identifier of the defensive technique. For example: <code>D3-IOPR</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *D3FTechnique) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *D3FTechnique) UnmarshalJSON(data []byte) error {
	type unmarshaler D3FTechnique
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = D3FTechnique(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *D3FTechnique) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The MITRE D3FEND™ object describes the tactic & technique associated with a countermeasure.
type D3Fend struct {
	// The Tactic object describes the tactic ID and/or name that is associated with a countermeasure.
	D3FTactic *D3FTactic `json:"d3f_tactic,omitempty" url:"d3f_tactic,omitempty"`
	// The Technique object describes the technique ID and/or name associated with a countermeasure.
	D3FTechnique *D3FTechnique `json:"d3f_technique,omitempty" url:"d3f_technique,omitempty"`
	// The D3FEND™ Matrix version.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *D3Fend) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *D3Fend) UnmarshalJSON(data []byte) error {
	type unmarshaler D3Fend
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = D3Fend(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *D3Fend) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The Device object represents an addressable computer system or host, which is typically connected to a computer network and participates in the transmission or processing of data within the computer network.
type Device struct {
	// A list of <code>agent</code> objects associated with a device, endpoint, or resource.
	AgentList []*Agent `json:"agent_list,omitempty" url:"agent_list,omitempty"`
	// The unique identifier of the cloud autoscale configuration.
	AutoscaleUid *string `json:"autoscale_uid,omitempty" url:"autoscale_uid,omitempty"`
	// The time the system was booted.
	BootTime *Timestamp `json:"boot_time,omitempty" url:"boot_time,omitempty"`
	// The time the system was booted.
	BootTimeDt *time.Time `json:"boot_time_dt,omitempty" url:"boot_time_dt,omitempty"`
	// A unique identifier of the device that changes after every reboot. For example, the value of <code>/proc/sys/kernel/random/boot_id</code> from Linux's procfs.
	BootUid *string `json:"boot_uid,omitempty" url:"boot_uid,omitempty"`
	// The information describing an instance of a container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
	Container *Container `json:"container,omitempty" url:"container,omitempty"`
	// The time when the device was known to have been created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the device was known to have been created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The description of the device, ordinarily as reported by the operating system.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The network domain where the device resides. For example: <code>work.example.com</code>.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// An Embedded Identity Document, is a unique serial number that identifies an eSIM-enabled device.
	Eid *string `json:"eid,omitempty" url:"eid,omitempty"`
	// The initial discovery time of the device.
	FirstSeenTime *Timestamp `json:"first_seen_time,omitempty" url:"first_seen_time,omitempty"`
	// The initial discovery time of the device.
	FirstSeenTimeDt *time.Time `json:"first_seen_time_dt,omitempty" url:"first_seen_time_dt,omitempty"`
	// The group names to which the device belongs. For example: <code>["Windows Laptops", "Engineering"]</code>.
	Groups []*Group `json:"groups,omitempty" url:"groups,omitempty"`
	// The device hostname.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The endpoint hardware information.
	HwInfo *DeviceHwInfo `json:"hw_info,omitempty" url:"hw_info,omitempty"`
	// The name of the hypervisor running on the device. For example, <code>Xen</code>, <code>VMware</code>, <code>Hyper-V</code>, <code>VirtualBox</code>, etc.
	Hypervisor *string `json:"hypervisor,omitempty" url:"hypervisor,omitempty"`
	// The Integrated Circuit Card Identification of a mobile device. Typically it is a unique 18 to 22 digit number that identifies a SIM card.
	Iccid *string `json:"iccid,omitempty" url:"iccid,omitempty"`
	// The image used as a template to run the virtual machine.
	Image *Image `json:"image,omitempty" url:"image,omitempty"`
	// The International Mobile Equipment Identity that is associated with the device.
	Imei *string `json:"imei,omitempty" url:"imei,omitempty"`
	// The International Mobile Equipment Identity values that are associated with the device.
	ImeiList []string `json:"imei_list,omitempty" url:"imei_list,omitempty"`
	// The unique identifier of a VM instance.
	InstanceUid *string `json:"instance_uid,omitempty" url:"instance_uid,omitempty"`
	// The name of the network interface (e.g. eth2).
	InterfaceName *string `json:"interface_name,omitempty" url:"interface_name,omitempty"`
	// The unique identifier of the network interface.
	InterfaceUid *string `json:"interface_uid,omitempty" url:"interface_uid,omitempty"`
	// The device IP address, in either IPv4 or IPv6 format.
	Ip *IpAddress `json:"ip,omitempty" url:"ip,omitempty"`
	// A list of IP addresses available on the device
	IpAddresses []string `json:"ip_addresses,omitempty" url:"ip_addresses,omitempty"`
	// Indicates whether the device or resource has a backup enabled, such as an automated snapshot or a cloud backup. For example, this is indicated by the <code>cloudBackupEnabled</code> value within JAMF Pro mobile devices or the registration of an AWS ARN with the AWS Backup service.
	IsBackedUp *bool `json:"is_backed_up,omitempty" url:"is_backed_up,omitempty"`
	// The event occurred on a compliant device.
	IsCompliant *bool `json:"is_compliant,omitempty" url:"is_compliant,omitempty"`
	// The event occurred on a managed device.
	IsManaged *bool `json:"is_managed,omitempty" url:"is_managed,omitempty"`
	// Indicates whether the device has an active mobile account. For example, this is indicated by the <code>itunesStoreAccountActive</code> value within JAMF Pro mobile devices.
	IsMobileAccountActive *bool `json:"is_mobile_account_active,omitempty" url:"is_mobile_account_active,omitempty"`
	// The event occurred on a personal device.
	IsPersonal *bool `json:"is_personal,omitempty" url:"is_personal,omitempty"`
	// The event occurred on a shared device.
	IsShared *bool `json:"is_shared,omitempty" url:"is_shared,omitempty"`
	// The event occurred on a supervised device. Devices that are supervised are typically mobile devices managed by a Mobile Device Management solution and are restricted from specific behaviors such as Apple AirDrop.
	IsSupervised *bool `json:"is_supervised,omitempty" url:"is_supervised,omitempty"`
	// The event occurred on a trusted device.
	IsTrusted *bool `json:"is_trusted,omitempty" url:"is_trusted,omitempty"`
	// The most recent discovery time of the device.
	LastSeenTime *Timestamp `json:"last_seen_time,omitempty" url:"last_seen_time,omitempty"`
	// The most recent discovery time of the device.
	LastSeenTimeDt *time.Time `json:"last_seen_time_dt,omitempty" url:"last_seen_time_dt,omitempty"`
	// The geographical location of the device.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The Media Access Control (MAC) address of the endpoint.
	Mac *MacAddress `json:"mac,omitempty" url:"mac,omitempty"`
	// A list of MAC addresses available on the device
	MacAddresses []string `json:"mac_addresses,omitempty" url:"mac_addresses,omitempty"`
	// The Mobile Equipment Identifier. It's a unique number that identifies a Code Division Multiple Access (CDMA) mobile device.
	Meid *string `json:"meid,omitempty" url:"meid,omitempty"`
	// The model of the device. For example <code>ThinkPad X1 Carbon</code>.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The time when the device was last known to have been modified.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The time when the device was last known to have been modified.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The alternate device name, ordinarily as assigned by an administrator. <p><b>Note:</b> The <b>Name</b> could be any other string that helps to identify the device, such as a phone number; for example <code>310-555-1234</code>.</p>
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// If running under a process namespace (such as in a container), the process identifier within that process namespace.
	NamespacePid *int `json:"namespace_pid,omitempty" url:"namespace_pid,omitempty"`
	// A list of NetBIOS names available on the device
	NetbiosNames []string `json:"netbios_names,omitempty" url:"netbios_names,omitempty"`
	// The physical or virtual network interfaces that are associated with the device, one for each unique MAC address/IP address/hostname/name combination.<p><b>Note:</b> The first element of the array is the network information that pertains to the event.</p>
	NetworkInterfaces []*NetworkInterface `json:"network_interfaces,omitempty" url:"network_interfaces,omitempty"`
	// The network isolation status of the endpoint
	NetworkStatus *string `json:"network_status,omitempty" url:"network_status,omitempty"`
	// The network isolation status ID.
	NetworkStatusId *DeviceNetworkStatusId `json:"network_status_id,omitempty" url:"network_status_id,omitempty"`
	// Organization and org unit related to the device.
	Org *Organization `json:"org,omitempty" url:"org,omitempty"`
	// The endpoint operating system.
	Os *Os `json:"os,omitempty" url:"os,omitempty"`
	// The operating system assigned Machine ID. In Windows, this is the value stored at the registry path: <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\MachineGuid</code>. In Linux, this is stored in the file: <code>/etc/machine-id</code>.
	OsMachineUuid *string `json:"os_machine_uuid,omitempty" url:"os_machine_uuid,omitempty"`
	// The identity of the service or user account that owns the endpoint or was last logged into it.
	Owner *User `json:"owner,omitempty" url:"owner,omitempty"`
	// The region where the virtual machine is located. For example, an AWS Region.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// The risk level, normalized to the caption of the risk_level_id value.
	RiskLevel *string `json:"risk_level,omitempty" url:"risk_level,omitempty"`
	// The normalized risk level id.
	RiskLevelId *DeviceRiskLevelId `json:"risk_level_id,omitempty" url:"risk_level_id,omitempty"`
	// The risk score as reported by the event source.
	RiskScore *int `json:"risk_score,omitempty" url:"risk_score,omitempty"`
	// The subnet mask.
	Subnet *Subnet `json:"subnet,omitempty" url:"subnet,omitempty"`
	// The unique identifier of a virtual subnet.
	SubnetUid *string `json:"subnet_uid,omitempty" url:"subnet_uid,omitempty"`
	// The list of software contained on a device
	SwInfo []*Product `json:"sw_info,omitempty" url:"sw_info,omitempty"`
	// The device type. For example: <code>unknown</code>, <code>server</code>, <code>desktop</code>, <code>laptop</code>, <code>tablet</code>, <code>mobile</code>, <code>virtual</code>, <code>browser</code>, <code>plc</code>, <code>scada</code>, <code>dcs</code>, <code>cnc</code>, <code>scientific</code>, <code>medical</code>, <code>lighting</code>, <code>energy</code>, <code>transportation</code> <code>other</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The device type ID.
	TypeId DeviceTypeId `json:"type_id" url:"type_id"`
	// The Apple assigned Unique Device Identifier (UDID). For iOS, iPadOS, tvOS, watchOS and visionOS devices, this is the UDID. For macOS devices, it is the Provisioning UDID. For example: <code>00008020-008D4548007B4F26</code>
	Udid *string `json:"udid,omitempty" url:"udid,omitempty"`
	// The unique identifier of the device. For example the Windows TargetSID or AWS EC2 ARN.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An alternate unique identifier of the device if any. For example the ActiveDirectory DN.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The product vendor that created the device.
	Vendor *Organization `json:"vendor,omitempty" url:"vendor,omitempty"`
	// The vendor for the device. For example <code>Dell</code> or <code>Lenovo</code>.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`
	// The Virtual LAN identifier.
	VlanUid *string `json:"vlan_uid,omitempty" url:"vlan_uid,omitempty"`
	// The unique identifier of the Virtual Private Cloud (VPC).
	VpcUid *string `json:"vpc_uid,omitempty" url:"vpc_uid,omitempty"`
	// The network zone or LAN segment.
	Zone *string `json:"zone,omitempty" url:"zone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Device) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Device) UnmarshalJSON(data []byte) error {
	type embed Device
	var unmarshaler = struct {
		embed
		BootTimeDt      *core.DateTime `json:"boot_time_dt,omitempty"`
		CreatedTimeDt   *core.DateTime `json:"created_time_dt,omitempty"`
		FirstSeenTimeDt *core.DateTime `json:"first_seen_time_dt,omitempty"`
		LastSeenTimeDt  *core.DateTime `json:"last_seen_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Device(unmarshaler.embed)
	d.BootTimeDt = unmarshaler.BootTimeDt.TimePtr()
	d.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	d.FirstSeenTimeDt = unmarshaler.FirstSeenTimeDt.TimePtr()
	d.LastSeenTimeDt = unmarshaler.LastSeenTimeDt.TimePtr()
	d.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *Device) MarshalJSON() ([]byte, error) {
	type embed Device
	var marshaler = struct {
		embed
		BootTimeDt      *core.DateTime `json:"boot_time_dt,omitempty"`
		CreatedTimeDt   *core.DateTime `json:"created_time_dt,omitempty"`
		FirstSeenTimeDt *core.DateTime `json:"first_seen_time_dt,omitempty"`
		LastSeenTimeDt  *core.DateTime `json:"last_seen_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:           embed(*d),
		BootTimeDt:      core.NewOptionalDateTime(d.BootTimeDt),
		CreatedTimeDt:   core.NewOptionalDateTime(d.CreatedTimeDt),
		FirstSeenTimeDt: core.NewOptionalDateTime(d.FirstSeenTimeDt),
		LastSeenTimeDt:  core.NewOptionalDateTime(d.LastSeenTimeDt),
		ModifiedTimeDt:  core.NewOptionalDateTime(d.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (d *Device) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The Device Hardware Information object contains details and specifications of the physical components that make up a device. This information provides an overview of the hardware capabilities, configuration, and characteristics of the device.
type DeviceHwInfo struct {
	// The BIOS date. For example: <code>03/31/16</code>.
	BiosDate *string `json:"bios_date,omitempty" url:"bios_date,omitempty"`
	// The BIOS manufacturer. For example: <code>LENOVO</code>.
	BiosManufacturer *string `json:"bios_manufacturer,omitempty" url:"bios_manufacturer,omitempty"`
	// The BIOS UUID.
	BiosUid *string `json:"bios_uid,omitempty" url:"bios_uid,omitempty"`
	// The BIOS version. For example: <code>LENOVO G5ETA2WW (2.62)</code>.
	BiosVer *string `json:"bios_ver,omitempty" url:"bios_ver,omitempty"`
	// The chassis type describes the system enclosure or physical form factor. Such as the following examples for Windows <a target='_blank' href='https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-systemenclosure'>Windows Chassis Types</a>
	Chassis *string `json:"chassis,omitempty" url:"chassis,omitempty"`
	// The CPU architecture, normalized to the caption of the <code>cpu_architecture_id</code> value. In the case of <code>Other</code>, it is defined by the source.
	CpuArchitecture *string `json:"cpu_architecture,omitempty" url:"cpu_architecture,omitempty"`
	// The normalized identifier of the CPU architecture.
	CpuArchitectureId *DeviceHwInfoCpuArchitectureId `json:"cpu_architecture_id,omitempty" url:"cpu_architecture_id,omitempty"`
	// The cpu architecture, the number of bits used for addressing in memory. For example: <code>32</code> or <code>64</code>.
	CpuBits *int `json:"cpu_bits,omitempty" url:"cpu_bits,omitempty"`
	// The number of processor cores in all installed processors. For Example: <code>42</code>.
	CpuCores *int `json:"cpu_cores,omitempty" url:"cpu_cores,omitempty"`
	// The number of physical processors on a system. For example: <code>1</code>.
	CpuCount *int `json:"cpu_count,omitempty" url:"cpu_count,omitempty"`
	// The speed of the processor in Mhz. For Example: <code>4200</code>.
	CpuSpeed *int `json:"cpu_speed,omitempty" url:"cpu_speed,omitempty"`
	// The processor type. For example: <code>x86 Family 6 Model 37 Stepping 5</code>.
	CpuType *string `json:"cpu_type,omitempty" url:"cpu_type,omitempty"`
	// The desktop display affiliated with the event
	DesktopDisplay *Display `json:"desktop_display,omitempty" url:"desktop_display,omitempty"`
	// The keyboard detailed information.
	KeyboardInfo *KeyboardInfo `json:"keyboard_info,omitempty" url:"keyboard_info,omitempty"`
	// The total amount of installed RAM, in Megabytes. For example: <code>2048</code>.
	RamSize *int `json:"ram_size,omitempty" url:"ram_size,omitempty"`
	// The device manufacturer serial number.
	SerialNumber *string `json:"serial_number,omitempty" url:"serial_number,omitempty"`
	// The device manufacturer assigned universally unique hardware identifier. For SMBIOS compatible devices such as those running Linux and Windows, it is the UUID member of the System Information structure in the SMBIOS information. For macOS devices, it is the Hardware UUID (also known as IOPlatformUUID in the I/O Registry).
	Uuid *string `json:"uuid,omitempty" url:"uuid,omitempty"`
	// The device manufacturer.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceHwInfo) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceHwInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceHwInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceHwInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *DeviceHwInfo) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DeviceHwInfoCpuArchitectureId is an enum, and the following values are allowed.
// 0 - Unknown: The CPU architecture is unknown.
// 1 - x86: CPU uses the x86 ISA. For bitness, refer to <code>cpu_bits</code>.
// 2 - ARM: CPU uses the ARM ISA. For bitness, refer to <code>cpu_bits</code>.
// 3 - V: CPU uses the RISC-V ISA. For bitness, refer to <code>cpu_bits</code>.
// 99 - Other: The CPU architecture is not mapped. See the <code>cpu_architecture</code> attribute, which contains a data source specific value.
type DeviceHwInfoCpuArchitectureId = int

// DeviceNetworkStatusId is an enum, and the following values are allowed.
// 1 - NotIsolated: Device is not isolated from the network.
// 2 - Isolated: Device is isolated from the network.
// 3 - PendingIsolation: Device is pending isolation from the network.
// 4 - PendingRestore: Device is pending restoration from isolation.
// 99 - Unknown: The network isolation status is unknown.
type DeviceNetworkStatusId = int

// DeviceRiskLevelId is an enum, and the following values are allowed.
// 0 - Info
// 1 - Low
// 2 - Medium
// 3 - High
// 4 - Critical
// 99 - Other: The risk level is not mapped. See the <code>risk_level</code> attribute, which contains a data source specific value.
type DeviceRiskLevelId = int

// DeviceTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Server: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Server/'>server</a>.
// 2 - Desktop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:DesktopComputer/'>desktop computer</a>.
// 3 - Laptop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:LaptopComputer/'>laptop computer</a>.
// 4 - Tablet: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:TabletComputer/'>tablet computer</a>.
// 5 - Mobile: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:MobilePhone/'>mobile phone</a>.
// 6 - Virtual: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:VirtualizationSoftware/'>virtual machine</a>.
// 7 - IOT: An <a target='_blank' href='https://www.techtarget.com/iotagenda/definition/IoT-device'>IOT (Internet of Things) device</a>.
// 8 - Browser: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Browser/'>web browser</a>.
// 9 - Firewall: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Firewall/'>networking firewall</a>.
// 10 - Switch: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Switch/'>networking switch</a>.
// 11 - Hub: A <a target='_blank' href='https://en.wikipedia.org/wiki/Ethernet_hub'>networking hub</a>.
// 12 - Router: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Router/'>networking router</a>.
// 13 - IDS: An <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:IntrusionDetectionSystem/'>intrusion detection system</a>.
// 14 - IPS: An <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:IntrusionPreventionSystem/'>intrusion prevention system</a>.
// 15 - LoadBalancer: A <a target='_blank' href='https://en.wikipedia.org/wiki/Load_balancing_(computing)'>Load Balancer device.</a>
// 89 - ImagingEquipment: Equipment for processing optical data, such as a camera.
// 90 - PLC: A Programmable logic controller.
// 91 - SCADA: A supervisory control and data acquisition system.
// 92 - DCS: A distributed control system.
// 93 - CNC: A computer numerical control system, including computerized machine tools.
// 94 - ScientificEquipment: A piece of scientific equipment such as an oscilloscope or spectrometer.
// 95 - MedicalDevice: A medical device such as an MRI machine or infusion pump.
// 96 - LightingControls: A lighting control for internal or external applications.
// 97 - EnergyMonitoringSystem: An energy monitoring, security or safety system.
// 98 - TransportationDevice: A transportation device or transportation supporting device.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type DeviceTypeId = int

// The Digital Signature object contains information about the cryptographic mechanism used to verify the authenticity, integrity, and origin of the file or application.
type DigitalSignature struct {
	// The digital signature algorithm used to create the signature, normalized to the caption of 'algorithm_id'. In the case of 'Other', it is defined by the event source.
	Algorithm *string `json:"algorithm,omitempty" url:"algorithm,omitempty"`
	// The identifier of the normalized digital signature algorithm.
	AlgorithmId DigitalSignatureAlgorithmId `json:"algorithm_id" url:"algorithm_id"`
	// The certificate object containing information about the digital certificate.
	Certificate *Certificate `json:"certificate,omitempty" url:"certificate,omitempty"`
	// The time when the digital signature was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the digital signature was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The developer ID on the certificate that signed the file.
	DeveloperUid *string `json:"developer_uid,omitempty" url:"developer_uid,omitempty"`
	// The message digest attribute contains the fixed length message hash representation and the corresponding hashing algorithm information.
	Digest *Fingerprint `json:"digest,omitempty" url:"digest,omitempty"`
	// The digital signature state defines the signature state, normalized to the caption of 'state_id'. In the case of 'Other', it is defined by the event source.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// The normalized identifier of the signature state.
	StateId *DigitalSignatureStateId `json:"state_id,omitempty" url:"state_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DigitalSignature) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DigitalSignature) UnmarshalJSON(data []byte) error {
	type embed DigitalSignature
	var unmarshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DigitalSignature(unmarshaler.embed)
	d.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *DigitalSignature) MarshalJSON() ([]byte, error) {
	type embed DigitalSignature
	var marshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed:         embed(*d),
		CreatedTimeDt: core.NewOptionalDateTime(d.CreatedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (d *DigitalSignature) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DigitalSignatureAlgorithmId is an enum, and the following values are allowed.
// 0 - Unknown: The algorithm is unknown.
// 1 - DSA: Digital Signature Algorithm (DSA).
// 2 - RSA: Rivest-Shamir-Adleman (RSA) Algorithm.
// 3 - ECDSA: Elliptic Curve Digital Signature Algorithm.
// 4 - Authenticode: Microsoft Authenticode Digital Signature Algorithm.
// 99 - Other: The algorithm is not mapped. See the <code>algorithm</code> attribute, which contains a data source specific value.
type DigitalSignatureAlgorithmId = int

// DigitalSignatureStateId is an enum, and the following values are allowed.
// 0 - Unknown: The state is unknown.
// 1 - Valid: The digital signature is valid.
// 2 - Expired: The digital signature is not valid due to expiration of certificate.
// 3 - Revoked: The digital signature is invalid due to certificate revocation.
// 4 - Suspended: The digital signature is invalid due to certificate suspension.
// 5 - Pending: The digital signature state is pending.
// 99 - Other: The state is not mapped. See the <code>state</code> attribute, which contains a data source specific value.
type DigitalSignatureStateId = int

// The Display object contains information about the physical or virtual display connected to a computer system.
type Display struct {
	// The numeric color depth.
	ColorDepth *int `json:"color_depth,omitempty" url:"color_depth,omitempty"`
	// The numeric physical height of display.
	PhysicalHeight *int `json:"physical_height,omitempty" url:"physical_height,omitempty"`
	// The numeric physical orientation of display.
	PhysicalOrientation *int `json:"physical_orientation,omitempty" url:"physical_orientation,omitempty"`
	// The numeric physical width of display.
	PhysicalWidth *int `json:"physical_width,omitempty" url:"physical_width,omitempty"`
	// The numeric scale factor of display.
	ScaleFactor *int `json:"scale_factor,omitempty" url:"scale_factor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Display) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Display) UnmarshalJSON(data []byte) error {
	type unmarshaler Display
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Display(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *Display) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The DNS Answer object represents a specific response provided by the Domain Name System (DNS) when querying for information about a domain or performing a DNS operation. It encapsulates the relevant details and data returned by the DNS server in response to a query.
type DnsAnswer struct {
	// The class of DNS data contained in this resource record. See <a target='_blank' href='https://www.rfc-editor.org/rfc/rfc1035.txt'>RFC1035</a>. For example: <code>IN</code>.
	Class *string `json:"class,omitempty" url:"class,omitempty"`
	// The list of DNS answer header flag IDs.
	FlagIds []DnsAnswerFlagIds `json:"flag_ids,omitempty" url:"flag_ids,omitempty"`
	// The list of DNS answer header flags.
	Flags []string `json:"flags,omitempty" url:"flags,omitempty"`
	// The DNS packet identifier assigned by the program that generated the query. The identifier is copied to the response.
	PacketUid *int `json:"packet_uid,omitempty" url:"packet_uid,omitempty"`
	// The data describing the DNS resource. The meaning of this data depends on the type and class of the resource record.
	Rdata string `json:"rdata" url:"rdata"`
	// The time interval that the resource record may be cached. Zero value means that the resource record can only be used for the transaction in progress, and should not be cached.
	Ttl *int `json:"ttl,omitempty" url:"ttl,omitempty"`
	// The type of data contained in this resource record. See <a target='_blank' href='https://www.rfc-editor.org/rfc/rfc1035.txt'>RFC1035</a>. For example: <code>CNAME</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DnsAnswer) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DnsAnswer) UnmarshalJSON(data []byte) error {
	type unmarshaler DnsAnswer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DnsAnswer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *DnsAnswer) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DnsAnswerFlagIds is an enum, and the following values are allowed.
// 0 - Unknown: The flag is unknown.
// 1 - AuthoritativeAnswer
// 2 - TruncatedResponse
// 3 - RecursionDesired
// 4 - RecursionAvailable
// 5 - AuthenticData
// 6 - CheckingDisabled
// 99 - Other: The flag is not mapped. See the <code>flags</code> attribute, which contains a data source specific value.
type DnsAnswerFlagIds = int

// The contact information related to a domain registration, e.g., registrant, administrator, abuse, billing, or technical contact.
type DomainContact struct {
	// The user's primary email address.
	EmailAddr *EmailAddress `json:"email_addr,omitempty" url:"email_addr,omitempty"`
	// Location details for the contract such as the city, state/province, country, etc.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The individual or organization name for the contact.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The number associated with the phone.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The Domain Contact type, normalized to the caption of the <code>type_id</code> value. In the case of 'Other', it is defined by the source
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The normalized domain contact type ID.
	TypeId DomainContactTypeId `json:"type_id" url:"type_id"`
	// The unique identifier of the contact information, typically provided in WHOIS information.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DomainContact) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DomainContact) UnmarshalJSON(data []byte) error {
	type unmarshaler DomainContact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DomainContact(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *DomainContact) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DomainContactTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Registrant: The contact information provided is for the domain registrant.
// 2 - Administrative: The contact information provided is for the domain administrator.
// 3 - Technical: The contact information provided is for the domain technical lead.
// 4 - Billing: The contact information provided is for the domain billing lead.
// 5 - Abuse: The contact information provided is for the domain abuse contact.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type DomainContactTypeId = int

// The Email object describes the email metadata such as sender, recipients, and direction, and can include embedded URLs and files.
type Email struct {
	// The BCC recipients of the email. Similar to cc field but for BCC recipients.
	Bcc []string `json:"bcc,omitempty" url:"bcc,omitempty"`
	// The machine-readable email header Cc values, as defined by RFC 5322. For example <code>example.user@usersdomain.com</code>.
	Cc []EmailAddress `json:"cc,omitempty" url:"cc,omitempty"`
	// The human-readable email header Cc Mailbox values. For example <code>'Example User &lt;example.user@usersdomain.com&gt;'</code>.
	CcMailboxes []string `json:"cc_mailboxes,omitempty" url:"cc_mailboxes,omitempty"`
	// The machine-readable <strong>Delivered-To</strong> email header field. For example <code>example.user@usersdomain.com</code>
	DeliveredTo *EmailAddress `json:"delivered_to,omitempty" url:"delivered_to,omitempty"`
	// The machine-readable <strong>Delivered-To</strong> email header values. For example <code>example.user@usersdomain.com</code>
	DeliveredToList []EmailAddress `json:"delivered_to_list,omitempty" url:"delivered_to_list,omitempty"`
	// The files embedded or attached to the email.
	Files []*File `json:"files,omitempty" url:"files,omitempty"`
	// The machine-readable email header From value, as defined by RFC 5322. For example <code>example.user@usersdomain.com</code>.
	From *EmailAddress `json:"from,omitempty" url:"from,omitempty"`
	// The machine-readable email header From values. This array should contain the value in <code>from</code>. For example <code>example.user@usersdomain.com</code>.
	FromList []EmailAddress `json:"from_list,omitempty" url:"from_list,omitempty"`
	// The human-readable email header From Mailbox value. For example <code>'Example User &lt;example.user@usersdomain.com&gt;'</code>.
	FromMailbox *string `json:"from_mailbox,omitempty" url:"from_mailbox,omitempty"`
	// The human-readable email header From Mailbox values. This array should contain the value in <code>from_mailbox</code>. For example <code>'Example User &lt;example.user@usersdomain.com&gt;'</code>.
	FromMailboxes []EmailAddress `json:"from_mailboxes,omitempty" url:"from_mailboxes,omitempty"`
	// Additional HTTP headers of an HTTP request or response.
	HttpHeaders []*HttpHeader `json:"http_headers,omitempty" url:"http_headers,omitempty"`
	// True if the email is viewable externally (presumably by external users).
	IsExternallyViewable *bool `json:"is_externally_viewable,omitempty" url:"is_externally_viewable,omitempty"`
	// The indication of whether the email has been read.
	IsRead *bool `json:"is_read,omitempty" url:"is_read,omitempty"`
	// Labels associated with the object, such as security or sensitivity labels created by a scanning app.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The email header Message-ID value, as defined by RFC 5322.
	MessageUid *string `json:"message_uid,omitempty" url:"message_uid,omitempty"`
	// The email authentication header.
	RawHeader *string `json:"raw_header,omitempty" url:"raw_header,omitempty"`
	// The machine-readable email header Reply-To value, as defined by RFC 5322. For example <code>example.user@usersdomain.com</code>
	ReplyTo *EmailAddress `json:"reply_to,omitempty" url:"reply_to,omitempty"`
	// The machine-readable email header Reply-To values, as defined by RFC 5322. For example <code>example.user@usersdomain.com</code>
	ReplyToList []EmailAddress `json:"reply_to_list,omitempty" url:"reply_to_list,omitempty"`
	// The human-readable email header Reply To Mailbox values. For example <code>'Example User &lt;example.user@usersdomain.com&gt;'</code>.
	ReplyToMailboxes []string `json:"reply_to_mailboxes,omitempty" url:"reply_to_mailboxes,omitempty"`
	// The address found in the 'Return-Path' header, which indicates where bounce messages (non-delivery reports) should be sent. This address is often set by the sending system and may differ from the 'From' or 'Sender' addresses. For example, <code>mailer-daemon@senderserver.com</code>.
	ReturnPath *EmailAddress `json:"return_path,omitempty" url:"return_path,omitempty"`
	// The machine readable email address of the system or server that actually transmitted the email message, extracted from the email headers per RFC 5322. This differs from the <code>from</code> field, which shows the message author. The sender field is most commonly used when multiple addresses appear in the <code> from_list </code> field, or when the transmitting system is different from the message author (such as when sending on behalf of someone else).
	Sender *EmailAddress `json:"sender,omitempty" url:"sender,omitempty"`
	// The human readable email address of the system or server that actually transmitted the email message, extracted from the email headers per RFC 5322. This differs from the <code>from_mailbox</code> field, which shows the message author. The sender mailbox field is most commonly used when multiple addresses appear in the <code> from_mailboxes </code> field, or when the transmitting system is different from the message author (such as when sending on behalf of someone else).
	SenderMailbox *string `json:"sender_mailbox,omitempty" url:"sender_mailbox,omitempty"`
	// Unique ID of the sender mailbox. This is distinct from the sender's email address.
	SenderMailboxUid *string `json:"sender_mailbox_uid,omitempty" url:"sender_mailbox_uid,omitempty"`
	// The size in bytes of the email, including attachments.
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// The value of the SMTP MAIL FROM command.
	SmtpFrom *EmailAddress `json:"smtp_from,omitempty" url:"smtp_from,omitempty"`
	// The value of the SMTP envelope RCPT TO command.
	SmtpTo []EmailAddress `json:"smtp_to,omitempty" url:"smtp_to,omitempty"`
	// The email header Subject value, as defined by RFC 5322.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The time at which the email was sent.
	TimeSent *Timestamp `json:"time_sent,omitempty" url:"time_sent,omitempty"`
	// The time at which the email was sent.
	TimeSentDt *time.Time `json:"time_sent_dt,omitempty" url:"time_sent_dt,omitempty"`
	// The machine-readable email header To values, as defined by RFC 5322. For example <code>example.user@usersdomain.com</code>
	To []EmailAddress `json:"to,omitempty" url:"to,omitempty"`
	// The human-readable email header To Mailbox values. For example <code>'Example User &lt;example.user@usersdomain.com&gt;'</code>.
	ToMailboxes []string `json:"to_mailboxes,omitempty" url:"to_mailboxes,omitempty"`
	// The unique identifier of the email thread.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The URLs embedded in the email.
	Urls []string `json:"urls,omitempty" url:"urls,omitempty"`
	// The X-Originating-IP header identifying the emails originating IP address(es).
	XOriginatingIp []IpAddress `json:"x_originating_ip,omitempty" url:"x_originating_ip,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Email) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Email) UnmarshalJSON(data []byte) error {
	type embed Email
	var unmarshaler = struct {
		embed
		TimeSentDt *core.DateTime `json:"time_sent_dt,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Email(unmarshaler.embed)
	e.TimeSentDt = unmarshaler.TimeSentDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *Email) MarshalJSON() ([]byte, error) {
	type embed Email
	var marshaler = struct {
		embed
		TimeSentDt *core.DateTime `json:"time_sent_dt,omitempty"`
	}{
		embed:      embed(*e),
		TimeSentDt: core.NewOptionalDateTime(e.TimeSentDt),
	}
	return json.Marshal(marshaler)
}

func (e *Email) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The Email Authentication object describes the Sender Policy Framework (SPF), DomainKeys Identified Mail (DKIM) and Domain-based Message Authentication, Reporting and Conformance (DMARC) attributes of an email.
type EmailAuth struct {
	// The DomainKeys Identified Mail (DKIM) status of the email.
	Dkim *string `json:"dkim,omitempty" url:"dkim,omitempty"`
	// The DomainKeys Identified Mail (DKIM) signing domain of the email.
	DkimDomain *string `json:"dkim_domain,omitempty" url:"dkim_domain,omitempty"`
	// The DomainKeys Identified Mail (DKIM) signature used by the sending/receiving system.
	DkimSignature *string `json:"dkim_signature,omitempty" url:"dkim_signature,omitempty"`
	// The Domain-based Message Authentication, Reporting and Conformance (DMARC) status of the email.
	Dmarc *string `json:"dmarc,omitempty" url:"dmarc,omitempty"`
	// The Domain-based Message Authentication, Reporting and Conformance (DMARC) override action.
	DmarcOverride *string `json:"dmarc_override,omitempty" url:"dmarc_override,omitempty"`
	// The Domain-based Message Authentication, Reporting and Conformance (DMARC) policy status.
	DmarcPolicy *string `json:"dmarc_policy,omitempty" url:"dmarc_policy,omitempty"`
	// The Sender Policy Framework (SPF) status of the email.
	Spf *string `json:"spf,omitempty" url:"spf,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmailAuth) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmailAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler EmailAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmailAuth(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EmailAuth) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Details about the encryption methodology utilized.
type EncryptionDetails struct {
	// The encryption algorithm used, normalized to the caption of 'algorithm_id
	Algorithm *string `json:"algorithm,omitempty" url:"algorithm,omitempty"`
	// The encryption algorithm used.
	AlgorithmId *EncryptionDetailsAlgorithmId `json:"algorithm_id,omitempty" url:"algorithm_id,omitempty"`
	// The length of the encryption key used.
	KeyLength *int `json:"key_length,omitempty" url:"key_length,omitempty"`
	// The unique identifier of the key used for encryption. For example, AWS KMS Key ARN.
	KeyUid *string `json:"key_uid,omitempty" url:"key_uid,omitempty"`
	// The type of the encryption used.
	Type *string `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EncryptionDetails) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EncryptionDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler EncryptionDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EncryptionDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EncryptionDetails) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// EncryptionDetailsAlgorithmId is an enum, and the following values are allowed.
// 0 - Unknown: The algorithm is unknown.
// 1 - DES: Data Encryption Standard Algorithm
// 2 - TripleDES: Triple Data Encryption Standard Algorithm
// 3 - AES: Advanced Encryption Standard Algorithm.
// 4 - RSA: Rivest-Shamir-Adleman Algorithm
// 5 - ECC: Elliptic Curve Cryptography Algorithm
// 6 - SM2: ShangMi Cryptographic Algorithm
// 99 - Other: The algorithm is not mapped. See the <code>algorithm</code> attribute, which contains a data source specific value.
type EncryptionDetailsAlgorithmId = int

// The Enrichment object provides inline enrichment data for specific attributes of interest within an event. It serves as a mechanism to enhance or supplement the information associated with the event by adding additional relevant details or context.
type Enrichment struct {
	// The time when the enrichment data was generated.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the enrichment data was generated.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The enrichment data associated with the attribute and value. The meaning of this data depends on the type the enrichment record.
	Data interface{} `json:"data" url:"data"`
	// A long description of the enrichment data.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The name of the attribute to which the enriched data pertains.
	Name string `json:"name" url:"name"`
	// The enrichment data provider name.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// The reputation of the enrichment data.
	Reputation *Reputation `json:"reputation,omitempty" url:"reputation,omitempty"`
	// A short description of the enrichment data.
	ShortDesc *string `json:"short_desc,omitempty" url:"short_desc,omitempty"`
	// The URL of the source of the enrichment data.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The enrichment type. For example: <code>location</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The value of the attribute to which the enriched data pertains.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Enrichment) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Enrichment) UnmarshalJSON(data []byte) error {
	type embed Enrichment
	var unmarshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Enrichment(unmarshaler.embed)
	e.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *Enrichment) MarshalJSON() ([]byte, error) {
	type embed Enrichment
	var marshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed:         embed(*e),
		CreatedTimeDt: core.NewOptionalDateTime(e.CreatedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (e *Enrichment) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// An environment variable.
type EnvironmentVariable struct {
	// The name of the environment variable.
	Name string `json:"name" url:"name"`
	// The value of the environment variable.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnvironmentVariable) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnvironmentVariable) UnmarshalJSON(data []byte) error {
	type unmarshaler EnvironmentVariable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnvironmentVariable(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *EnvironmentVariable) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The Exploit Prediction Scoring System (EPSS) object describes the estimated probability a vulnerability will be exploited. EPSS is a community-driven effort to combine descriptive information about vulnerabilities (CVEs) with evidence of actual exploitation in-the-wild. (<a target='_blank' href='https://www.first.org/epss/'>EPSS</a>).
type Epss struct {
	// The timestamp indicating when the EPSS score was calculated.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The timestamp indicating when the EPSS score was calculated.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The EPSS score's percentile representing relative importance and ranking of the score in the larger EPSS dataset.
	Percentile *float64 `json:"percentile,omitempty" url:"percentile,omitempty"`
	// The EPSS score representing the probability [0-1] of exploitation in the wild in the next 30 days (following score publication).
	Score string `json:"score" url:"score"`
	// The version of the EPSS model used to calculate the score.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Epss) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Epss) UnmarshalJSON(data []byte) error {
	type embed Epss
	var unmarshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Epss(unmarshaler.embed)
	e.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *Epss) MarshalJSON() ([]byte, error) {
	type embed Epss
	var marshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed:         embed(*e),
		CreatedTimeDt: core.NewOptionalDateTime(e.CreatedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (e *Epss) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The OCSF Schema Extension object provides detailed information about the schema extension used to construct the event. The schema extensions are registered in the <a target='_blank' href='https://github.com/ocsf/ocsf-schema/blob/main/extensions.md'>extensions.md</a> file.
type Extension struct {
	// The schema extension name. For example: <code>dev</code>.
	Name string `json:"name" url:"name"`
	// The schema extension unique identifier. For example: <code>999</code>.
	Uid string `json:"uid" url:"uid"`
	// The schema extension version. For example: <code>1.0.0-alpha.2</code>.
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Extension) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Extension) UnmarshalJSON(data []byte) error {
	type unmarshaler Extension
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Extension(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *Extension) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The Feature object provides information about the software product feature that generated a specific event. It encompasses details related to the capabilities, components, user interface (UI) design, and performance upgrades associated with the feature.
type Feature struct {
	// The name of the feature.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique identifier of the feature.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The version of the feature.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *Feature) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Feature) UnmarshalJSON(data []byte) error {
	type unmarshaler Feature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Feature(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = nil
	return nil
}

func (f *Feature) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The File object represents the metadata associated with a file stored in a computer system. It encompasses information about the file itself, including its attributes, properties, and organizational details.
type File struct {
	// The time when the file was last accessed.
	AccessedTime *Timestamp `json:"accessed_time,omitempty" url:"accessed_time,omitempty"`
	// The time when the file was last accessed.
	AccessedTimeDt *time.Time `json:"accessed_time_dt,omitempty" url:"accessed_time_dt,omitempty"`
	// The name of the user who last accessed the object.
	Accessor *User `json:"accessor,omitempty" url:"accessor,omitempty"`
	// The app which mediated access to the file. This could be separate from the source app, for example a case where a user exports a report from a web app. The source app would be their browser and the accessor app the web app.
	AccessorApp *Product `json:"accessor_app,omitempty" url:"accessor_app,omitempty"`
	// The bitmask value that represents the file attributes.
	Attributes *int `json:"attributes,omitempty" url:"attributes,omitempty"`
	// The name of the company that published the file. For example: <code>Microsoft Corporation</code>.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// The file content confidentiality, normalized to the confidentiality_id value. In the case of 'Other', it is defined by the event source.
	Confidentiality *string `json:"confidentiality,omitempty" url:"confidentiality,omitempty"`
	// The normalized identifier of the file content confidentiality indicator.
	ConfidentialityId *FileConfidentialityId `json:"confidentiality_id,omitempty" url:"confidentiality_id,omitempty"`
	// The time when the file was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the file was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The user that created the file.
	Creator *User `json:"creator,omitempty" url:"creator,omitempty"`
	// The description of the file, as returned by file system. For example: the description as returned by the Unix file command or the Windows file type.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The drive type, normalized to the caption of the <code>drive_type_id</code> value. In the case of <code>Other</code>, it is defined by the source.
	DriveType *string `json:"drive_type,omitempty" url:"drive_type,omitempty"`
	// Identifies the type of a disk drive, i.e. fixed, removable, etc.
	DriveTypeId *FileDriveTypeId `json:"drive_type_id,omitempty" url:"drive_type_id,omitempty"`
	// The encryption details of the file. Should be populated if the file is encrypted.
	EncryptionDetails *EncryptionDetails `json:"encryption_details,omitempty" url:"encryption_details,omitempty"`
	// The extension of the file, excluding the leading dot. For example: <code>exe</code> from <code>svchost.exe</code>, or <code>gz</code> from <code>export.tar.gz</code>.
	Ext *string `json:"ext,omitempty" url:"ext,omitempty"`
	// An array of hash attributes.
	Hashes []*Fingerprint `json:"hashes,omitempty" url:"hashes,omitempty"`
	// The name of the file as identified within the file itself. This contrasts with the name by which the file is known on disk. Where available, the internal name is widely used by security practitioners and detection content because the on-disk file name is not reliable. On the Windows OS, most PE files contain a <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/versioninfo-resource">VERSIONINFO</a> resource from which the internal name can be obtained. On macOS, binaries can optionally embed a copy of the application's Info.plist file which in turn contains the name of the executable.
	InternalName *string `json:"internal_name,omitempty" url:"internal_name,omitempty"`
	// Indicates if the file was deleted from the filesystem.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// Indicates if the file is encrypted.
	IsEncrypted *bool `json:"is_encrypted,omitempty" url:"is_encrypted,omitempty"`
	// Indicates if the file is publicly accessible. For example in an object's public access in AWS S3
	IsPublic *bool `json:"is_public,omitempty" url:"is_public,omitempty"`
	// Indicates that the file cannot be modified.
	IsReadonly *bool `json:"is_readonly,omitempty" url:"is_readonly,omitempty"`
	// The indication of whether the object is part of the operating system.
	IsSystem *bool `json:"is_system,omitempty" url:"is_system,omitempty"`
	// Labels associated with the object, such as security or sensitivity labels created by a scanning app.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The Multipurpose Internet Mail Extensions (MIME) type of the file, if applicable.
	MimeType *string `json:"mime_type,omitempty" url:"mime_type,omitempty"`
	// The time when the file was last modified.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The time when the file was last modified.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The user that last modified the file.
	Modifier *User `json:"modifier,omitempty" url:"modifier,omitempty"`
	// The name of the file. For example: <code>svchost.exe</code>
	Name FileName `json:"name" url:"name"`
	// The user that owns the file/object.
	Owner *User `json:"owner,omitempty" url:"owner,omitempty"`
	// The parent folder in which the file resides. For example: <code>c:\windows\system32</code>
	ParentFolder *string `json:"parent_folder,omitempty" url:"parent_folder,omitempty"`
	// The full path to the file. For example: <code>c:\windows\system32\svchost.exe</code>.
	Path *FilePath `json:"path,omitempty" url:"path,omitempty"`
	// The product that created or installed the file.
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// The object security descriptor.
	SecurityDescriptor *string `json:"security_descriptor,omitempty" url:"security_descriptor,omitempty"`
	// The digital signature of the file.
	Signature *DigitalSignature `json:"signature,omitempty" url:"signature,omitempty"`
	// The size of data, in bytes.
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// The storage class of the file. For example in AWS S3: <code>STANDARD, STANDARD_IA, GLACIER</code>.
	StorageClass *string `json:"storage_class,omitempty" url:"storage_class,omitempty"`
	// The list of tags; <code>{key:value}</code> pairs associated to the file.
	Tags []*KeyValueObject `json:"tags,omitempty" url:"tags,omitempty"`
	// The file type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The file type ID. Note the distinction between a <code>Regular File</code> and an <code>Executable File</code>. If the distinction is not known, or not indicated by the log, use <code>Regular File</code>. In this case, it should not be assumed that a Regular File is not executable.
	TypeId FileTypeId `json:"type_id" url:"type_id"`
	// The unique identifier of the file as defined by the storage system, such the file system file ID.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The file URI, such as those reporting by static analysis tools. E.g., <code>file:///C:/dev/sarif/sarif-tutorials/samples/Introduction/simple-example.js</code>
	Uri *UrlString `json:"uri,omitempty" url:"uri,omitempty"`
	// The URL of the file, when applicable.
	Url *Url `json:"url,omitempty" url:"url,omitempty"`
	// The file version. For example: <code>8.0.7601.17514</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// The volume on the storage device where the file is located.
	Volume *string `json:"volume,omitempty" url:"volume,omitempty"`
	// An unordered collection of zero or more name/value pairs where each pair represents a file or folder extended attribute.</p>For example: Windows alternate data stream attributes (ADS stream name, ADS size, etc.), user-defined or application-defined attributes, ACL, owner, primary group, etc. Examples from DCS: </p><ul><li><strong>ads_name</strong></li><li><strong>ads_size</strong></li><li><strong>dacl</strong></li><li><strong>owner</strong></li><li><strong>primary_group</strong></li><li><strong>link_name</strong> - name of the link associated to the file.</li><li><strong>hard_link_count</strong> - the number of links that are associated to the file.</li></ul>
	Xattributes *Object `json:"xattributes,omitempty" url:"xattributes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		AccessedTimeDt *core.DateTime `json:"accessed_time_dt,omitempty"`
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.AccessedTimeDt = unmarshaler.AccessedTimeDt.TimePtr()
	f.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	f.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = nil
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		AccessedTimeDt *core.DateTime `json:"accessed_time_dt,omitempty"`
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:          embed(*f),
		AccessedTimeDt: core.NewOptionalDateTime(f.AccessedTimeDt),
		CreatedTimeDt:  core.NewOptionalDateTime(f.CreatedTimeDt),
		ModifiedTimeDt: core.NewOptionalDateTime(f.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (f *File) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// FileConfidentialityId is an enum, and the following values are allowed.
// 0 - Unknown: The confidentiality is unknown.
// 1 - NotConfidential
// 2 - Confidential
// 3 - Secret
// 4 - TopSecret
// 5 - Private
// 6 - Restricted
// 99 - Other: The confidentiality is not mapped. See the <code>confidentiality</code> attribute, which contains a data source specific value.
type FileConfidentialityId = int

// FileDriveTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The drive type is unknown.
// 1 - Removable: The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.
// 2 - Fixed: The drive has fixed media; for example, a hard disk drive or flash drive.
// 3 - Remote: The drive is a remote (network) drive.
// 4 - ROM: The drive is a CD-ROM drive.
// 5 - RAMDisk: The drive is a RAM disk.
// 99 - Other: The drive type is not mapped. See the <code>drive_type</code> attribute, which contains a data source specific value.
type FileDriveTypeId = int

// FileTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - RegularFile
// 2 - Folder
// 3 - CharacterDevice
// 4 - BlockDevice
// 5 - LocalSocket
// 6 - NamedPipe
// 7 - SymbolicLink
// 8 - ExecutableFile
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type FileTypeId = int

// The Fingerprint object provides detailed information about a digital fingerprint, which is a compact representation of data used to identify a longer piece of information, such as a public key or file content. It contains the algorithm and value of the fingerprint, enabling efficient and reliable identification of the associated data.
type Fingerprint struct {
	// The hash algorithm used to create the digital fingerprint, normalized to the caption of <code>algorithm_id</code>. In the case of <code>Other</code>, it is defined by the event source.
	Algorithm *string `json:"algorithm,omitempty" url:"algorithm,omitempty"`
	// The identifier of the normalized hash algorithm, which was used to create the digital fingerprint.
	AlgorithmId FingerprintAlgorithmId `json:"algorithm_id" url:"algorithm_id"`
	// The digital fingerprint value.
	Value Hash `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *Fingerprint) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fingerprint) UnmarshalJSON(data []byte) error {
	type unmarshaler Fingerprint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fingerprint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = nil
	return nil
}

func (f *Fingerprint) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// FingerprintAlgorithmId is an enum, and the following values are allowed.
// 0 - Unknown: The algorithm is unknown.
// 1 - MD5: MD5 message-digest algorithm producing a 128-bit (16-byte) hash value.
// 2 - 1: Secure Hash Algorithm 1 producing a 160-bit (20-byte) hash value.
// 3 - 256: Secure Hash Algorithm 2 producing a 256-bit (32-byte) hash value.
// 4 - 512: Secure Hash Algorithm 2 producing a 512-bit (64-byte) hash value.
// 5 - CTPH: The ssdeep generated fuzzy checksum. Also known as Context Triggered Piecewise Hash (CTPH).
// 6 - TLSH: The TLSH fuzzy hashing algorithm.
// 7 - quickXorHash: Microsoft simple non-cryptographic hash algorithm that works by XORing the bytes in a circular-shifting fashion.
// 8 - 224: Secure Hash Algorithm 2 producing a 224-bit (28-byte) hash value.
// 9 - 384: Secure Hash Algorithm 2 producing a 384-bit (48-byte) hash value.
// 10 - 512_224: Secure Hash Algorithm 2 producing a 512-bit (64-byte) hash value truncated to a 224-bit (28-byte) hash value.
// 11 - 512_256: Secure Hash Algorithm 2 producing a 512-bit (64-byte) hash value truncated to a 256-bit (32-byte) hash value.
// 12 - 224: Secure Hash Algorithm 3 producing a 224-bit (28-byte) hash value.
// 13 - 256: Secure Hash Algorithm 3 producing a 256-bit (32-byte) hash value.
// 14 - 384: Secure Hash Algorithm 3 producing a 384-bit (48-byte) hash value.
// 15 - 512: Secure Hash Algorithm 3 producing a 512-bit (64-byte) hash value.
// 16 - bit: xxHash H3 producing a 64-bit hash value.
// 17 - bit: xxHash H3 producing a 128-bit hash value.
// 99 - Other: The algorithm is not mapped. See the <code>algorithm</code> attribute, which contains a data source specific value.
type FingerprintAlgorithmId = int

// The Firewall Rule object represents a specific rule within a firewall policy or event. It contains information about a rule's configuration, properties, and associated actions that define how network traffic is handled by the firewall.
type FirewallRule struct {
	// The rule category.
	Category *string `json:"category,omitempty" url:"category,omitempty"`
	// The rule trigger condition for the rule. For example: SQL_INJECTION.
	Condition *string `json:"condition,omitempty" url:"condition,omitempty"`
	// The description of the rule that generated the event.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The rule response time duration, usually used for challenge completion time.
	Duration *int `json:"duration,omitempty" url:"duration,omitempty"`
	// The data in a request that rule matched. For example: '["10","and","1"]'.
	MatchDetails []string `json:"match_details,omitempty" url:"match_details,omitempty"`
	// The location of the matched data in the source which resulted in the triggered firewall rule. For example: HEADER.
	MatchLocation *string `json:"match_location,omitempty" url:"match_location,omitempty"`
	// The name of the rule that generated the event.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The rate limit for a rate-based rule.
	RateLimit *int `json:"rate_limit,omitempty" url:"rate_limit,omitempty"`
	// The sensitivity of the firewall rule in the matched event. For example: HIGH.
	Sensitivity *string `json:"sensitivity,omitempty" url:"sensitivity,omitempty"`
	// The rule type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique identifier of the rule that generated the event.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The rule version. For example: <code>1.1</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FirewallRule) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FirewallRule) UnmarshalJSON(data []byte) error {
	type unmarshaler FirewallRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirewallRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = nil
	return nil
}

func (f *FirewallRule) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The Group object represents a collection or association of entities, such as users, policies, or devices. It serves as a logical grouping mechanism to organize and manage entities with similar characteristics or permissions within a system or organization, including but not limited to purposes of access control.
type Group struct {
	// The group description.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The domain where the group is defined. For example: the LDAP or Active Directory domain.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The group name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The group privileges.
	Privileges []string `json:"privileges,omitempty" url:"privileges,omitempty"`
	// The type of the group or account.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique identifier of the group. For example, for Windows events this is the security identifier (SID) of the group.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Group) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Group) UnmarshalJSON(data []byte) error {
	type unmarshaler Group
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Group(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *Group) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The HTTP Header object represents the headers sent in an HTTP request or response. HTTP headers are key-value pairs that convey additional information about the HTTP message, including details about the content, caching, authentication, encoding, and other aspects of the communication.
type HttpHeader struct {
	// The name of the HTTP header.
	Name string `json:"name" url:"name"`
	// The value of the HTTP header.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpHeader) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpHeader(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = nil
	return nil
}

func (h *HttpHeader) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The HTTP Request object represents the attributes of a request made to a web server. It encapsulates the details and metadata associated with an HTTP request, including the request method, headers, URL, query parameters, body content, and other relevant information.
type HttpRequest struct {
	// The arguments sent along with the HTTP request.
	Args *string `json:"args,omitempty" url:"args,omitempty"`
	// The actual length of the HTTP request body, in number of bytes, independent of a potentially existing Content-Length header.
	BodyLength *int `json:"body_length,omitempty" url:"body_length,omitempty"`
	// Additional HTTP headers of an HTTP request or response.
	HttpHeaders []*HttpHeader `json:"http_headers,omitempty" url:"http_headers,omitempty"`
	// The <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods'>HTTP request method</a> indicates the desired action to be performed for a given resource.
	HttpMethod *HttpRequestHttpMethod `json:"http_method,omitempty" url:"http_method,omitempty"`
	// The length of the entire HTTP request, in number of bytes.
	Length *int `json:"length,omitempty" url:"length,omitempty"`
	// The request header that identifies the address of the previous web page, which is linked to the current web page or resource being requested.
	Referrer *string `json:"referrer,omitempty" url:"referrer,omitempty"`
	// The unique identifier of the http request.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The URL object that pertains to the request.
	Url *Url `json:"url,omitempty" url:"url,omitempty"`
	// The request header that identifies the operating system and web browser.
	UserAgent *string `json:"user_agent,omitempty" url:"user_agent,omitempty"`
	// Concise version of the user agent, e.g. Chrome or Firefox instead of the full user-agent string.
	UserAgentName *string `json:"user_agent_name,omitempty" url:"user_agent_name,omitempty"`
	// The Hypertext Transfer Protocol (HTTP) version.
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// The X-Forwarded-For header identifying the originating IP address(es) of a client connecting to a web server through an HTTP proxy or a load balancer.
	XForwardedFor []IpAddress `json:"x_forwarded_for,omitempty" url:"x_forwarded_for,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpRequest) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = nil
	return nil
}

func (h *HttpRequest) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// HttpRequestHttpMethod is an enum, and the following values are allowed.
// CONNECT - Connect: The CONNECT method establishes a tunnel to the server identified by the target resource.
// DELETE - Delete: The DELETE method deletes the specified resource.
// GET - Get: The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
// HEAD - Head: The HEAD method asks for a response identical to a GET request, but without the response body.
// OPTIONS - Options: The OPTIONS method describes the communication options for the target resource.
// PATCH - Patch: The PATCH method applies partial modifications to a resource.
// POST - Post: The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.
// PUT - Put: The PUT method replaces all current representations of the target resource with the request payload.
// TRACE - Trace: The TRACE method performs a message loop-back test along the path to the target resource.
type HttpRequestHttpMethod = string

// The HTTP Response object contains detailed information about the response sent from a web server to the requester. It encompasses attributes and metadata that describe the response status, headers, body content, and other relevant information.
type HttpResponse struct {
	// The actual length of the HTTP response body, in number of bytes, independent of a potentially existing Content-Length header.
	BodyLength *int `json:"body_length,omitempty" url:"body_length,omitempty"`
	// The Hypertext Transfer Protocol (HTTP) status code returned from the web server to the client. For example, 200.
	Code int `json:"code" url:"code"`
	// The request header that identifies the original <a target='_blank' href='https://www.iana.org/assignments/media-types/media-types.xhtml'>media type </a> of the resource (prior to any content encoding applied for sending).
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`
	// Additional HTTP headers of an HTTP request or response.
	HttpHeaders []*HttpHeader `json:"http_headers,omitempty" url:"http_headers,omitempty"`
	// The HTTP response latency measured in milliseconds.
	Latency *int `json:"latency,omitempty" url:"latency,omitempty"`
	// The length of the entire HTTP response, in number of bytes.
	Length *int `json:"length,omitempty" url:"length,omitempty"`
	// The description of the event/finding, as defined by the source.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// The response status. For example: A successful HTTP status of 'OK' which corresponds to a code of 200.
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpResponse) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = nil
	return nil
}

func (h *HttpResponse) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The Identity Provider object contains detailed information about a provider responsible for creating, maintaining, and managing identity information while offering authentication services to applications. An Identity Provider (IdP) serves as a trusted authority that verifies the identity of users and issues authentication tokens or assertions to enable secure access to applications or services.
type Idp struct {
	// The Authentication Factors object describes the different types of Multi-Factor Authentication (MFA) methods and/or devices supported by the Identity Provider.
	AuthFactors []*AuthFactor `json:"auth_factors,omitempty" url:"auth_factors,omitempty"`
	// The primary domain associated with the Identity Provider.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The fingerprint of the X.509 certificate used by the Identity Provider.
	Fingerprint *Fingerprint `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// The Identity Provider enforces Multi Factor Authentication (MFA).
	HasMfa *bool `json:"has_mfa,omitempty" url:"has_mfa,omitempty"`
	// The unique identifier (often a URL) used by the Identity Provider as its issuer.
	Issuer *string `json:"issuer,omitempty" url:"issuer,omitempty"`
	// The name of the Identity Provider.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The supported protocol of the Identity Provider. E.g., <code>SAML</code>, <code>OIDC</code>, or <code>OAuth2</code>.
	ProtocolName *string `json:"protocol_name,omitempty" url:"protocol_name,omitempty"`
	// The System for Cross-domain Identity Management (SCIM) resource object provides a structured set of attributes related to SCIM protocols used for identity provisioning and management across cloud-based platforms. It standardizes user and group provisioning details, enabling identity synchronization and lifecycle management with compatible Identity Providers (IdPs) and applications. SCIM is defined in <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc7643'>RFC-7634</a>
	Scim *Scim `json:"scim,omitempty" url:"scim,omitempty"`
	// The Single Sign-On (SSO) object provides a structure for normalizing SSO attributes, configuration, and/or settings from Identity Providers.
	Sso *Sso `json:"sso,omitempty" url:"sso,omitempty"`
	// The configuration state of the Identity Provider, normalized to the caption of the <code>state_id</code> value. In the case of <code>Other</code>, it is defined by the event source.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// The normalized state ID of the Identity Provider to reflect its configuration or activation status.
	StateId *IdpStateId `json:"state_id,omitempty" url:"state_id,omitempty"`
	// The tenant ID associated with the Identity Provider.
	TenantUid *string `json:"tenant_uid,omitempty" url:"tenant_uid,omitempty"`
	// The unique identifier of the Identity Provider.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The URL for accessing the configuration or metadata of the Identity Provider.
	UrlString *UrlString `json:"url_string,omitempty" url:"url_string,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Idp) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Idp) UnmarshalJSON(data []byte) error {
	type unmarshaler Idp
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Idp(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *Idp) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// IdpStateId is an enum, and the following values are allowed.
// 0 - Unknown: The configuration state of the Identity Provider is unknown.
// 1 - Active: The Identity Provider is in an Active state, or otherwise enabled.
// 2 - Suspended: The Identity Provider is in a Suspended state.
// 3 - Deprecated: The Identity Provider is in a Deprecated state, or is otherwise disabled.
// 4 - Deleted: The Identity Provider is in a Deleted state.
// 99 - Other: The configuration state of the Identity Provider is not mapped. See the <code>state</code> attribute, which contains a data source specific value.
type IdpStateId = int

// The Image object provides a description of a specific Virtual Machine (VM) or Container image.
type Image struct {
	// The list of labels associated to the image.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The image name. For example: <code>elixir</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The full path to the image file.
	Path *FilePath `json:"path,omitempty" url:"path,omitempty"`
	// The image tag. For example: <code>1.11-alpine</code>.
	Tag *string `json:"tag,omitempty" url:"tag,omitempty"`
	// The list of tags; <code>{key:value}</code> pairs associated to the image.
	Tags []*KeyValueObject `json:"tags,omitempty" url:"tags,omitempty"`
	// The unique image ID. For example: <code>77af4d6b9913</code>.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Image) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Image) UnmarshalJSON(data []byte) error {
	type unmarshaler Image
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Image(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *Image) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The KB Article object contains metadata that describes the patch or update.
type KbArticle struct {
	// The average time to patch.
	AvgTimespan *Timespan `json:"avg_timespan,omitempty" url:"avg_timespan,omitempty"`
	// The kb article bulletin identifier.
	Bulletin *string `json:"bulletin,omitempty" url:"bulletin,omitempty"`
	// The vendors classification of the kb article.
	Classification *string `json:"classification,omitempty" url:"classification,omitempty"`
	// The date the kb article was released by the vendor.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The date the kb article was released by the vendor.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The install state of the kb article.
	InstallState *string `json:"install_state,omitempty" url:"install_state,omitempty"`
	// The normalized install state ID of the kb article.
	InstallStateId *KbArticleInstallStateId `json:"install_state_id,omitempty" url:"install_state_id,omitempty"`
	// The kb article has been replaced by another.
	IsSuperseded *bool `json:"is_superseded,omitempty" url:"is_superseded,omitempty"`
	// The operating system the kb article applies.
	Os *Os `json:"os,omitempty" url:"os,omitempty"`
	// The product details the kb article applies.
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// The severity of the kb article.
	Severity *string `json:"severity,omitempty" url:"severity,omitempty"`
	// The size in bytes for the kb article.
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// The kb article link from the source vendor.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The title of the kb article.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// The unique identifier for the kb article.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (k *KbArticle) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KbArticle) UnmarshalJSON(data []byte) error {
	type embed KbArticle
	var unmarshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KbArticle(unmarshaler.embed)
	k.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties

	k._rawJSON = nil
	return nil
}

func (k *KbArticle) MarshalJSON() ([]byte, error) {
	type embed KbArticle
	var marshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed:         embed(*k),
		CreatedTimeDt: core.NewOptionalDateTime(k.CreatedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (k *KbArticle) String() string {
	if len(k._rawJSON) > 0 {
		if value, err := core.StringifyJSON(k._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// KbArticleInstallStateId is an enum, and the following values are allowed.
// 0 - Unknown: The normalized install state is unknown.
// 1 - Installed: The item is installed.
// 2 - NotInstalled: The item is not installed.
// 3 - InstalledPendingReboot: The item is installed pending reboot operation.
// 99 - Other: The install state is not mapped. See the <code>install_state</code> attribute, which contains a data source specific value.
type KbArticleInstallStateId = int

// A generic object allowing to define a <code>{key:value}</code> pair.
type KeyValueObject struct {
	// The name of the key.
	Name string `json:"name" url:"name"`
	// The value associated to the key.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// Optional, the values associated to the key. You can populate this attribute, when you have multiple values for the same key.
	Values []string `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (k *KeyValueObject) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyValueObject) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyValueObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyValueObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties

	k._rawJSON = nil
	return nil
}

func (k *KeyValueObject) String() string {
	if len(k._rawJSON) > 0 {
		if value, err := core.StringifyJSON(k._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// The Keyboard Information object contains details and attributes related to a computer or device keyboard. It encompasses information that describes the characteristics, capabilities, and configuration of the keyboard.
type KeyboardInfo struct {
	// The number of function keys on client keyboard.
	FunctionKeys *int `json:"function_keys,omitempty" url:"function_keys,omitempty"`
	// The Input Method Editor (IME) file name.
	Ime *string `json:"ime,omitempty" url:"ime,omitempty"`
	// The keyboard locale identifier name (e.g., en-US).
	KeyboardLayout *string `json:"keyboard_layout,omitempty" url:"keyboard_layout,omitempty"`
	// The keyboard numeric code.
	KeyboardSubtype *int `json:"keyboard_subtype,omitempty" url:"keyboard_subtype,omitempty"`
	// The keyboard type (e.g., xt, ico).
	KeyboardType *string `json:"keyboard_type,omitempty" url:"keyboard_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (k *KeyboardInfo) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyboardInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyboardInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyboardInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties

	k._rawJSON = nil
	return nil
}

func (k *KeyboardInfo) String() string {
	if len(k._rawJSON) > 0 {
		if value, err := core.StringifyJSON(k._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// The Kill Chain Phase object represents a single phase of a cyber attack, including the initial reconnaissance and planning stages up to the final objective of the attacker. It provides a detailed description of each phase and its associated activities within the broader context of a cyber attack. See <a target='_blank' href='https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html'>Cyber Kill Chain®</a>.
type KillChainPhase struct {
	// The cyber kill chain phase.
	Phase *string `json:"phase,omitempty" url:"phase,omitempty"`
	// The cyber kill chain phase identifier.
	PhaseId KillChainPhasePhaseId `json:"phase_id" url:"phase_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (k *KillChainPhase) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KillChainPhase) UnmarshalJSON(data []byte) error {
	type unmarshaler KillChainPhase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KillChainPhase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties

	k._rawJSON = nil
	return nil
}

func (k *KillChainPhase) String() string {
	if len(k._rawJSON) > 0 {
		if value, err := core.StringifyJSON(k._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// KillChainPhasePhaseId is an enum, and the following values are allowed.
// 0 - Unknown: The kill chain phase is unknown.
// 1 - Reconnaissance: The attackers pick a target and perform a detailed analysis, start collecting information (email addresses, conferences information, etc.) and evaluate the victim’s vulnerabilities to determine how to exploit them.
// 2 - Weaponization: The attackers develop a malware weapon and aim to exploit the discovered vulnerabilities.
// 3 - Delivery: The intruders will use various tactics, such as phishing, infected USB drives, etc.
// 4 - Exploitation: The intruders start leveraging vulnerabilities to executed code on the victim’s system.
// 5 - Installation: The intruders install malware on the victim’s system.
// 6 - Control: Malware opens a command channel to enable the intruders to remotely manipulate the victim's system.
// 7 - ActionsonObjectives: With hands-on keyboard access, intruders accomplish the mission’s goal.
// 99 - Other: The kill chain phase is not mapped. See the <code>phase</code> attribute, which contains a data source specific value.
type KillChainPhasePhaseId = int

// The additional LDAP attributes that describe a person.
type LdapPerson struct {
	// The cost center associated with the user.
	CostCenter *string `json:"cost_center,omitempty" url:"cost_center,omitempty"`
	// The timestamp when the user was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The timestamp when the user was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The timestamp when the user was deleted. In Active Directory (AD), when a user is deleted they are moved to a temporary container and then removed after 30 days. So, this field can be populated even after a user is deleted for the next 30 days.
	DeletedTime *Timestamp `json:"deleted_time,omitempty" url:"deleted_time,omitempty"`
	// The timestamp when the user was deleted. In Active Directory (AD), when a user is deleted they are moved to a temporary container and then removed after 30 days. So, this field can be populated even after a user is deleted for the next 30 days.
	DeletedTimeDt *time.Time `json:"deleted_time_dt,omitempty" url:"deleted_time_dt,omitempty"`
	// The display name of the LDAP person. According to RFC 2798, this is the preferred name of a person to be used when displaying entries.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// Indicates whether the user is eligible for rehire. This typically applies to terminated or retired employees.
	EligibleForRehire *bool `json:"eligible_for_rehire,omitempty" url:"eligible_for_rehire,omitempty"`
	// A list of additional email addresses for the user.
	EmailAddrs []EmailAddress `json:"email_addrs,omitempty" url:"email_addrs,omitempty"`
	// The employee identifier assigned to the user by the organization.
	EmployeeUid *string `json:"employee_uid,omitempty" url:"employee_uid,omitempty"`
	// The employment status, normalized to the caption of the employment_status_id value. In the case of 'Other', it is defined by the data source.
	EmploymentStatus *string `json:"employment_status,omitempty" url:"employment_status,omitempty"`
	// The timestamp when the employment status was last changed.
	EmploymentStatusDate *Timestamp `json:"employment_status_date,omitempty" url:"employment_status_date,omitempty"`
	// The timestamp when the employment status was last changed.
	EmploymentStatusDateDt *time.Time `json:"employment_status_date_dt,omitempty" url:"employment_status_date_dt,omitempty"`
	// The normalized identifier of the user's employment status.
	EmploymentStatusId *LdapPersonEmploymentStatusId `json:"employment_status_id,omitempty" url:"employment_status_id,omitempty"`
	// The given or first name of the user.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The timestamp when the user was or will be hired by the organization.
	HireTime *Timestamp `json:"hire_time,omitempty" url:"hire_time,omitempty"`
	// The timestamp when the user was or will be hired by the organization.
	HireTimeDt *time.Time `json:"hire_time_dt,omitempty" url:"hire_time_dt,omitempty"`
	// The user's job title.
	JobTitle *string `json:"job_title,omitempty" url:"job_title,omitempty"`
	// The labels associated with the user. For example in AD this could be the <code>userType</code>, <code>employeeType</code>. For example: <code>Member, Employee</code>.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The last time when the user logged in.
	LastLoginTime *Timestamp `json:"last_login_time,omitempty" url:"last_login_time,omitempty"`
	// The last time when the user logged in.
	LastLoginTimeDt *time.Time `json:"last_login_time_dt,omitempty" url:"last_login_time_dt,omitempty"`
	// The LDAP and X.500 <code>commonName</code> attribute, typically the full name of the person. For example, <code>John Doe</code>.
	LdapCn *string `json:"ldap_cn,omitempty" url:"ldap_cn,omitempty"`
	// The X.500 Distinguished Name (DN) is a structured string that uniquely identifies an entry, such as a user, in an X.500 directory service For example, <code>cn=John Doe,ou=People,dc=example,dc=com</code>.
	LdapDn *string `json:"ldap_dn,omitempty" url:"ldap_dn,omitempty"`
	// The timestamp when the user left or will be leaving the organization.
	LeaveTime *Timestamp `json:"leave_time,omitempty" url:"leave_time,omitempty"`
	// The timestamp when the user left or will be leaving the organization.
	LeaveTimeDt *time.Time `json:"leave_time_dt,omitempty" url:"leave_time_dt,omitempty"`
	// The geographical location associated with a user. This is typically the user's usual work location.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The user's manager. This helps in understanding an org hierarchy. This should only ever be populated once in an event. I.e. there should not be a manager's manager in an event.
	Manager *Object `json:"manager,omitempty" url:"manager,omitempty"`
	// The timestamp when the user entry was last modified.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The timestamp when the user entry was last modified.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The primary office location associated with the user. This could be any string and isn't a specific address. For example, <code>South East Virtual</code>.
	OfficeLocation *string `json:"office_location,omitempty" url:"office_location,omitempty"`
	// The telephone number of the user. Corresponds to the LDAP <code>Telephone-Number</code> CN.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// Indicates whether a termination is considered regrettable by the organization (i.e., loss of a valued employee). This is typically only populated for terminated employees.
	RegrettableTermination *bool `json:"regrettable_termination,omitempty" url:"regrettable_termination,omitempty"`
	// The user's direct reports. This is the inverse of the manager relationship, representing users who report directly to this user in the organizational hierarchy. This field only includes immediate/direct reports, not transitive reports.
	Reports []Object `json:"reports,omitempty" url:"reports,omitempty"`
	// The last or family name for the user.
	Surname *string `json:"surname,omitempty" url:"surname,omitempty"`
	// The list of tags; <code>{key:value}</code> pairs associated to the user.
	Tags []*KeyValueObject `json:"tags,omitempty" url:"tags,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LdapPerson) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LdapPerson) UnmarshalJSON(data []byte) error {
	type embed LdapPerson
	var unmarshaler = struct {
		embed
		CreatedTimeDt          *core.DateTime `json:"created_time_dt,omitempty"`
		DeletedTimeDt          *core.DateTime `json:"deleted_time_dt,omitempty"`
		EmploymentStatusDateDt *core.DateTime `json:"employment_status_date_dt,omitempty"`
		HireTimeDt             *core.DateTime `json:"hire_time_dt,omitempty"`
		LastLoginTimeDt        *core.DateTime `json:"last_login_time_dt,omitempty"`
		LeaveTimeDt            *core.DateTime `json:"leave_time_dt,omitempty"`
		ModifiedTimeDt         *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LdapPerson(unmarshaler.embed)
	l.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	l.DeletedTimeDt = unmarshaler.DeletedTimeDt.TimePtr()
	l.EmploymentStatusDateDt = unmarshaler.EmploymentStatusDateDt.TimePtr()
	l.HireTimeDt = unmarshaler.HireTimeDt.TimePtr()
	l.LastLoginTimeDt = unmarshaler.LastLoginTimeDt.TimePtr()
	l.LeaveTimeDt = unmarshaler.LeaveTimeDt.TimePtr()
	l.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *LdapPerson) MarshalJSON() ([]byte, error) {
	type embed LdapPerson
	var marshaler = struct {
		embed
		CreatedTimeDt          *core.DateTime `json:"created_time_dt,omitempty"`
		DeletedTimeDt          *core.DateTime `json:"deleted_time_dt,omitempty"`
		EmploymentStatusDateDt *core.DateTime `json:"employment_status_date_dt,omitempty"`
		HireTimeDt             *core.DateTime `json:"hire_time_dt,omitempty"`
		LastLoginTimeDt        *core.DateTime `json:"last_login_time_dt,omitempty"`
		LeaveTimeDt            *core.DateTime `json:"leave_time_dt,omitempty"`
		ModifiedTimeDt         *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:                  embed(*l),
		CreatedTimeDt:          core.NewOptionalDateTime(l.CreatedTimeDt),
		DeletedTimeDt:          core.NewOptionalDateTime(l.DeletedTimeDt),
		EmploymentStatusDateDt: core.NewOptionalDateTime(l.EmploymentStatusDateDt),
		HireTimeDt:             core.NewOptionalDateTime(l.HireTimeDt),
		LastLoginTimeDt:        core.NewOptionalDateTime(l.LastLoginTimeDt),
		LeaveTimeDt:            core.NewOptionalDateTime(l.LeaveTimeDt),
		ModifiedTimeDt:         core.NewOptionalDateTime(l.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (l *LdapPerson) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// LdapPersonEmploymentStatusId is an enum, and the following values are allowed.
// 0 - Unknown: The employment status is unknown.
// 1 - Applicant: The user is a job applicant or candidate who has not yet been hired.
// 2 - Active: The user is currently employed and actively working.
// 3 - Terminated: The user's employment has been terminated.
// 4 - Retired: The user has retired from the organization.
// 99 - Other: The employment status is not mapped. See the <code>employment_status</code> attribute, which contains a data source specific value.
type LdapPersonEmploymentStatusId = int

// The Geo Location object describes a geographical location, usually associated with an IP address.
type Location struct {
	// Expressed as either height above takeoff location or height above ground level (AGL) for a UAS current location. This value is provided in meters and must have a minimum resolution of 1 m. Special Values: <code>Invalid</code>, <code>No Value</code>, or <code>Unknown: -1000 m</code>.
	AerialHeight *string `json:"aerial_height,omitempty" url:"aerial_height,omitempty"`
	// The name of the city.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// The name of the continent.
	Continent *string `json:"continent,omitempty" url:"continent,omitempty"`
	// A two-element array, containing a longitude/latitude pair. The format conforms with <a target='_blank' href='https://geojson.org'>GeoJSON</a>. For example: <code>[-73.983, 40.719]</code>.
	Coordinates []float64 `json:"coordinates,omitempty" url:"coordinates,omitempty"`
	// The ISO 3166-1 Alpha-2 country code.<p><b>Note:</b> The two letter country code should be capitalized. For example: <code>US</code> or <code>CA</code>.</p>
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// The description of the geographical location.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The aircraft distance above or below the ellipsoid as measured along a line that passes through the aircraft and is normal to the surface of the WGS-84 ellipsoid. This value is provided in meters and must have a minimum resolution of 1 m. Special Values: <code>Invalid</code>, <code>No Value</code>, or <code>Unknown: -1000 m</code>.
	GeodeticAltitude *string `json:"geodetic_altitude,omitempty" url:"geodetic_altitude,omitempty"`
	// Provides quality/containment on geodetic altitude. This is based on ADS-B Geodetic Vertical Accuracy (GVA). Measured in meters.
	GeodeticVerticalAccuracy *string `json:"geodetic_vertical_accuracy,omitempty" url:"geodetic_vertical_accuracy,omitempty"`
	// <p>Geohash of the geo-coordinates (latitude and longitude).</p><a target='_blank' href='https://en.wikipedia.org/wiki/Geohash'>Geohashing</a> is a geocoding system used to encode geographic coordinates in decimal degrees, to a single string.
	Geohash *string `json:"geohash,omitempty" url:"geohash,omitempty"`
	// Provides quality/containment on horizontal position. This is based on ADS-B NACp. Measured in meters.
	HorizontalAccuracy *string `json:"horizontal_accuracy,omitempty" url:"horizontal_accuracy,omitempty"`
	// The indication of whether the location is on premises.
	IsOnPremises *bool `json:"is_on_premises,omitempty" url:"is_on_premises,omitempty"`
	// The name of the Internet Service Provider (ISP).
	Isp *string `json:"isp,omitempty" url:"isp,omitempty"`
	// The geographical Latitude coordinate represented in Decimal Degrees (DD). For example: <code>42.361145</code>.
	Lat *float64 `json:"lat,omitempty" url:"lat,omitempty"`
	// The geographical Longitude coordinate represented in Decimal Degrees (DD). For example: <code>-71.057083</code>.
	Long *float64 `json:"long,omitempty" url:"long,omitempty"`
	// The postal code of the location.
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// The uncorrected barometric pressure altitude (based on reference standard 29.92 inHg, 1013.25 mb) provides a reference for algorithms that utilize 'altitude deltas' between aircraft. This value is provided in meters and must have a minimum resolution of 1 m.. Special Values: <code>Invalid</code>, <code>No Value</code>, or <code>Unknown: -1000 m</code>.
	PressureAltitude *string `json:"pressure_altitude,omitempty" url:"pressure_altitude,omitempty"`
	// The provider of the geographical location data.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// The alphanumeric code that identifies the principal subdivision (e.g. province or state) of the country. For example, 'CH-VD' for the Canton of Vaud, Switzerland
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// Timezone string. This provides timezone information that may be present even when latitude and longitude are absent.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Location) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Location) UnmarshalJSON(data []byte) error {
	type unmarshaler Location
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Location(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *Location) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The Logger object represents the device and product where events are stored with times for receipt and transmission. This may be at the source device where the event occurred, a remote scanning device, intermediate hops, or the ultimate destination.
type Logger struct {
	// The device where the events are logged.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// The unique identifier of the event assigned by the logger.
	EventUid *string `json:"event_uid,omitempty" url:"event_uid,omitempty"`
	// Indicates whether the OCSF event data has been truncated due to size limitations. When <code>true</code>, some event data may have been omitted to fit within system constraints.
	IsTruncated *bool `json:"is_truncated,omitempty" url:"is_truncated,omitempty"`
	// The audit level at which an event was generated.
	LogLevel *string `json:"log_level,omitempty" url:"log_level,omitempty"`
	// The event log name. For example, syslog file name or Windows logging subsystem: Security.
	LogName *string `json:"log_name,omitempty" url:"log_name,omitempty"`
	// The logging provider or logging service that logged the event. For example, Microsoft-Windows-Security-Auditing.
	LogProvider *string `json:"log_provider,omitempty" url:"log_provider,omitempty"`
	// The event log schema version that specifies the format of the original event. For example syslog version or Cisco Log Schema Version.
	LogVersion *string `json:"log_version,omitempty" url:"log_version,omitempty"`
	// <p>The time when the logging system collected and logged the event.</p>This attribute is distinct from the event time in that event time typically contain the time extracted from the original event. Most of the time, these two times will be different.
	LoggedTime *Timestamp `json:"logged_time,omitempty" url:"logged_time,omitempty"`
	// <p>The time when the logging system collected and logged the event.</p>This attribute is distinct from the event time in that event time typically contain the time extracted from the original event. Most of the time, these two times will be different.
	LoggedTimeDt *time.Time `json:"logged_time_dt,omitempty" url:"logged_time_dt,omitempty"`
	// The name of the logging product instance.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The product logging the event. This may be the event source product, a management server product, a scanning product, a SIEM, etc.
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// The time when the event was transmitted from the logging device to it's next destination.
	TransmitTime *Timestamp `json:"transmit_time,omitempty" url:"transmit_time,omitempty"`
	// The time when the event was transmitted from the logging device to it's next destination.
	TransmitTimeDt *time.Time `json:"transmit_time_dt,omitempty" url:"transmit_time_dt,omitempty"`
	// The unique identifier of the logging product instance.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The original size of the OCSF event data in kilobytes before any truncation occurred. This field is typically populated when <code>is_truncated</code> is <code>true</code> to indicate the full size of the original event.
	UntruncatedSize *int `json:"untruncated_size,omitempty" url:"untruncated_size,omitempty"`
	// The version of the logging product.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Logger) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Logger) UnmarshalJSON(data []byte) error {
	type embed Logger
	var unmarshaler = struct {
		embed
		LoggedTimeDt   *core.DateTime `json:"logged_time_dt,omitempty"`
		TransmitTimeDt *core.DateTime `json:"transmit_time_dt,omitempty"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = Logger(unmarshaler.embed)
	l.LoggedTimeDt = unmarshaler.LoggedTimeDt.TimePtr()
	l.TransmitTimeDt = unmarshaler.TransmitTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *Logger) MarshalJSON() ([]byte, error) {
	type embed Logger
	var marshaler = struct {
		embed
		LoggedTimeDt   *core.DateTime `json:"logged_time_dt,omitempty"`
		TransmitTimeDt *core.DateTime `json:"transmit_time_dt,omitempty"`
	}{
		embed:          embed(*l),
		LoggedTimeDt:   core.NewOptionalDateTime(l.LoggedTimeDt),
		TransmitTimeDt: core.NewOptionalDateTime(l.TransmitTimeDt),
	}
	return json.Marshal(marshaler)
}

func (l *Logger) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// This object is a used to capture strings which may be truncated by a security product due to their length.
type LongString struct {
	// Indicates that <code>value</code> has been truncated. May be omitted if truncation has not occurred.
	IsTruncated *bool `json:"is_truncated,omitempty" url:"is_truncated,omitempty"`
	// The size in bytes of the string represented by <code>value</code> before truncation. Should be omitted if truncation has not occurred.
	UntruncatedSize *int `json:"untruncated_size,omitempty" url:"untruncated_size,omitempty"`
	// The string value, truncated if <code>is_truncated</code> is <code>true</code>.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LongString) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LongString) UnmarshalJSON(data []byte) error {
	type unmarshaler LongString
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LongString(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *LongString) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The Malware object describes the classification of known malicious software, which is intentionally designed to cause damage to a computer, server, client, or computer network.
type Malware struct {
	// The list of normalized identifiers of the malware classifications.
	ClassificationIds []MalwareClassificationIds `json:"classification_ids" url:"classification_ids"`
	// The list of malware classifications, normalized to the captions of the <code>classification_ids</code> values. In the case of 'Other', they are defined by the event source.
	Classifications []string `json:"classifications,omitempty" url:"classifications,omitempty"`
	// The list of Common Vulnerabilities and Exposures (CVE) identifiers associated with the malware. Reference: <a target='_blank' href='https://cve.mitre.org/'>CVE</a>
	Cves []*Cve `json:"cves,omitempty" url:"cves,omitempty"`
	// The list of file objects representing files that were identified as infected by the malware.
	Files []*File `json:"files,omitempty" url:"files,omitempty"`
	// The malware name, as reported by the detection engine.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The number of files that were identified to be infected by the malware.
	NumInfected *int `json:"num_infected,omitempty" url:"num_infected,omitempty"`
	// The filesystem path of the malware that was observed.
	Path *FilePath `json:"path,omitempty" url:"path,omitempty"`
	// The name or identifier of the security solution or service that provided the malware detection information.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// The severity of the malware, normalized to the captions of the <code>severity_id</code> values. In the case of 'Other', they are defined by the event source.
	Severity *string `json:"severity,omitempty" url:"severity,omitempty"`
	// The normalized identifier of the malware severity.
	SeverityId *MalwareSeverityId `json:"severity_id,omitempty" url:"severity_id,omitempty"`
	// A unique identifier for the specific malware instance, as assigned by the detection engine (e.g., virus signature ID or IPS rule ID).
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Malware) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Malware) UnmarshalJSON(data []byte) error {
	type unmarshaler Malware
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Malware(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *Malware) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The malware scan information object describes characteristics, metadata of a malware scanning job.
type MalwareScanInfo struct {
	// The timestamp indicating when the scan job completed execution.
	EndTime *Timestamp `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The timestamp indicating when the scan job completed execution.
	EndTimeDt *time.Time `json:"end_time_dt,omitempty" url:"end_time_dt,omitempty"`
	// The administrator-supplied or application-generated name of the scan. For example: "Home office weekly user database scan", "Scan folders for viruses", "Full system virus scan"
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The total number of files analyzed during the scan.
	NumFiles *int `json:"num_files,omitempty" url:"num_files,omitempty"`
	// The total number of files identified as infected with malware during the scan.
	NumInfected *int `json:"num_infected,omitempty" url:"num_infected,omitempty"`
	// The total number of storage volumes examined during the malware scan.
	NumVolumes *int `json:"num_volumes,omitempty" url:"num_volumes,omitempty"`
	// The total size in bytes of all files that were scanned.
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// The timestamp indicating when the scan job began execution.
	StartTime *Timestamp `json:"start_time,omitempty" url:"start_time,omitempty"`
	// The timestamp indicating when the scan job began execution.
	StartTimeDt *time.Time `json:"start_time_dt,omitempty" url:"start_time_dt,omitempty"`
	// Hosts or IP addresses targeted by the scan.
	Targets []string `json:"targets,omitempty" url:"targets,omitempty"`
	// The type of scan.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The type id of the scan.
	TypeId MalwareScanInfoTypeId `json:"type_id" url:"type_id"`
	// The application-defined unique identifier assigned to an instance of a scan.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The number of unique malware detected across all infected files.
	UniqueMalwareCount *int `json:"unique_malware_count,omitempty" url:"unique_malware_count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MalwareScanInfo) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MalwareScanInfo) UnmarshalJSON(data []byte) error {
	type embed MalwareScanInfo
	var unmarshaler = struct {
		embed
		EndTimeDt   *core.DateTime `json:"end_time_dt,omitempty"`
		StartTimeDt *core.DateTime `json:"start_time_dt,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MalwareScanInfo(unmarshaler.embed)
	m.EndTimeDt = unmarshaler.EndTimeDt.TimePtr()
	m.StartTimeDt = unmarshaler.StartTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *MalwareScanInfo) MarshalJSON() ([]byte, error) {
	type embed MalwareScanInfo
	var marshaler = struct {
		embed
		EndTimeDt   *core.DateTime `json:"end_time_dt,omitempty"`
		StartTimeDt *core.DateTime `json:"start_time_dt,omitempty"`
	}{
		embed:       embed(*m),
		EndTimeDt:   core.NewOptionalDateTime(m.EndTimeDt),
		StartTimeDt: core.NewOptionalDateTime(m.StartTimeDt),
	}
	return json.Marshal(marshaler)
}

func (m *MalwareScanInfo) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// MalwareScanInfoTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Manual: The scan was manually initiated by the user or administrator.
// 2 - Scheduled: The scan was started based on scheduler.
// 3 - UpdatedContent: The scan was triggered by a content update.
// 4 - QuarantinedItems: The scan was triggered by newly quarantined items.
// 5 - AttachedMedia: The scan was triggered by the attachment of removable media.
// 6 - UserLogon: The scan was started due to a user logon.
// 7 - ELAM: The scan was triggered by an Early Launch Anti-Malware (ELAM) detection.
// 99 - Other: The scan type id is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type MalwareScanInfoTypeId = int

// MalwareClassificationIds is an enum, and the following values are allowed.
// 0 - Unknown: The classification is unknown.
// 1 - Adware
// 2 - Backdoor
// 3 - Bot
// 4 - Bootkit
// 5 - DDOS
// 6 - Downloader
// 7 - Dropper
// 8 - Kit
// 9 - Keylogger
// 10 - Ransomware
// 11 - Access_Trojan
// 13 - Exploitation
// 14 - Security_Software
// 15 - Rootkit
// 16 - Capture
// 17 - Spyware
// 18 - Trojan
// 19 - Virus
// 20 - Webshell
// 21 - Wiper
// 22 - Worm
// 99 - Other: The classification is not mapped. See the <code>classifications</code> attribute, which contains a data source specific value.
type MalwareClassificationIds = int

// MalwareSeverityId is an enum, and the following values are allowed.
// 0 - Unknown: The event/finding severity is unknown.
// 1 - Informational: Informational message. No action required.
// 2 - Low: The user decides if action is needed.
// 3 - Medium: Action is required but the situation is not serious at this time.
// 4 - High: Action is required immediately.
// 5 - Critical: Action is required immediately and the scope is broad.
// 6 - Fatal: An error occurred but it is too late to take remedial action.
// 99 - Other: The event/finding severity is not mapped. See the <code>severity</code> attribute, which contains a data source specific value.
type MalwareSeverityId = int

// The Metadata object describes the metadata associated with the event.
type Metadata struct {
	// The unique identifier used to correlate events.
	CorrelationUid *string `json:"correlation_uid,omitempty" url:"correlation_uid,omitempty"`
	// Debug information about non-fatal issues with this OCSF event. Each issue is a line in this string array.
	Debug []string `json:"debug,omitempty" url:"debug,omitempty"`
	// The <code>Event ID, Code, or Name</code> that the product uses to primarily identify the event.
	EventCode *string `json:"event_code,omitempty" url:"event_code,omitempty"`
	// The schema extension used to create the event.
	Extension *Extension `json:"extension,omitempty" url:"extension,omitempty"`
	// The schema extensions used to create the event.
	Extensions []*Extension `json:"extensions,omitempty" url:"extensions,omitempty"`
	// Indicates whether the OCSF event data has been truncated due to size limitations. When <code>true</code>, some event data may have been omitted to fit within system constraints.
	IsTruncated *bool `json:"is_truncated,omitempty" url:"is_truncated,omitempty"`
	// The list of labels attached to the event. For example: <code>["sample", "dev"]</code>
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The audit level at which an event was generated.
	LogLevel *string `json:"log_level,omitempty" url:"log_level,omitempty"`
	// The event log name. For example, syslog file name or Windows logging subsystem: Security.
	LogName *string `json:"log_name,omitempty" url:"log_name,omitempty"`
	// The logging provider or logging service that logged the event. For example, Microsoft-Windows-Security-Auditing.
	LogProvider *string `json:"log_provider,omitempty" url:"log_provider,omitempty"`
	// The event log schema version that specifies the format of the original event. For example syslog version or Cisco Log Schema Version.
	LogVersion *string `json:"log_version,omitempty" url:"log_version,omitempty"`
	// <p>The time when the logging system collected and logged the event.</p>This attribute is distinct from the event time in that event time typically contain the time extracted from the original event. Most of the time, these two times will be different.
	LoggedTime *Timestamp `json:"logged_time,omitempty" url:"logged_time,omitempty"`
	// <p>The time when the logging system collected and logged the event.</p>This attribute is distinct from the event time in that event time typically contain the time extracted from the original event. Most of the time, these two times will be different.
	LoggedTimeDt *time.Time `json:"logged_time_dt,omitempty" url:"logged_time_dt,omitempty"`
	// An array of Logger objects that describe the devices and logging products between the event source and its eventual destination. Note, this attribute can be used when there is a complex end-to-end path of event flow.
	Loggers []*Logger `json:"loggers,omitempty" url:"loggers,omitempty"`
	// The time when the event was last modified or enriched.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The time when the event was last modified or enriched.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The original event time as reported by the event source. For example, the time in the original format from system event log such as Syslog on Unix/Linux and the System event file on Windows. Omit if event is generated instead of collected via logs.
	OriginalTime *string `json:"original_time,omitempty" url:"original_time,omitempty"`
	// The event processed time, such as an ETL operation.
	ProcessedTime *Timestamp `json:"processed_time,omitempty" url:"processed_time,omitempty"`
	// The event processed time, such as an ETL operation.
	ProcessedTimeDt *time.Time `json:"processed_time_dt,omitempty" url:"processed_time_dt,omitempty"`
	// The product that reported the event.
	Product *Product `json:"product" url:"product"`
	// The list of profiles used to create the event. Profiles should be referenced by their <code>name</code> attribute for core profiles, or <code>extension/name</code> for profiles from extensions.
	Profiles []string `json:"profiles,omitempty" url:"profiles,omitempty"`
	// Sequence number of the event. The sequence number is a value available in some events, to make the exact ordering of events unambiguous, regardless of the event time precision.
	Sequence *int `json:"sequence,omitempty" url:"sequence,omitempty"`
	// The list of tags; <code>{key:value}</code> pairs associated to the event.
	Tags []*KeyValueObject `json:"tags,omitempty" url:"tags,omitempty"`
	// The unique tenant identifier.
	TenantUid *string `json:"tenant_uid,omitempty" url:"tenant_uid,omitempty"`
	// An array of transformation info that describes the mappings or transforms applied to the data.
	TransformationInfoList []*TransformationInfo `json:"transformation_info_list,omitempty" url:"transformation_info_list,omitempty"`
	// The logging system-assigned unique identifier of an event instance.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The original size of the OCSF event data in kilobytes before any truncation occurred. This field is typically populated when <code>is_truncated</code> is <code>true</code> to indicate the full size of the original event.
	UntruncatedSize *int `json:"untruncated_size,omitempty" url:"untruncated_size,omitempty"`
	// The version of the OCSF schema, using Semantic Versioning Specification (<a target='_blank' href='https://semver.org'>SemVer</a>). For example: <code>1.0.0.</code> Event consumers use the version to determine the available event attributes.
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Metadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type embed Metadata
	var unmarshaler = struct {
		embed
		LoggedTimeDt    *core.DateTime `json:"logged_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
		ProcessedTimeDt *core.DateTime `json:"processed_time_dt,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Metadata(unmarshaler.embed)
	m.LoggedTimeDt = unmarshaler.LoggedTimeDt.TimePtr()
	m.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()
	m.ProcessedTimeDt = unmarshaler.ProcessedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *Metadata) MarshalJSON() ([]byte, error) {
	type embed Metadata
	var marshaler = struct {
		embed
		LoggedTimeDt    *core.DateTime `json:"logged_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
		ProcessedTimeDt *core.DateTime `json:"processed_time_dt,omitempty"`
	}{
		embed:           embed(*m),
		LoggedTimeDt:    core.NewOptionalDateTime(m.LoggedTimeDt),
		ModifiedTimeDt:  core.NewOptionalDateTime(m.ModifiedTimeDt),
		ProcessedTimeDt: core.NewOptionalDateTime(m.ProcessedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (m *Metadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The Metric object defines a simple name/value pair entity for a metric.
type Metric struct {
	// The name of the metric.
	Name string `json:"name" url:"name"`
	// The value of the metric.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Metric) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metric) UnmarshalJSON(data []byte) error {
	type unmarshaler Metric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metric(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *Metric) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The MITRE Mitigation object describes the ATT&CK® or ATLAS™ Mitigation ID and/or name that is associated to an attack.
type Mitigation struct {
	// The D3FEND countermeasures that are associated with the attack technique. For example: ATT&CK Technique <code>T1003</code> is addressed by Mitigation <code>M1027</code>, and D3FEND Technique <code>D3-OTP</code>.
	Countermeasures []*D3Fend `json:"countermeasures,omitempty" url:"countermeasures,omitempty"`
	// The Mitigation name that is associated with the attack technique. For example: <code>Password Policies</code>, or <code>Code Signing</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The versioned permalink of the Mitigation. For example: <code>https://attack.mitre.org/versions/v14/mitigations/M1027</code>.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The Mitigation ID that is associated with the attack technique. For example: <code>M1027</code>, or <code>AML.M0013</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Mitigation) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Mitigation) UnmarshalJSON(data []byte) error {
	type unmarshaler Mitigation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Mitigation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *Mitigation) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The Network Connection Information object describes characteristics of an OSI Transport Layer communication, including TCP and UDP.
type NetworkConnectionInfo struct {
	// The boundary of the connection, normalized to the caption of 'boundary_id'. In the case of 'Other', it is defined by the event source. <p> For cloud connections, this translates to the traffic-boundary(same VPC, through IGW, etc.). For traditional networks, this is described as Local, Internal, or External.</p>
	Boundary *string `json:"boundary,omitempty" url:"boundary,omitempty"`
	// <p>The normalized identifier of the boundary of the connection. </p><p> For cloud connections, this translates to the traffic-boundary (same VPC, through IGW, etc.). For traditional networks, this is described as Local, Internal, or External.</p>
	BoundaryId *NetworkConnectionInfoBoundaryId `json:"boundary_id,omitempty" url:"boundary_id,omitempty"`
	// The Community ID of the network connection.
	CommunityUid *string `json:"community_uid,omitempty" url:"community_uid,omitempty"`
	// The direction of the initiated connection, traffic, or email, normalized to the caption of the direction_id value. In the case of 'Other', it is defined by the event source.
	Direction *string `json:"direction,omitempty" url:"direction,omitempty"`
	// The normalized identifier of the direction of the initiated connection, traffic, or email.
	DirectionId NetworkConnectionInfoDirectionId `json:"direction_id" url:"direction_id"`
	// The Connection Flag History summarizes events in a network connection. For example flags <code> ShAD </code> representing SYN, SYN/ACK, ACK and Data exchange.
	FlagHistory *string `json:"flag_history,omitempty" url:"flag_history,omitempty"`
	// The IP protocol name in lowercase, as defined by the Internet Assigned Numbers Authority (IANA). For example: <code>tcp</code> or <code>udp</code>.
	ProtocolName *string `json:"protocol_name,omitempty" url:"protocol_name,omitempty"`
	// The IP protocol number, as defined by the Internet Assigned Numbers Authority (IANA). For example: <code>6</code> for TCP and <code>17</code> for UDP.
	ProtocolNum *int `json:"protocol_num,omitempty" url:"protocol_num,omitempty"`
	// The Internet Protocol version.
	ProtocolVer *string `json:"protocol_ver,omitempty" url:"protocol_ver,omitempty"`
	// The Internet Protocol version identifier.
	ProtocolVerId *NetworkConnectionInfoProtocolVerId `json:"protocol_ver_id,omitempty" url:"protocol_ver_id,omitempty"`
	// The authenticated user or service session.
	Session *Session `json:"session,omitempty" url:"session,omitempty"`
	// The network connection TCP header flags (i.e., control bits).
	TcpFlags *int `json:"tcp_flags,omitempty" url:"tcp_flags,omitempty"`
	// The unique identifier of the connection.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkConnectionInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkConnectionInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkConnectionInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkConnectionInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkConnectionInfo) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NetworkConnectionInfoBoundaryId is an enum, and the following values are allowed.
// 0 - Unknown: The connection boundary is unknown.
// 1 - Localhost: Local network traffic on the same endpoint.
// 2 - Internal: Internal network traffic between two endpoints inside network.
// 3 - External: External network traffic between two endpoints on the Internet or outside the network.
// 4 - SameVPC: Through another resource in the same VPC
// 5 - VPCGateway: Through an Internet gateway or a gateway VPC endpoint
// 6 - VirtualPrivateGateway: Through a virtual private gateway
// 7 - regionVPC: Through an intra-region VPC peering connection
// 8 - regionVPC: Through an inter-region VPC peering connection
// 9 - LocalGateway: Through a local gateway
// 10 - GatewayVPC: Through a gateway VPC endpoint (Nitro-based instances only)
// 11 - InternetGateway: Through an Internet gateway (Nitro-based instances only)
// 99 - Other: The boundary is not mapped. See the <code>boundary</code> attribute, which contains a data source specific value.
type NetworkConnectionInfoBoundaryId = int

// NetworkConnectionInfoDirectionId is an enum, and the following values are allowed.
// 0 - Unknown: The connection direction is unknown.
// 1 - Inbound: Inbound network connection. The connection was originated from the Internet or outside network, destined for services on the inside network.
// 2 - Outbound: Outbound network connection. The connection was originated from inside the network, destined for services on the Internet or outside network.
// 3 - Lateral: Lateral network connection. The connection was originated from inside the network, destined for services on the inside network.
// 99 - Other: The direction is not mapped. See the <code>direction</code> attribute, which contains a data source specific value.
type NetworkConnectionInfoDirectionId = int

// NetworkConnectionInfoProtocolVerId is an enum, and the following values are allowed.
// 0 - Unknown: The protocol version is unknown.
// 4 - IPv4*
// 6 - IPv6*
// 99 - Other: The protocol version is not mapped. See the <code>protocol_ver</code> attribute, which contains a data source specific value.
type NetworkConnectionInfoProtocolVerId = int

// The Network Endpoint object describes characteristics of a network endpoint. These can be a source or destination of a network connection.
type NetworkEndpoint struct {
	// A list of <code>agent</code> objects associated with a device, endpoint, or resource.
	AgentList []*Agent `json:"agent_list,omitempty" url:"agent_list,omitempty"`
	// The Autonomous System details associated with an IP address.
	AutonomousSystem *AutonomousSystem `json:"autonomous_system,omitempty" url:"autonomous_system,omitempty"`
	// The information describing an instance of a container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
	Container *Container `json:"container,omitempty" url:"container,omitempty"`
	// The name of the domain that the endpoint belongs to or that corresponds to the endpoint.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The fully qualified name of the endpoint.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The endpoint hardware information.
	HwInfo *DeviceHwInfo `json:"hw_info,omitempty" url:"hw_info,omitempty"`
	// The unique identifier of a VM instance.
	InstanceUid *string `json:"instance_uid,omitempty" url:"instance_uid,omitempty"`
	// The name of the network interface (e.g. eth2).
	InterfaceName *string `json:"interface_name,omitempty" url:"interface_name,omitempty"`
	// The unique identifier of the network interface.
	InterfaceUid *string `json:"interface_uid,omitempty" url:"interface_uid,omitempty"`
	// The intermediate IP Addresses. For example, the IP addresses in the HTTP X-Forwarded-For header.
	IntermediateIps []IpAddress `json:"intermediate_ips,omitempty" url:"intermediate_ips,omitempty"`
	// The IP address of the endpoint, in either IPv4 or IPv6 format.
	Ip *IpAddress `json:"ip,omitempty" url:"ip,omitempty"`
	// The name of the Internet Service Provider (ISP).
	Isp *string `json:"isp,omitempty" url:"isp,omitempty"`
	// The organization name of the Internet Service Provider (ISP). This represents the parent organization or company that owns/operates the ISP. For example, Comcast Corporation would be the ISP org for Xfinity internet service. This attribute helps identify the ultimate provider when ISPs operate under different brand names.
	IspOrg *string `json:"isp_org,omitempty" url:"isp_org,omitempty"`
	// The geographical location of the endpoint.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The Media Access Control (MAC) address of the endpoint.
	Mac *MacAddress `json:"mac,omitempty" url:"mac,omitempty"`
	// The short name of the endpoint.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// If running under a process namespace (such as in a container), the process identifier within that process namespace.
	NamespacePid *int `json:"namespace_pid,omitempty" url:"namespace_pid,omitempty"`
	// The endpoint operating system.
	Os *Os `json:"os,omitempty" url:"os,omitempty"`
	// The identity of the service or user account that owns the endpoint or was last logged into it.
	Owner *User `json:"owner,omitempty" url:"owner,omitempty"`
	// The port used for communication within the network connection.
	Port *Port `json:"port,omitempty" url:"port,omitempty"`
	// The network proxy information pertaining to a specific endpoint. This can be used to describe information pertaining to network address translation (NAT).
	ProxyEndpoint *NetworkProxy `json:"proxy_endpoint,omitempty" url:"proxy_endpoint,omitempty"`
	// The unique identifier of a virtual subnet.
	SubnetUid *string `json:"subnet_uid,omitempty" url:"subnet_uid,omitempty"`
	// The service name in service-to-service connections. For example, AWS VPC logs the pkt-src-aws-service and pkt-dst-aws-service fields identify the connection is coming from or going to an AWS service.
	SvcName *string `json:"svc_name,omitempty" url:"svc_name,omitempty"`
	// The network endpoint type. For example: <code>unknown</code>, <code>server</code>, <code>desktop</code>, <code>laptop</code>, <code>tablet</code>, <code>mobile</code>, <code>virtual</code>, <code>browser</code>, or <code>other</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The network endpoint type ID.
	TypeId *NetworkEndpointTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique identifier of the endpoint.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The Virtual LAN identifier.
	VlanUid *string `json:"vlan_uid,omitempty" url:"vlan_uid,omitempty"`
	// The unique identifier of the Virtual Private Cloud (VPC).
	VpcUid *string `json:"vpc_uid,omitempty" url:"vpc_uid,omitempty"`
	// The network zone or LAN segment.
	Zone *string `json:"zone,omitempty" url:"zone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkEndpoint) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkEndpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkEndpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkEndpoint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkEndpoint) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NetworkEndpointTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Server: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Server/'>server</a>.
// 2 - Desktop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:DesktopComputer/'>desktop computer</a>.
// 3 - Laptop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:LaptopComputer/'>laptop computer</a>.
// 4 - Tablet: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:TabletComputer/'>tablet computer</a>.
// 5 - Mobile: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:MobilePhone/'>mobile phone</a>.
// 6 - Virtual: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:VirtualizationSoftware/'>virtual machine</a>.
// 7 - IOT: An <a target='_blank' href='https://www.techtarget.com/iotagenda/definition/IoT-device'>IOT (Internet of Things) device</a>.
// 8 - Browser: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Browser/'>web browser</a>.
// 9 - Firewall: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Firewall/'>networking firewall</a>.
// 10 - Switch: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Switch/'>networking switch</a>.
// 11 - Hub: A <a target='_blank' href='https://en.wikipedia.org/wiki/Ethernet_hub'>networking hub</a>.
// 12 - Router: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Router/'>networking router</a>.
// 13 - IDS: An <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:IntrusionDetectionSystem/'>intrusion detection system</a>.
// 14 - IPS: An <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:IntrusionPreventionSystem/'>intrusion prevention system</a>.
// 15 - LoadBalancer: A <a target='_blank' href='https://en.wikipedia.org/wiki/Load_balancing_(computing)'>Load Balancer device.</a>
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type NetworkEndpointTypeId = int

// The Network Interface object describes the type and associated attributes of a physical or virtual network interface.
type NetworkInterface struct {
	// The hostname associated with the network interface.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The IP address associated with the network interface.
	Ip *IpAddress `json:"ip,omitempty" url:"ip,omitempty"`
	// A list of IP addresses available on the network interface.
	IpAddresses []string `json:"ip_addresses,omitempty" url:"ip_addresses,omitempty"`
	// The MAC address of the network interface.
	Mac *MacAddress `json:"mac,omitempty" url:"mac,omitempty"`
	// A list of MAC addresses available on the network interface.
	MacAddresses []string `json:"mac_addresses,omitempty" url:"mac_addresses,omitempty"`
	// The name of the network interface.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The namespace is useful in merger or acquisition situations. For example, when similar entities exist that you need to keep separate.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// The list of open ports on a network interface, including port numbers and associated protocol information.
	OpenPorts []*PortInfo `json:"open_ports,omitempty" url:"open_ports,omitempty"`
	// The subnet prefix length determines the number of bits used to represent the network part of the IP address. The remaining bits are reserved for identifying individual hosts within that subnet.
	SubnetPrefix *int `json:"subnet_prefix,omitempty" url:"subnet_prefix,omitempty"`
	// The type of network interface.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The network interface type identifier.
	TypeId *NetworkInterfaceTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique identifier for the network interface.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkInterface) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkInterface) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkInterface
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkInterface(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkInterface) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NetworkInterfaceTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Wired
// 2 - Wireless
// 3 - Mobile
// 4 - Tunnel
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type NetworkInterfaceTypeId = int

// The network proxy endpoint object describes a proxy server, which acts as an intermediary between a client requesting a resource and the server providing that resource.
type NetworkProxy struct {
	// A list of <code>agent</code> objects associated with a device, endpoint, or resource.
	AgentList []*Agent `json:"agent_list,omitempty" url:"agent_list,omitempty"`
	// The Autonomous System details associated with an IP address.
	AutonomousSystem *AutonomousSystem `json:"autonomous_system,omitempty" url:"autonomous_system,omitempty"`
	// The information describing an instance of a container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
	Container *Container `json:"container,omitempty" url:"container,omitempty"`
	// The name of the domain that the endpoint belongs to or that corresponds to the endpoint.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The fully qualified name of the endpoint.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The endpoint hardware information.
	HwInfo *DeviceHwInfo `json:"hw_info,omitempty" url:"hw_info,omitempty"`
	// The unique identifier of a VM instance.
	InstanceUid *string `json:"instance_uid,omitempty" url:"instance_uid,omitempty"`
	// The name of the network interface (e.g. eth2).
	InterfaceName *string `json:"interface_name,omitempty" url:"interface_name,omitempty"`
	// The unique identifier of the network interface.
	InterfaceUid *string `json:"interface_uid,omitempty" url:"interface_uid,omitempty"`
	// The intermediate IP Addresses. For example, the IP addresses in the HTTP X-Forwarded-For header.
	IntermediateIps []IpAddress `json:"intermediate_ips,omitempty" url:"intermediate_ips,omitempty"`
	// The IP address of the endpoint, in either IPv4 or IPv6 format.
	Ip *IpAddress `json:"ip,omitempty" url:"ip,omitempty"`
	// The name of the Internet Service Provider (ISP).
	Isp *string `json:"isp,omitempty" url:"isp,omitempty"`
	// The organization name of the Internet Service Provider (ISP). This represents the parent organization or company that owns/operates the ISP. For example, Comcast Corporation would be the ISP org for Xfinity internet service. This attribute helps identify the ultimate provider when ISPs operate under different brand names.
	IspOrg *string `json:"isp_org,omitempty" url:"isp_org,omitempty"`
	// The geographical location of the endpoint.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The Media Access Control (MAC) address of the endpoint.
	Mac *MacAddress `json:"mac,omitempty" url:"mac,omitempty"`
	// The short name of the endpoint.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// If running under a process namespace (such as in a container), the process identifier within that process namespace.
	NamespacePid *int `json:"namespace_pid,omitempty" url:"namespace_pid,omitempty"`
	// The endpoint operating system.
	Os *Os `json:"os,omitempty" url:"os,omitempty"`
	// The identity of the service or user account that owns the endpoint or was last logged into it.
	Owner *User `json:"owner,omitempty" url:"owner,omitempty"`
	// The port used for communication within the network connection.
	Port *Port `json:"port,omitempty" url:"port,omitempty"`
	// The network proxy information pertaining to a specific endpoint. This can be used to describe information pertaining to network address translation (NAT).
	ProxyEndpoint *Object `json:"proxy_endpoint,omitempty" url:"proxy_endpoint,omitempty"`
	// The unique identifier of a virtual subnet.
	SubnetUid *string `json:"subnet_uid,omitempty" url:"subnet_uid,omitempty"`
	// The service name in service-to-service connections. For example, AWS VPC logs the pkt-src-aws-service and pkt-dst-aws-service fields identify the connection is coming from or going to an AWS service.
	SvcName *string `json:"svc_name,omitempty" url:"svc_name,omitempty"`
	// The network endpoint type. For example: <code>unknown</code>, <code>server</code>, <code>desktop</code>, <code>laptop</code>, <code>tablet</code>, <code>mobile</code>, <code>virtual</code>, <code>browser</code>, or <code>other</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The network endpoint type ID.
	TypeId *NetworkProxyTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique identifier of the endpoint.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The Virtual LAN identifier.
	VlanUid *string `json:"vlan_uid,omitempty" url:"vlan_uid,omitempty"`
	// The unique identifier of the Virtual Private Cloud (VPC).
	VpcUid *string `json:"vpc_uid,omitempty" url:"vpc_uid,omitempty"`
	// The network zone or LAN segment.
	Zone *string `json:"zone,omitempty" url:"zone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkProxy) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkProxy) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkProxy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkProxy(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkProxy) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NetworkProxyTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Server: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Server/'>server</a>.
// 2 - Desktop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:DesktopComputer/'>desktop computer</a>.
// 3 - Laptop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:LaptopComputer/'>laptop computer</a>.
// 4 - Tablet: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:TabletComputer/'>tablet computer</a>.
// 5 - Mobile: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:MobilePhone/'>mobile phone</a>.
// 6 - Virtual: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:VirtualizationSoftware/'>virtual machine</a>.
// 7 - IOT: An <a target='_blank' href='https://www.techtarget.com/iotagenda/definition/IoT-device'>IOT (Internet of Things) device</a>.
// 8 - Browser: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Browser/'>web browser</a>.
// 9 - Firewall: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Firewall/'>networking firewall</a>.
// 10 - Switch: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Switch/'>networking switch</a>.
// 11 - Hub: A <a target='_blank' href='https://en.wikipedia.org/wiki/Ethernet_hub'>networking hub</a>.
// 12 - Router: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Router/'>networking router</a>.
// 13 - IDS: An <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:IntrusionDetectionSystem/'>intrusion detection system</a>.
// 14 - IPS: An <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:IntrusionPreventionSystem/'>intrusion prevention system</a>.
// 15 - LoadBalancer: A <a target='_blank' href='https://en.wikipedia.org/wiki/Load_balancing_(computing)'>Load Balancer device.</a>
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type NetworkProxyTypeId = int

// An unordered collection of attributes. It defines a set of attributes available in all objects. It can be also used as a generic object to log objects that are not otherwise defined by the schema.
type Object = map[string]interface{}

// The observable object is a pivot element that contains related information found in many places in the event.
type Observable struct {
	// The full name of the observable attribute. The <code>name</code> is a pointer/reference to an attribute within the OCSF event data. For example: <code>file.name</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Contains the original and normalized reputation scores.
	Reputation *Reputation `json:"reputation,omitempty" url:"reputation,omitempty"`
	// The observable value type name.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The observable value type identifier.
	TypeId ObservableTypeId `json:"type_id" url:"type_id"`
	// The value associated with the observable attribute. The meaning of the value depends on the observable type.<br/>If the <code>name</code> refers to a scalar attribute, then the <code>value</code> is the value of the attribute.<br/>If the <code>name</code> refers to an object attribute, then the <code>value</code> is not populated.
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Observable) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Observable) UnmarshalJSON(data []byte) error {
	type unmarshaler Observable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Observable(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Observable) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// ObservableTypeId is an enum, and the following values are allowed.
// 0 - Unknown: Unknown observable data type.
// 1 - Hostname: Unique name assigned to a device connected to a computer network. It may be a fully qualified domain name (FQDN). For example:<br><code>r2-d2.example.com.</code>,<br><code>mx.example.com</code>
// 2 - IPAddress: Internet Protocol address (IP address), in either IPv4 or IPv6 format. For example:<br><code>192.168.200.24</code>, <br> <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>.
// 3 - MACAddress: Media Access Control (MAC) address. For example:<br><code>18:36:F3:98:4F:9A</code>.
// 4 - UserName: User name. For example:<br><code>john_doe</code>.
// 5 - EmailAddress: Email address. For example:<br><code>john_doe@example.com</code>.
// 6 - URLString: Uniform Resource Locator (URL) string. For example:<br><code>http://www.example.com/download/trouble.exe</code>.
// 7 - FileName: File name. For example:<br><code>text-file.txt</code>.
// 8 - Hash: Hash. A unique value that corresponds to the content of the file, image, ja3_hash or hassh found in the schema. For example:<br> MD5: <code>3172ac7e2b55cbb81f04a6e65855a628</code>.
// 9 - ProcessName: Process name. For example:<br><code>Notepad</code>.
// 10 - ResourceUID: Resource unique identifier. For example, S3 Bucket name or EC2 Instance ID.
// 11 - Port: The TCP/UDP port number. For example:<br><code>80</code>,<br><code>22</code>.
// 12 - Subnet: The subnet represented in a CIDR notation, using the format network_address/prefix_length. The network_address can be in either IPv4 or IPv6 format. The prefix length indicates the number of bits used for the network portion, and the remaining bits are available for host addresses within that subnet. For example:<br><code>192.168.1.0/24</code>,<br><code>2001:0db8:85a3:0000::/64</code>
// 20 - Endpoint: The Endpoint object describes a physical or virtual device that connects to and exchanges information with a computer network. Some examples of endpoints are mobile devices, desktop computers, virtual machines, embedded devices, and servers. Internet-of-Things devices—like cameras, lighting, refrigerators, security systems, smart speakers, and thermostats—are also endpoints.
// 21 - User: The User object describes the characteristics of a user/person or a security principal.
// 22 - Email: The Email object describes the email metadata such as sender, recipients, and direction, and can include embedded URLs and files.
// 23 - UniformResourceLocator: The Uniform Resource Locator (URL) object describes the characteristics of a URL.
// 24 - File: The File object represents the metadata associated with a file stored in a computer system. It encompasses information about the file itself, including its attributes, properties, and organizational details.
// 25 - Process: The Process object describes a running instance of a launched program.
// 26 - GeoLocation: The Geo Location object describes a geographical location, usually associated with an IP address.
// 27 - Container: The Container object describes an instance of a specific container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
// 30 - Fingerprint: The Fingerprint object provides detailed information about a digital fingerprint, which is a compact representation of data used to identify a longer piece of information, such as a public key or file content. It contains the algorithm and value of the fingerprint, enabling efficient and reliable identification of the associated data.
// 45 - FilePath: The full path to the file. For example: For example:<br><code>c:\windows\system32\svchost.exe</code>.
// 99 - Other: The observable data type is not mapped. See the <code>type</code> attribute, which may contain data source specific value.
type ObservableTypeId = int

// The Organization object describes characteristics of an organization or company and its division if any. Additionally, it also describes cloud and Software-as-a-Service (SaaS) logical hierarchies such as AWS Organizations, Google Cloud Organizations, Oracle Cloud Tenancies, and similar constructs.
type Organization struct {
	// The name of the organization, Oracle Cloud Tenancy, Google Cloud Organization, or AWS Organization. For example, <code> Widget, Inc. </code> or the <code> AWS Organization name </code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The name of an organizational unit, Google Cloud Folder, or AWS Org Unit. For example, the <code> GCP Project Name </code>, or <code> Dev_Prod_OU </code>.
	OuName *string `json:"ou_name,omitempty" url:"ou_name,omitempty"`
	// The unique identifier of an organizational unit, Google Cloud Folder, or AWS Org Unit. For example, an <code> Oracle Cloud Tenancy ID </code>, <code> AWS OU ID </code>, or <code> GCP Folder ID </code>.
	OuUid *string `json:"ou_uid,omitempty" url:"ou_uid,omitempty"`
	// The unique identifier of the organization, Oracle Cloud Tenancy, Google Cloud Organization, or AWS Organization. For example, an <code> AWS Org ID </code> or <code> Oracle Cloud Domain ID </code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Organization) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Organization) UnmarshalJSON(data []byte) error {
	type unmarshaler Organization
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Organization(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Organization) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The Operating System (OS) object describes characteristics of an OS, such as Linux or Windows.
type Os struct {
	// The operating system build number.
	Build *string `json:"build,omitempty" url:"build,omitempty"`
	// The operating system country code, as defined by the ISO 3166-1 standard (Alpha-2 code).<p><b>Note:</b> The two letter country code should be capitalized. For example: <code>US</code> or <code>CA</code>.</p>
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// The Common Platform Enumeration (CPE) name as described by (<a target='_blank' href='https://nvd.nist.gov/products/cpe'>NIST</a>) For example: <code>cpe:/a:apple:safari:16.2</code>.
	CpeName *string `json:"cpe_name,omitempty" url:"cpe_name,omitempty"`
	// The cpu architecture, the number of bits used for addressing in memory. For example: <code>32</code> or <code>64</code>.
	CpuBits *int `json:"cpu_bits,omitempty" url:"cpu_bits,omitempty"`
	// The operating system edition. For example: <code>Professional</code>.
	Edition *string `json:"edition,omitempty" url:"edition,omitempty"`
	// The kernel release of the operating system. On Unix-based systems, this is determined from the <code>uname -r</code> command output, for example "5.15.0-122-generic".
	KernelRelease *string `json:"kernel_release,omitempty" url:"kernel_release,omitempty"`
	// The two letter lower case language codes, as defined by <a target='_blank' href='https://en.wikipedia.org/wiki/ISO_639-1'>ISO 639-1</a>. For example: <code>en</code> (English), <code>de</code> (German), or <code>fr</code> (French).
	Lang *string `json:"lang,omitempty" url:"lang,omitempty"`
	// The operating system name.
	Name string `json:"name" url:"name"`
	// The name of the latest Service Pack.
	SpName *string `json:"sp_name,omitempty" url:"sp_name,omitempty"`
	// The version number of the latest Service Pack.
	SpVer *int `json:"sp_ver,omitempty" url:"sp_ver,omitempty"`
	// The type of the operating system.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The type identifier of the operating system.
	TypeId OsTypeId `json:"type_id" url:"type_id"`
	// The version of the OS running on the device that originated the event. For example: "Windows 10", "OS X 10.7", or "iOS 9".
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Os) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Os) UnmarshalJSON(data []byte) error {
	type unmarshaler Os
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Os(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Os) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// OsTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// 100 - Windows
// 101 - WindowsMobile
// 200 - Linux
// 201 - Android
// 300 - macOS
// 301 - iOS
// 302 - iPadOS
// 400 - Solaris
// 401 - AIX
// 402 - UX
type OsTypeId = int

// The OSINT (Open Source Intelligence) object contains details related to an indicator such as the indicator itself, related indicators, geolocation, registrar information, subdomains, analyst commentary, and other contextual information. This information can be used to further enrich a detection or finding by providing decisioning support to other analysts and engineers.
type Osint struct {
	// Any pertinent DNS answers information related to an indicator or OSINT analysis.
	Answers []*DnsAnswer `json:"answers,omitempty" url:"answers,omitempty"`
	// MITRE ATT&CK Tactics, Techniques, and/or Procedures (TTPs) pertinent to an indicator or OSINT analysis.
	Attacks []*Attack `json:"attacks,omitempty" url:"attacks,omitempty"`
	// Any pertinent autonomous system information related to an indicator or OSINT analysis.
	AutonomousSystem *AutonomousSystem `json:"autonomous_system,omitempty" url:"autonomous_system,omitempty"`
	// The campaign object describes details about the campaign that was the source of the activity.
	Campaign *Campaign `json:"campaign,omitempty" url:"campaign,omitempty"`
	// Categorizes the threat indicator based on its functional or operational role.
	Category *string `json:"category,omitempty" url:"category,omitempty"`
	// Analyst commentary or source commentary about an indicator or OSINT analysis.
	Comment *string `json:"comment,omitempty" url:"comment,omitempty"`
	// The confidence of an indicator being malicious and/or pertinent, normalized to the caption of the confidence_id value. In the case of 'Other', it is defined by the event source or analyst.
	Confidence *string `json:"confidence,omitempty" url:"confidence,omitempty"`
	// The normalized confidence refers to the accuracy of collected information related to the OSINT or how pertinent an indicator or analysis is to a specific event or finding. A low confidence means that the information collected or analysis conducted lacked detail or is not accurate enough to qualify an indicator as fully malicious.
	ConfidenceId *OsintConfidenceId `json:"confidence_id,omitempty" url:"confidence_id,omitempty"`
	// The timestamp when the indicator was initially created or identified.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The timestamp when the indicator was initially created or identified.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The identifier of the user, system, or organization that contributed the indicator.
	Creator *User `json:"creator,omitempty" url:"creator,omitempty"`
	// A detailed explanation of the indicator, including its context, purpose, and relevance.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The specific detection pattern or signature associated with the indicator.
	DetectionPattern *string `json:"detection_pattern,omitempty" url:"detection_pattern,omitempty"`
	// The detection pattern type, normalized to the caption of the detection_pattern_type_id value. In the case of 'Other', it is defined by the event source.
	DetectionPatternType *string `json:"detection_pattern_type,omitempty" url:"detection_pattern_type,omitempty"`
	// Specifies the type of detection pattern used to identify the associated threat indicator.
	DetectionPatternTypeId *OsintDetectionPatternTypeId `json:"detection_pattern_type_id,omitempty" url:"detection_pattern_type_id,omitempty"`
	// Any email information pertinent to an indicator or OSINT analysis.
	Email *Email `json:"email,omitempty" url:"email,omitempty"`
	// Any email authentication information pertinent to an indicator or OSINT analysis.
	EmailAuth *EmailAuth `json:"email_auth,omitempty" url:"email_auth,omitempty"`
	// The expiration date of the indicator, after which it is no longer considered reliable.
	ExpirationTime *Timestamp `json:"expiration_time,omitempty" url:"expiration_time,omitempty"`
	// The expiration date of the indicator, after which it is no longer considered reliable.
	ExpirationTimeDt *time.Time `json:"expiration_time_dt,omitempty" url:"expiration_time_dt,omitempty"`
	// A unique identifier assigned by an external system for cross-referencing.
	ExternalUid *string `json:"external_uid,omitempty" url:"external_uid,omitempty"`
	// Any pertinent file information related to an indicator or OSINT analysis.
	File *File `json:"file,omitempty" url:"file,omitempty"`
	// A grouping of adversarial behaviors and resources believed to be associated with specific threat actors or campaigns. Intrusion sets often encompass multiple campaigns and are used to organize related activities under a common label.
	IntrusionSets []string `json:"intrusion_sets,omitempty" url:"intrusion_sets,omitempty"`
	// Lockheed Martin Kill Chain Phases pertinent to an indicator or OSINT analysis.
	KillChain []*KillChainPhase `json:"kill_chain,omitempty" url:"kill_chain,omitempty"`
	// Tags or keywords associated with the indicator to enhance searchability.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// Any pertinent geolocation information related to an indicator or OSINT analysis.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// A list of Malware objects, describing details about the identified malware.
	Malware []*Malware `json:"malware,omitempty" url:"malware,omitempty"`
	// The timestamp of the last modification or update to the indicator.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The timestamp of the last modification or update to the indicator.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The <code>name</code> is a pointer/reference to an attribute within the OCSF event data. For example: file.name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Provides a reference to an external source of information related to the CTI being represented. This may include a URL, a document, or some other type of reference that provides additional context or information about the CTI.
	References []string `json:"references,omitempty" url:"references,omitempty"`
	// Any analytics related to an indicator or OSINT analysis.
	RelatedAnalytics []*Analytic `json:"related_analytics,omitempty" url:"related_analytics,omitempty"`
	// Related reputational analysis from third-party engines and analysts for a given indicator or OSINT analysis.
	Reputation *Reputation `json:"reputation,omitempty" url:"reputation,omitempty"`
	// A numerical representation of the threat indicator’s risk level.
	RiskScore *int `json:"risk_score,omitempty" url:"risk_score,omitempty"`
	// Any pertinent script information related to an indicator or OSINT analysis.
	Script *Script `json:"script,omitempty" url:"script,omitempty"`
	// Represents the severity level of the threat indicator, typically reflecting its potential impact or damage.
	Severity *string `json:"severity,omitempty" url:"severity,omitempty"`
	// The normalized severity level of the threat indicator, typically reflecting its potential impact or damage.
	SeverityId *OsintSeverityId `json:"severity_id,omitempty" url:"severity_id,omitempty"`
	// Any digital signatures or hashes related to an indicator or OSINT analysis.
	Signatures []*DigitalSignature `json:"signatures,omitempty" url:"signatures,omitempty"`
	// The source URL of an indicator or OSINT analysis, e.g., a URL back to a TIP, report, or otherwise.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// Any pertinent subdomain information - such as those generated by a Domain Generation Algorithm - related to an indicator or OSINT analysis.
	Subdomains []string `json:"subdomains,omitempty" url:"subdomains,omitempty"`
	// A CIDR or network block related to an indicator or OSINT analysis.
	Subnet *Subnet `json:"subnet,omitempty" url:"subnet,omitempty"`
	// A threat actor is an individual or group that conducts malicious cyber activities, often with financial, political, or ideological motives.
	ThreatActor *ThreatActor `json:"threat_actor,omitempty" url:"threat_actor,omitempty"`
	// The <a target='_blank' href='https://www.first.org/tlp/'>Traffic Light Protocol</a> was created to facilitate greater sharing of potentially sensitive information and more effective collaboration. TLP provides a simple and intuitive schema for indicating with whom potentially sensitive information can be shared.
	Tlp *OsintTlp `json:"tlp,omitempty" url:"tlp,omitempty"`
	// The OSINT indicator type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The OSINT indicator type ID.
	TypeId OsintTypeId `json:"type_id" url:"type_id"`
	// The unique identifier for the OSINT object.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The timestamp indicating when the associated indicator or intelligence was added to the system or repository.
	UploadedTime *Timestamp `json:"uploaded_time,omitempty" url:"uploaded_time,omitempty"`
	// The timestamp indicating when the associated indicator or intelligence was added to the system or repository.
	UploadedTimeDt *time.Time `json:"uploaded_time_dt,omitempty" url:"uploaded_time_dt,omitempty"`
	// The actual indicator value in scope, e.g., a SHA-256 hash hexdigest or a domain name.
	Value string `json:"value" url:"value"`
	// The vendor name of a tool which generates intelligence or provides indicators.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`
	// Any vulnerabilities related to an indicator or OSINT analysis.
	Vulnerabilities []*Vulnerability `json:"vulnerabilities,omitempty" url:"vulnerabilities,omitempty"`
	// Any pertinent WHOIS information related to an indicator or OSINT analysis.
	Whois *Whois `json:"whois,omitempty" url:"whois,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Osint) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Osint) UnmarshalJSON(data []byte) error {
	type embed Osint
	var unmarshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
		ModifiedTimeDt   *core.DateTime `json:"modified_time_dt,omitempty"`
		UploadedTimeDt   *core.DateTime `json:"uploaded_time_dt,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Osint(unmarshaler.embed)
	o.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	o.ExpirationTimeDt = unmarshaler.ExpirationTimeDt.TimePtr()
	o.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()
	o.UploadedTimeDt = unmarshaler.UploadedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Osint) MarshalJSON() ([]byte, error) {
	type embed Osint
	var marshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
		ModifiedTimeDt   *core.DateTime `json:"modified_time_dt,omitempty"`
		UploadedTimeDt   *core.DateTime `json:"uploaded_time_dt,omitempty"`
	}{
		embed:            embed(*o),
		CreatedTimeDt:    core.NewOptionalDateTime(o.CreatedTimeDt),
		ExpirationTimeDt: core.NewOptionalDateTime(o.ExpirationTimeDt),
		ModifiedTimeDt:   core.NewOptionalDateTime(o.ModifiedTimeDt),
		UploadedTimeDt:   core.NewOptionalDateTime(o.UploadedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (o *Osint) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// OsintConfidenceId is an enum, and the following values are allowed.
// 0 - Unknown: The normalized confidence is unknown.
// 1 - Low
// 2 - Medium
// 3 - High
// 99 - Other: The confidence is not mapped to the defined enum values. See the <code>confidence</code> attribute, which contains a data source specific value.
type OsintConfidenceId = int

// OsintDetectionPatternTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is not mapped.
// 1 - STIX
// 2 - PCRE
// 3 - SIGMA
// 4 - Snort
// 5 - Suricata
// 6 - YARA
// 99 - Other: The detection pattern type is not mapped. See the <code>detection_pattern_type</code> attribute, which contains a data source specific value.
type OsintDetectionPatternTypeId = int

// OsintSeverityId is an enum, and the following values are allowed.
// 0 - Unknown: The event/finding severity is unknown.
// 1 - Informational: Informational message. No action required.
// 2 - Low: The user decides if action is needed.
// 3 - Medium: Action is required but the situation is not serious at this time.
// 4 - High: Action is required immediately.
// 5 - Critical: Action is required immediately and the scope is broad.
// 6 - Fatal: An error occurred but it is too late to take remedial action.
// 99 - Other: The event/finding severity is not mapped. See the <code>severity</code> attribute, which contains a data source specific value.
type OsintSeverityId = int

// OsintTlp is an enum, and the following values are allowed.
// AMBER - AMBER: TLP:AMBER is for limited disclosure, recipients can only spread this on a need-to-know basis within their organization and its clients. Note that TLP:AMBER+STRICT restricts sharing to the organization only. Sources may use TLP:AMBER when information requires support to be effectively acted upon, yet carries risk to privacy, reputation, or operations if shared outside of the organizations involved. Recipients may share TLP:AMBER information with members of their own organization and its clients, but only on a need-to-know basis to protect their organization and its clients and prevent further harm. Note: if the source wants to restrict sharing to the organization only, they must specify TLP:AMBER+STRICT.
// AMBER STRICT - AMBER_STRICT: TLP:AMBER is for limited disclosure, recipients can only spread this on a need-to-know basis within their organization and its clients. Note that TLP:AMBER+STRICT restricts sharing to the organization only. Sources may use TLP:AMBER when information requires support to be effectively acted upon, yet carries risk to privacy, reputation, or operations if shared outside of the organizations involved. Recipients may share TLP:AMBER information with members of their own organization and its clients, but only on a need-to-know basis to protect their organization and its clients and prevent further harm. Note: if the source wants to restrict sharing to the organization only, they must specify TLP:AMBER+STRICT.
// CLEAR - CLEAR: TLP:CLEAR denotes that recipients can spread this to the world, there is no limit on disclosure. Sources may use TLP:CLEAR when information carries minimal or no foreseeable risk of misuse, in accordance with applicable rules and procedures for public release. Subject to standard copyright rules, TLP:CLEAR information may be shared without restriction.
// GREEN - GREEN: TLP:GREEN is for limited disclosure, recipients can spread this within their community. Sources may use TLP:GREEN when information is useful to increase awareness within their wider community. Recipients may share TLP:GREEN information with peers and partner organizations within their community, but not via publicly accessible channels. TLP:GREEN information may not be shared outside of the community. Note: when “community” is not defined, assume the cybersecurity/defense community.
// RED - RED: TLP:RED is for the eyes and ears of individual recipients only, no further disclosure. Sources may use TLP:RED when information cannot be effectively acted upon without significant risk for the privacy, reputation, or operations of the organizations involved. Recipients may therefore not share TLP:RED information with anyone else. In the context of a meeting, for example, TLP:RED information is limited to those present at the meeting.
// WHITE - WHITE: TLP:WHITE and TLP:CLEAR may be used interchangeably, TLP:WHITE is the most up to date (as of TLP 2.0) usage.
type OsintTlp = string

// OsintTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The indicator type is ambiguous or there is not a related indicator for the OSINT object.
// 1 - IPAddress: An IPv4 or IPv6 address.
// 2 - Domain: A full-qualified domain name (FQDN), subdomain, or partial domain.
// 3 - Hostname: A hostname or computer name.
// 4 - Hash: Any type of hash e.g., MD5, SHA1, SHA2, BLAKE, BLAKE2, SSDEEP, VHASH, etc. generated from a file, malware sample, request header, or otherwise used to identify a pertinent artifact.
// 5 - URL: A Uniform Resource Locator (URL) or Uniform Resource Indicator (URI).
// 6 - UserAgent: A User Agent typically seen in HTTP request headers.
// 7 - DigitalCertificate: The serial number, fingerprint, or full content of an X.509 digital certificate.
// 8 - Email: The contents of an email or any related information to an email object.
// 9 - EmailAddress: An email address.
// 10 - Vulnerability: A CVE ID, CWE ID, or other identifier for a weakness, exploit, bug, or misconfiguration.
// 11 - File: A file or metadata about a file.
// 12 - RegistryKey: A Windows Registry Key.
// 13 - RegistryValue: A Windows Registry Value.
// 14 - CommandLine: A partial or full Command Line used to invoke scripts or other remote commands.
// 99 - Other: The indicator type is not directly listed.
type OsintTypeId = int

// The Software Package object describes details about a software package.
type Package struct {
	// Architecture is a shorthand name describing the type of computer hardware the packaged software is meant to run on.
	Architecture *string `json:"architecture,omitempty" url:"architecture,omitempty"`
	// The Common Platform Enumeration (CPE) name for the software package.
	CpeName *string `json:"cpe_name,omitempty" url:"cpe_name,omitempty"`
	// The software package epoch. Epoch is a way to define weighted dependencies based on version numbers.
	Epoch *int `json:"epoch,omitempty" url:"epoch,omitempty"`
	// Cryptographic hash to identify the binary instance of a software component. This can include any component such file, package, or library.
	Hash *Fingerprint `json:"hash,omitempty" url:"hash,omitempty"`
	// The software license applied to this package.
	License *string `json:"license,omitempty" url:"license,omitempty"`
	// The URL pointing to the license applied on package or software. This is typically a <code>LICENSE.md</code> file within a repository.
	LicenseUrl *UrlString `json:"license_url,omitempty" url:"license_url,omitempty"`
	// The software package name.
	Name string `json:"name" url:"name"`
	// The software packager manager utilized to manage a package on a system, e.g. npm, yum, dpkg etc.
	PackageManager *string `json:"package_manager,omitempty" url:"package_manager,omitempty"`
	// The URL of the package or library at the package manager, or the specific URL or URI of an internal package manager link such as <code>AWS CodeArtifact</code> or <code>Artifactory</code>.
	PackageManagerUrl *UrlString `json:"package_manager_url,omitempty" url:"package_manager_url,omitempty"`
	// A purl is a URL string used to identify and locate a software package in a mostly universal and uniform way across programming languages, package managers, packaging conventions, tools, APIs and databases.
	Purl *string `json:"purl,omitempty" url:"purl,omitempty"`
	// Release is the number of times a version of the software has been packaged.
	Release *string `json:"release,omitempty" url:"release,omitempty"`
	// The link to the specific library or package such as within <code>GitHub</code>, this is different from the link to the package manager where the library or package is hosted.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The type of software package, normalized to the caption of the <code>type_id</code> value. In the case of 'Other', it is defined by the source.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The type of software package.
	TypeId *PackageTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// A unique identifier for the package or library reported by the source tool. E.g., the <code>libId</code> within the <code>sbom</code> field of an OX Security Issue or the SPDX <code>components.\*.bom-ref</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the vendor who published the software package.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`
	// The software package version.
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Package) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Package) UnmarshalJSON(data []byte) error {
	type unmarshaler Package
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Package(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Package) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// PackageTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Application: An application software package.
// 2 - OperatingSystem: An operating system software package.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type PackageTypeId = int

// The Policy object describes the policies that are applicable. <p>Policy attributes provide traceability to the operational state of the security product at the time that the event was captured, facilitating forensics, troubleshooting, and policy tuning/adjustments.</p>
type Policy struct {
	// Additional data about the policy such as the underlying JSON policy itself or other details.
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`
	// The description of the policy.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The policy group.
	Group *Group `json:"group,omitempty" url:"group,omitempty"`
	// A determination if the content of a policy was applied to a target or request, or not.
	IsApplied *bool `json:"is_applied,omitempty" url:"is_applied,omitempty"`
	// The policy name. For example: <code>AdministratorAccess Policy</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The policy type. For example: <code>Identity Policy, Resource Policy, Service Control Policy, etc./code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique identifier of the policy instance.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The policy version number.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Policy) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Policy) UnmarshalJSON(data []byte) error {
	type unmarshaler Policy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Policy(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Policy) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The Port Information object describes a port and its associated protocol details.
type PortInfo struct {
	// The port number. For example: <code>80</code>, <code>443</code>, <code>22</code>.
	Port Port `json:"port" url:"port"`
	// The IP protocol name in lowercase, as defined by the Internet Assigned Numbers Authority (IANA). For example: <code>tcp</code> or <code>udp</code>.
	ProtocolName *string `json:"protocol_name,omitempty" url:"protocol_name,omitempty"`
	// The IP protocol number, as defined by the Internet Assigned Numbers Authority (IANA). For example: <code>6</code> for TCP and <code>17</code> for UDP.
	ProtocolNum *int `json:"protocol_num,omitempty" url:"protocol_num,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PortInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PortInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PortInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PortInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *PortInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The Process object describes a running instance of a launched program.
type Process struct {
	// An array of Process Entities describing the extended parentage of this process object. Direct parent information should be expressed through the <code>parent_process</code> attribute. The first array element is the direct parent of this process object. Subsequent list elements go up the process parentage hierarchy. That is, the array is sorted from newest to oldest process. It is recommended to only populate this field for the top-level process object.
	Ancestry []*ProcessEntity `json:"ancestry,omitempty" url:"ancestry,omitempty"`
	// The audit user assigned at login by the audit subsystem.
	Auid *int `json:"auid,omitempty" url:"auid,omitempty"`
	// The full command line used to launch an application, service, process, or job. For example: <code>ssh user@10.0.0.10</code>. If the command line is unavailable or missing, the empty string <code>”</code> is to be used.
	CmdLine *string `json:"cmd_line,omitempty" url:"cmd_line,omitempty"`
	// The information describing an instance of a container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
	Container *Container `json:"container,omitempty" url:"container,omitempty"`
	// A unique process identifier that can be assigned deterministically by multiple system data producers.
	Cpid *string `json:"cpid,omitempty" url:"cpid,omitempty"`
	// The time when the process was created/started.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the process was created/started.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The effective group under which this process is running.
	Egid *int `json:"egid,omitempty" url:"egid,omitempty"`
	// Environment variables associated with the process.
	EnvironmentVariables []*EnvironmentVariable `json:"environment_variables,omitempty" url:"environment_variables,omitempty"`
	// The effective user under which this process is running.
	Euid *int `json:"euid,omitempty" url:"euid,omitempty"`
	// The process file object.
	File *File `json:"file,omitempty" url:"file,omitempty"`
	// The group under which this process is running.
	Group *Group `json:"group,omitempty" url:"group,omitempty"`
	// The process integrity level, normalized to the caption of the integrity_id value. In the case of 'Other', it is defined by the event source (Windows only).
	Integrity *string `json:"integrity,omitempty" url:"integrity,omitempty"`
	// The normalized identifier of the process integrity level (Windows only).
	IntegrityId *ProcessIntegrityId `json:"integrity_id,omitempty" url:"integrity_id,omitempty"`
	// The lineage of the process, represented by a list of paths for each ancestor process. For example: <code>['/usr/sbin/sshd', '/usr/bin/bash', '/usr/bin/whoami']</code>.
	Lineage []FilePath `json:"lineage,omitempty" url:"lineage,omitempty"`
	// The list of loaded module names.
	LoadedModules []string `json:"loaded_modules,omitempty" url:"loaded_modules,omitempty"`
	// The friendly name of the process, for example: <code>Notepad++</code>.
	Name *ProcessName `json:"name,omitempty" url:"name,omitempty"`
	// If running under a process namespace (such as in a container), the process identifier within that process namespace.
	NamespacePid *int `json:"namespace_pid,omitempty" url:"namespace_pid,omitempty"`
	// The parent process of this process object. It is recommended to only populate this field for the top-level process object, to prevent deep nesting. Additional ancestry information can be supplied in the <code>ancestry</code> attribute.
	ParentProcess *Object `json:"parent_process,omitempty" url:"parent_process,omitempty"`
	// The process file path.
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// The process identifier, as reported by the operating system. Process ID (PID) is a number used by the operating system to uniquely identify an active process.
	Pid *int `json:"pid,omitempty" url:"pid,omitempty"`
	// The identifier of the process thread associated with the event, as returned by the operating system.
	Ptid *int `json:"ptid,omitempty" url:"ptid,omitempty"`
	// The name of the containment jail (i.e., sandbox). For example, hardened_ps, high_security_ps, oracle_ps, netsvcs_ps, or default_ps.
	Sandbox *string `json:"sandbox,omitempty" url:"sandbox,omitempty"`
	// The user session under which this process is running.
	Session *Session `json:"session,omitempty" url:"session,omitempty"`
	// The time when the process was terminated.
	TerminatedTime *Timestamp `json:"terminated_time,omitempty" url:"terminated_time,omitempty"`
	// The time when the process was terminated.
	TerminatedTimeDt *time.Time `json:"terminated_time_dt,omitempty" url:"terminated_time_dt,omitempty"`
	// The identifier of the thread associated with the event, as returned by the operating system.
	Tid *int `json:"tid,omitempty" url:"tid,omitempty"`
	// A unique identifier for this process assigned by the producer (tool). Facilitates correlation of a process event with other events for that process.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The user under which this process is running.
	User *User `json:"user,omitempty" url:"user,omitempty"`
	// The working directory of a process.
	WorkingDirectory *string `json:"working_directory,omitempty" url:"working_directory,omitempty"`
	// An unordered collection of zero or more name/value pairs that represent a process extended attribute.
	Xattributes *Object `json:"xattributes,omitempty" url:"xattributes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Process) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Process) UnmarshalJSON(data []byte) error {
	type embed Process
	var unmarshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		TerminatedTimeDt *core.DateTime `json:"terminated_time_dt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Process(unmarshaler.embed)
	p.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	p.TerminatedTimeDt = unmarshaler.TerminatedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Process) MarshalJSON() ([]byte, error) {
	type embed Process
	var marshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		TerminatedTimeDt *core.DateTime `json:"terminated_time_dt,omitempty"`
	}{
		embed:            embed(*p),
		CreatedTimeDt:    core.NewOptionalDateTime(p.CreatedTimeDt),
		TerminatedTimeDt: core.NewOptionalDateTime(p.TerminatedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (p *Process) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The Process Entity object provides critical fields for referencing a process.
type ProcessEntity struct {
	// The full command line used to launch an application, service, process, or job. For example: <code>ssh user@10.0.0.10</code>. If the command line is unavailable or missing, the empty string <code>”</code> is to be used.
	CmdLine *string `json:"cmd_line,omitempty" url:"cmd_line,omitempty"`
	// A unique process identifier that can be assigned deterministically by multiple system data producers.
	Cpid *string `json:"cpid,omitempty" url:"cpid,omitempty"`
	// The time when the process was created/started.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the process was created/started.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The friendly name of the process, for example: <code>Notepad++</code>.
	Name *ProcessName `json:"name,omitempty" url:"name,omitempty"`
	// The process file path.
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// The process identifier, as reported by the operating system. Process ID (PID) is a number used by the operating system to uniquely identify an active process.
	Pid *int `json:"pid,omitempty" url:"pid,omitempty"`
	// A unique identifier for this process assigned by the producer (tool). Facilitates correlation of a process event with other events for that process.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProcessEntity) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessEntity) UnmarshalJSON(data []byte) error {
	type embed ProcessEntity
	var unmarshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = ProcessEntity(unmarshaler.embed)
	p.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProcessEntity) MarshalJSON() ([]byte, error) {
	type embed ProcessEntity
	var marshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed:         embed(*p),
		CreatedTimeDt: core.NewOptionalDateTime(p.CreatedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (p *ProcessEntity) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// ProcessIntegrityId is an enum, and the following values are allowed.
// 0 - Unknown: The integrity level is unknown.
// 1 - Untrusted
// 2 - Low
// 3 - Medium
// 4 - High
// 5 - System
// 6 - Protected
// 99 - Other: The integrity level is not mapped. See the <code>integrity</code> attribute, which contains a data source specific value.
type ProcessIntegrityId = int

// The Product object describes characteristics of a software product.
type Product struct {
	// The Common Platform Enumeration (CPE) name as described by (<a target='_blank' href='https://nvd.nist.gov/products/cpe'>NIST</a>) For example: <code>cpe:/a:apple:safari:16.2</code>.
	CpeName *string `json:"cpe_name,omitempty" url:"cpe_name,omitempty"`
	// Indicates the source from which the app was installed, such as the app store.
	DistributionMode *string `json:"distribution_mode,omitempty" url:"distribution_mode,omitempty"`
	// The feature that reported the event.
	Feature *Feature `json:"feature,omitempty" url:"feature,omitempty"`
	// The two letter lower case language codes, as defined by <a target='_blank' href='https://en.wikipedia.org/wiki/ISO_639-1'>ISO 639-1</a>. For example: <code>en</code> (English), <code>de</code> (German), or <code>fr</code> (French).
	Lang *string `json:"lang,omitempty" url:"lang,omitempty"`
	// The name of the product.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The installation path of the product.
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// The unique identifier of the product.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The URL pointing towards the product.
	UrlString *UrlString `json:"url_string,omitempty" url:"url_string,omitempty"`
	// The name of the vendor of the product.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`
	// The version of the product, as defined by the event source. For example: <code>2013.1.3-beta</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// The product workload associated with the event.
	Workload *string `json:"workload,omitempty" url:"workload,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Product) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Product) UnmarshalJSON(data []byte) error {
	type unmarshaler Product
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Product(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Product) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The Programmatic Credential object describes service-specific credentials used for direct API access and system integration. These credentials are typically issued by individual services or platforms for accessing their APIs and resources, focusing on credential lifecycle management and usage tracking. Examples include API keys, service account keys, client certificates, and vendor-specific access tokens.
type ProgrammaticCredential struct {
	// The timestamp when this programmatic credential was last used for authentication or API access. This helps track credential usage patterns, identify dormant credentials that may pose security risks, and support credential lifecycle management. The timestamp should reflect the most recent successful authentication or API call using this credential.
	LastUsedTime *Timestamp `json:"last_used_time,omitempty" url:"last_used_time,omitempty"`
	// The timestamp when this programmatic credential was last used for authentication or API access. This helps track credential usage patterns, identify dormant credentials that may pose security risks, and support credential lifecycle management. The timestamp should reflect the most recent successful authentication or API call using this credential.
	LastUsedTimeDt *time.Time `json:"last_used_time_dt,omitempty" url:"last_used_time_dt,omitempty"`
	// The type or category of programmatic credential, normalized to the caption of the type_id value. In the case of 'Other', it is defined by the event source. Examples include 'API Key', 'Service Account Key', 'Access Token', 'Client Certificate', 'OAuth Token', 'Personal Access Token', etc.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique identifier of the programmatic credential. This could be an API key ID, service account key ID, access token identifier, certificate serial number, or other unique identifier that distinguishes this credential from others. Examples: AWS Access Key ID, GCP Service Account Key ID, Azure Application ID, or OAuth2 token identifier.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProgrammaticCredential) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProgrammaticCredential) UnmarshalJSON(data []byte) error {
	type embed ProgrammaticCredential
	var unmarshaler = struct {
		embed
		LastUsedTimeDt *core.DateTime `json:"last_used_time_dt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = ProgrammaticCredential(unmarshaler.embed)
	p.LastUsedTimeDt = unmarshaler.LastUsedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *ProgrammaticCredential) MarshalJSON() ([]byte, error) {
	type embed ProgrammaticCredential
	var marshaler = struct {
		embed
		LastUsedTimeDt *core.DateTime `json:"last_used_time_dt,omitempty"`
	}{
		embed:          embed(*p),
		LastUsedTimeDt: core.NewOptionalDateTime(p.LastUsedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (p *ProgrammaticCredential) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The Remediation object describes the recommended remediation steps to address identified issue(s).
type Remediation struct {
	// An array of Center for Internet Security (CIS) Controls that can be optionally mapped to provide additional remediation details.
	CisControls []*CisControl `json:"cis_controls,omitempty" url:"cis_controls,omitempty"`
	// The description of the remediation strategy.
	Desc string `json:"desc" url:"desc"`
	// A list of KB articles or patches related to an endpoint. A KB Article contains metadata that describes the patch or an update.
	KbArticleList []*KbArticle `json:"kb_article_list,omitempty" url:"kb_article_list,omitempty"`
	// The KB article/s related to the entity. A KB Article contains metadata that describes the patch or an update.
	KbArticles []string `json:"kb_articles,omitempty" url:"kb_articles,omitempty"`
	// A list of supporting URL/s, references that help describe the remediation strategy.
	References []string `json:"references,omitempty" url:"references,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Remediation) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Remediation) UnmarshalJSON(data []byte) error {
	type unmarshaler Remediation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Remediation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Remediation) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The Reputation object describes the reputation/risk score of an entity (e.g. device, user, domain).
type Reputation struct {
	// The reputation score as reported by the event source.
	BaseScore float64 `json:"base_score" url:"base_score"`
	// The provider of the reputation information.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// The reputation score, normalized to the caption of the score_id value. In the case of 'Other', it is defined by the event source.
	Score *string `json:"score,omitempty" url:"score,omitempty"`
	// The normalized reputation score identifier.
	ScoreId ReputationScoreId `json:"score_id" url:"score_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Reputation) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Reputation) UnmarshalJSON(data []byte) error {
	type unmarshaler Reputation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Reputation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Reputation) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// ReputationScoreId is an enum, and the following values are allowed.
// 0 - Unknown: The reputation score is unknown.
// 1 - VerySafe: Long history of good behavior.
// 2 - Safe: Consistently good behavior.
// 3 - ProbablySafe: Reasonable history of good behavior.
// 4 - LeansSafe: Starting to establish a history of normal behavior.
// 5 - MaynotbeSafe: No established history of normal behavior.
// 6 - ExerciseCaution: Starting to establish a history of suspicious or risky behavior.
// 7 - Risky: A site with a history of suspicious or risky behavior. (spam, scam, potentially unwanted software, potentially malicious).
// 8 - PossiblyMalicious: Strong possibility of maliciousness.
// 9 - ProbablyMalicious: Indicators of maliciousness.
// 10 - Malicious: Proven evidence of maliciousness.
// 99 - Other: The reputation score is not mapped. See the <code>rep_score</code> attribute, which contains a data source specific value.
type ReputationScoreId = int

// The Request Elements object describes characteristics of an API request.
type Request struct {
	// When working with containerized applications, the set of containers which write to the standard the output of a particular logging driver. For example, this may be the set of containers involved in handling api requests and responses for a containerized application.
	Containers []*Container `json:"containers,omitempty" url:"containers,omitempty"`
	// The additional data that is associated with the api request.
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`
	// The communication flags that are associated with the api request.
	Flags []string `json:"flags,omitempty" url:"flags,omitempty"`
	// The unique request identifier.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Request) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Request) UnmarshalJSON(data []byte) error {
	type unmarshaler Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Request) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The Response Elements object describes characteristics of an API response.
type Response struct {
	// The numeric response sent to a request.
	Code *int `json:"code,omitempty" url:"code,omitempty"`
	// When working with containerized applications, the set of containers which write to the standard the output of a particular logging driver. For example, this may be the set of containers involved in handling api requests and responses for a containerized application.
	Containers []*Container `json:"containers,omitempty" url:"containers,omitempty"`
	// The additional data that is associated with the api response.
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Error Code
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Error Message
	ErrorMessage *string `json:"error_message,omitempty" url:"error_message,omitempty"`
	// The communication flags that are associated with the api response.
	Flags []string `json:"flags,omitempty" url:"flags,omitempty"`
	// The description of the event/finding, as defined by the source.
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Response) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Response) UnmarshalJSON(data []byte) error {
	type unmarshaler Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Response(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Response) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The Rule object describes characteristics of a rule associated with a policy or an event.
type Rule struct {
	// The rule category.
	Category *string `json:"category,omitempty" url:"category,omitempty"`
	// The description of the rule that generated the event.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The name of the rule that generated the event.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The rule type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique identifier of the rule that generated the event.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The rule version. For example: <code>1.1</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Rule) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	type unmarshaler Rule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Rule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Rule) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The Subject Alternative name (SAN) object describes a SAN secured by a digital certificate
type San struct {
	// Name of SAN (e.g. The actual IP Address or domain.)
	Name string `json:"name" url:"name"`
	// Type descriptor of SAN (e.g. IP Address/domain/etc.)
	Type string `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *San) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *San) UnmarshalJSON(data []byte) error {
	type unmarshaler San
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = San(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *San) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The System for Cross-domain Identity Management (SCIM) Configuration object provides a structured set of attributes related to SCIM protocols used for identity provisioning and management across cloud-based platforms. It standardizes user and group provisioning details, enabling identity synchronization and lifecycle management with compatible Identity Providers (IdPs) and applications. SCIM is defined in <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc7643'>RFC-7634</a>
type Scim struct {
	// The authorization protocol as defined by the caption of <code>auth_protocol_id</code>. In the case of <code>Other</code>, it is defined by the event source.
	AuthProtocol *string `json:"auth_protocol,omitempty" url:"auth_protocol,omitempty"`
	// The normalized identifier of the authorization protocol used by the SCIM resource.
	AuthProtocolId *ScimAuthProtocolId `json:"auth_protocol_id,omitempty" url:"auth_protocol_id,omitempty"`
	// When the SCIM resource was added to the service provider.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// When the SCIM resource was added to the service provider.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// Message or code associated with the last encountered error.
	ErrorMessage *string `json:"error_message,omitempty" url:"error_message,omitempty"`
	// Indicates whether the SCIM resource is configured to provision groups, automatically or otherwise.
	IsGroupProvisioningEnabled *bool `json:"is_group_provisioning_enabled,omitempty" url:"is_group_provisioning_enabled,omitempty"`
	// Indicates whether the SCIM resource is configured to provision users, automatically or otherwise.
	IsUserProvisioningEnabled *bool `json:"is_user_provisioning_enabled,omitempty" url:"is_user_provisioning_enabled,omitempty"`
	// Timestamp of the most recent successful synchronization.
	LastRunTime *Timestamp `json:"last_run_time,omitempty" url:"last_run_time,omitempty"`
	// Timestamp of the most recent successful synchronization.
	LastRunTimeDt *time.Time `json:"last_run_time_dt,omitempty" url:"last_run_time_dt,omitempty"`
	// The most recent time when the SCIM resource was updated at the service provider.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The most recent time when the SCIM resource was updated at the service provider.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The name of the SCIM resource.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The supported protocol for the SCIM resource. E.g., <code>SAML</code>, <code>OIDC</code>, or <code>OAuth2</code>.
	ProtocolName *string `json:"protocol_name,omitempty" url:"protocol_name,omitempty"`
	// Maximum number of requests allowed by the SCIM resource within a specified time frame to avoid throttling.
	RateLimit *int `json:"rate_limit,omitempty" url:"rate_limit,omitempty"`
	// SCIM provides a schema for representing groups, identified using the following schema URI: <code>urn:ietf:params:scim:schemas:core:2.0:Group</code> as defined in <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc7643'>RFC-7634</a>. This attribute will capture key-value pairs for the scheme implemented in a SCIM resource.
	ScimGroupSchema interface{} `json:"scim_group_schema,omitempty" url:"scim_group_schema,omitempty"`
	// SCIM provides a resource type for user resources. The core schema for user is identified using the following schema URI: <code>urn:ietf:params:scim:schemas:core:2.0:User</code> as defined in <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc7643'>RFC-7634</a>. his attribute will capture key-value pairs for the scheme implemented in a SCIM resource. This object is inclusive of both the basic and Enterprise User Schema Extension.
	ScimUserSchema interface{} `json:"scim_user_schema,omitempty" url:"scim_user_schema,omitempty"`
	// The provisioning state of the SCIM resource, normalized to the caption of the <code>state_id</code> value. In the case of <code>Other</code>, it is defined by the event source.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// The normalized state ID of the SCIM resource to reflect its activation status.
	StateId *ScimStateId `json:"state_id,omitempty" url:"state_id,omitempty"`
	// A unique identifier for a SCIM resource as defined by the service provider.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// A String that is an identifier for the resource as defined by the provisioning client. The <code>externalId</code> may simplify identification of a resource between the provisioning client and the service provider by allowing the client to use a filter to locate the resource with an identifier from the provisioning domain, obviating the need to store a local mapping between the provisioning domain's identifier of the resource and the identifier used by the service provider.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The primary URL for SCIM API requests.
	UrlString *UrlString `json:"url_string,omitempty" url:"url_string,omitempty"`
	// Name of the vendor or service provider implementing SCIM. E.g., <code>Okta</code>, <code>Auth0</code>, <code>Microsoft</code>.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`
	// SCIM protocol version supported e.g., <code>SCIM 2.0</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Scim) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Scim) UnmarshalJSON(data []byte) error {
	type embed Scim
	var unmarshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		LastRunTimeDt  *core.DateTime `json:"last_run_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Scim(unmarshaler.embed)
	s.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	s.LastRunTimeDt = unmarshaler.LastRunTimeDt.TimePtr()
	s.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Scim) MarshalJSON() ([]byte, error) {
	type embed Scim
	var marshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		LastRunTimeDt  *core.DateTime `json:"last_run_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:          embed(*s),
		CreatedTimeDt:  core.NewOptionalDateTime(s.CreatedTimeDt),
		LastRunTimeDt:  core.NewOptionalDateTime(s.LastRunTimeDt),
		ModifiedTimeDt: core.NewOptionalDateTime(s.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (s *Scim) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// ScimAuthProtocolId is an enum, and the following values are allowed.
// 0 - Unknown: The authentication protocol is unknown.
// 1 - NTLM
// 2 - Kerberos
// 3 - Digest
// 4 - OpenID
// 5 - SAML
// 6 - 0
// 7 - PAP
// 8 - CHAP
// 9 - EAP
// 10 - RADIUS
// 11 - BasicAuthentication
// 12 - LDAP
// 99 - Other: The authentication protocol is not mapped. See the <code>auth_protocol</code> attribute, which contains a data source specific value.
type ScimAuthProtocolId = int

// ScimStateId is an enum, and the following values are allowed.
// 0 - Unknown: The provisioning state of the SCIM resource is unknown.
// 1 - Pending: The SCIM resource is Pending activation or creation.
// 2 - Active: The SCIM resource is in an Active state, or otherwise enabled.
// 3 - Failed: The SCIM resource is in a Failed state.
// 4 - Deleted: The SCIM resource is in a Deleted state, or otherwise disabled.
// 99 - Other: The provisioning state of the SCIM resource is not mapped. See the <code>state</code> attribute, which contains a data source specific value.
type ScimStateId = int

// The Script object describes a script or command that can be executed by a shell, script engine, or interpreter. Examples include Bash, JavsScript, PowerShell, Python, VBScript, etc. Note that the term <em>script</em> here denotes not only a script contained within a file but also a script or command typed interactively by a user, supplied on the command line, or provided by some other file-less mechanism.
type Script struct {
	// Present if this script is associated with a file. Not present in the case of a file-less script.
	File *File `json:"file,omitempty" url:"file,omitempty"`
	// An array of the script's cryptographic hashes. Note that these hashes are calculated on the script in its original encoding, and not on the normalized UTF-8 encoding found in the <code>script_content</code> attribute.
	Hashes []*Fingerprint `json:"hashes,omitempty" url:"hashes,omitempty"`
	// Unique identifier for the script or macro, independent of the containing file, used for tracking, auditing, and security analysis.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// This attribute relates a sub-script to a parent script having the matching <code>uid</code> attribute. In the case of PowerShell, sub-script execution can be identified by matching the activity correlation ID of the raw ETW events provided by the OS.
	ParentUid *string `json:"parent_uid,omitempty" url:"parent_uid,omitempty"`
	// The script content, normalized to UTF-8 encoding irrespective of its original encoding. When emitting this attribute, it may be appropriate to truncate large scripts. When consuming this attribute, large scripts should be anticipated.
	ScriptContent *LongString `json:"script_content" url:"script_content"`
	// The script type, normalized to the caption of the <code>type_id</code> value. In the case of 'Other', it is defined by the event source.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The normalized script type ID.
	TypeId ScriptTypeId `json:"type_id" url:"type_id"`
	// Some script engines assign a unique ID to each individual execution of a given script. This attribute captures that unique ID. In the case of PowerShell, the unique ID corresponds to the <code>ScriptBlockId</code> in the raw ETW events provided by the OS.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Script) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Script) UnmarshalJSON(data []byte) error {
	type unmarshaler Script
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Script(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Script) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// ScriptTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The script type is unknown.
// 1 - WindowsCommandPrompt
// 2 - PowerShell
// 3 - Python
// 4 - JavaScript
// 5 - VBScript
// 6 - UnixShell
// 7 - VBA
// 99 - Other: The script type is not mapped. See the <code>type</code> attribute which contains an event source specific value.
type ScriptTypeId = int

// The Service object describes characteristics of a service, <code> e.g. AWS EC2. </code>
type Service struct {
	// The list of labels associated with the service.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The name of the service.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The list of tags; <code>{key:value}</code> pairs associated to the service.
	Tags []*KeyValueObject `json:"tags,omitempty" url:"tags,omitempty"`
	// The unique identifier of the service.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The version of the service.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Service) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Service) UnmarshalJSON(data []byte) error {
	type unmarshaler Service
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Service(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Service) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The Session object describes details about an authenticated session. e.g. Session Creation Time, Session Issuer.
type Session struct {
	// The number of identical sessions spawned from the same source IP, destination IP, application, and content/threat type seen over a period of time.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// The time when the session was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the session was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The unique identifier of the user's credential. For example, AWS Access Key ID.
	CredentialUid *string `json:"credential_uid,omitempty" url:"credential_uid,omitempty"`
	// The reason which triggered the session expiration.
	ExpirationReason *string `json:"expiration_reason,omitempty" url:"expiration_reason,omitempty"`
	// The session expiration time.
	ExpirationTime *Timestamp `json:"expiration_time,omitempty" url:"expiration_time,omitempty"`
	// The session expiration time.
	ExpirationTimeDt *time.Time `json:"expiration_time_dt,omitempty" url:"expiration_time_dt,omitempty"`
	// Indicates whether Multi Factor Authentication was used during authentication.
	IsMfa *bool `json:"is_mfa,omitempty" url:"is_mfa,omitempty"`
	// The indication of whether the session is remote.
	IsRemote *bool `json:"is_remote,omitempty" url:"is_remote,omitempty"`
	// The indication of whether the session is a VPN session.
	IsVpn *bool `json:"is_vpn,omitempty" url:"is_vpn,omitempty"`
	// The identifier of the session issuer.
	Issuer *string `json:"issuer,omitempty" url:"issuer,omitempty"`
	// The Pseudo Terminal associated with the session. Ex: the tty or pts value.
	Terminal *string `json:"terminal,omitempty" url:"terminal,omitempty"`
	// The unique identifier of the session.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The alternate unique identifier of the session. e.g. AWS ARN - <code>arn:aws:sts::123344444444:assumed-role/Admin/example-session</code>.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The universally unique identifier of the session.
	Uuid *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Session) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Session) UnmarshalJSON(data []byte) error {
	type embed Session
	var unmarshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Session(unmarshaler.embed)
	s.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	s.ExpirationTimeDt = unmarshaler.ExpirationTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Session) MarshalJSON() ([]byte, error) {
	type embed Session
	var marshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
	}{
		embed:            embed(*s),
		CreatedTimeDt:    core.NewOptionalDateTime(s.CreatedTimeDt),
		ExpirationTimeDt: core.NewOptionalDateTime(s.ExpirationTimeDt),
	}
	return json.Marshal(marshaler)
}

func (s *Session) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The Sharing object encompasses information about how and with whom a resource was shared.
type Sharing struct {
	// The actor(s) with whom the resource has been shared. Note that with the addition of groups to the Actor object, sharing with a group can be represented by an Actor object with an empty user field and a populated groups field.
	Actors []*Actor `json:"actors,omitempty" url:"actors,omitempty"`
	// True if anonymous access is enabled for sharing.
	Anonymous *bool `json:"anonymous,omitempty" url:"anonymous,omitempty"`
	// True if the recipients have permission to re-share the resource.
	CanReshare *bool `json:"can_reshare,omitempty" url:"can_reshare,omitempty"`
	// Unique ID of a sharing link.
	LinkId *string `json:"link_id,omitempty" url:"link_id,omitempty"`
	// List of permissions granted.
	Permissions []*SharingPermission `json:"permissions,omitempty" url:"permissions,omitempty"`
	// The scope, normalized to the caption of the scope_id value.
	Scope *string `json:"scope,omitempty" url:"scope,omitempty"`
	// The normalized identifier of the sharing scope.
	ScopeId *SharingScopeId `json:"scope_id,omitempty" url:"scope_id,omitempty"`
	// Describes the nature of a sharing action, such as creating a link for others to access a resource.
	SharingAction *string `json:"sharing_action,omitempty" url:"sharing_action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Sharing) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Sharing) UnmarshalJSON(data []byte) error {
	type unmarshaler Sharing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Sharing(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Sharing) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The Sharing Permission type represents the permissions granted to recipients via a Sharing object.
type SharingPermission struct {
	// The sharing permission type, normalized to the caption of the sharing_permission_type_id value.
	SharingPermissionType *string `json:"sharing_permission_type,omitempty" url:"sharing_permission_type,omitempty"`
	// The normalized identifier of the sharing permission type.
	SharingPermissionTypeId SharingPermissionSharingPermissionTypeId `json:"sharing_permission_type_id" url:"sharing_permission_type_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SharingPermission) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SharingPermission) UnmarshalJSON(data []byte) error {
	type unmarshaler SharingPermission
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SharingPermission(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SharingPermission) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// SharingPermissionSharingPermissionTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The sharing permission type is unknown.
// 1 - View: View permission.
// 2 - Modify: Modify permission.
// 99 - Other: The sharing permission type is not mapped.
type SharingPermissionSharingPermissionTypeId = int

// SharingScopeId is an enum, and the following values are allowed.
// 0 - Unknown: The scope is unknown.
// 1 - User: User scope.
// 2 - Group: Group scope.
// 3 - Tenant: Tenant scope.
// 4 - Organization: Organization scope.
// 5 - World: World scope.
// 99 - Other: The scope is not mapped.
type SharingScopeId = int

// The Single Sign-On (SSO) object provides a structure for normalizing SSO attributes, configuration, and/or settings from Identity Providers.
type Sso struct {
	// The authorization protocol as defined by the caption of <code>auth_protocol_id</code>. In the case of <code>Other</code>, it is defined by the event source.
	AuthProtocol *string `json:"auth_protocol,omitempty" url:"auth_protocol,omitempty"`
	// The normalized identifier of the authentication protocol used by the SSO resource.
	AuthProtocolId *SsoAuthProtocolId `json:"auth_protocol_id,omitempty" url:"auth_protocol_id,omitempty"`
	// Digital Signature associated with the SSO resource, e.g., SAML X.509 certificate details.
	Certificate *Certificate `json:"certificate,omitempty" url:"certificate,omitempty"`
	// When the SSO resource was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// When the SSO resource was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The duration (in minutes) for an SSO session, after which re-authentication is required.
	DurationMins *int `json:"duration_mins,omitempty" url:"duration_mins,omitempty"`
	// Duration (in minutes) of allowed inactivity before Single Sign-On (SSO) session expiration.
	IdleTimeout *int `json:"idle_timeout,omitempty" url:"idle_timeout,omitempty"`
	// URL for initiating an SSO login request.
	LoginEndpoint *UrlString `json:"login_endpoint,omitempty" url:"login_endpoint,omitempty"`
	// URL for initiating an SSO logout request, allowing sessions to be terminated across applications.
	LogoutEndpoint *UrlString `json:"logout_endpoint,omitempty" url:"logout_endpoint,omitempty"`
	// URL where metadata about the SSO configuration is available (e.g., for SAML configurations).
	MetadataEndpoint *UrlString `json:"metadata_endpoint,omitempty" url:"metadata_endpoint,omitempty"`
	// The most recent time when the SSO resource was updated.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The most recent time when the SSO resource was updated.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The name of the SSO resource.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The supported protocol for the SSO resource. E.g., <code>SAML</code> or <code>OIDC</code>.
	ProtocolName *string `json:"protocol_name,omitempty" url:"protocol_name,omitempty"`
	// Scopes define the specific permissions or actions that the client is allowed to perform on behalf of the user. Each scope represents a different set of permissions, and the user can selectively grant or deny access to specific scopes during the authorization process.
	Scopes []string `json:"scopes,omitempty" url:"scopes,omitempty"`
	// A unique identifier for a SSO resource.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// Name of the vendor or service provider implementing SSO. E.g., <code>Okta</code>, <code>Auth0</code>, <code>Microsoft</code>.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Sso) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Sso) UnmarshalJSON(data []byte) error {
	type embed Sso
	var unmarshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Sso(unmarshaler.embed)
	s.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	s.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Sso) MarshalJSON() ([]byte, error) {
	type embed Sso
	var marshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:          embed(*s),
		CreatedTimeDt:  core.NewOptionalDateTime(s.CreatedTimeDt),
		ModifiedTimeDt: core.NewOptionalDateTime(s.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (s *Sso) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// SsoAuthProtocolId is an enum, and the following values are allowed.
// 0 - Unknown: The authentication protocol is unknown.
// 1 - NTLM
// 2 - Kerberos
// 3 - Digest
// 4 - OpenID
// 5 - SAML
// 6 - 0
// 7 - PAP
// 8 - CHAP
// 9 - EAP
// 10 - RADIUS
// 11 - BasicAuthentication
// 12 - LDAP
// 99 - Other: The authentication protocol is not mapped. See the <code>auth_protocol</code> attribute, which contains a data source specific value.
type SsoAuthProtocolId = int

// The MITRE Sub-technique object describes the ATT&CK® or ATLAS™ Sub-technique ID and/or name associated to an attack.
type SubTechnique struct {
	// The name of the attack sub-technique. For example: <code>Scanning IP Blocks</code> or <code>User Execution: Unsafe ML Artifacts</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The versioned permalink of the attack sub-technique. For example: <code>https://attack.mitre.org/versions/v14/techniques/T1595/001/</code>.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The unique identifier of the attack sub-technique. For example: <code>T1595.001</code> or <code>AML.T0011.000</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubTechnique) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubTechnique) UnmarshalJSON(data []byte) error {
	type unmarshaler SubTechnique
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubTechnique(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *SubTechnique) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The MITRE Tactic object describes the ATT&CK® or ATLAS™ Tactic ID and/or name that is associated to an attack.
type Tactic struct {
	// The Tactic name that is associated with the attack technique. For example: <code>Reconnaissance</code> or <code>ML Model Access</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The versioned permalink of the Tactic. For example: <code>https://attack.mitre.org/versions/v14/tactics/TA0043/</code>.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The Tactic ID that is associated with the attack technique. For example: <code>TA0043</code>, or <code>AML.TA0000</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Tactic) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tactic) UnmarshalJSON(data []byte) error {
	type unmarshaler Tactic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tactic(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Tactic) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The MITRE Technique object describes the ATT&CK® or ATLAS™ Technique ID and/or name associated to an attack.
type Technique struct {
	// The name of the attack technique. For example: <code>Active Scanning</code> or <code>AI Model Inference API Access</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The versioned permalink of the attack technique. For example: <code>https://attack.mitre.org/versions/v14/techniques/T1595/</code>.
	SrcUrl *UrlString `json:"src_url,omitempty" url:"src_url,omitempty"`
	// The unique identifier of the attack technique. For example: <code>T1595</code> or <code>AML.T0040</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Technique) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Technique) UnmarshalJSON(data []byte) error {
	type unmarshaler Technique
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Technique(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Technique) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Threat actor is responsible for the observed malicious activity.
type ThreatActor struct {
	// The name of the threat actor.
	Name string `json:"name" url:"name"`
	// The classification of the threat actor based on their motivations, capabilities, or affiliations. Common types include nation-state actors, cybercriminal groups, hacktivists, or insider threats.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The normalized datastore resource type identifier.
	TypeId *ThreatActorTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *ThreatActor) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ThreatActor) UnmarshalJSON(data []byte) error {
	type unmarshaler ThreatActor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ThreatActor(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *ThreatActor) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// ThreatActorTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The threat actor type is unknown.
// 1 - state
// 2 - Cybercriminal
// 3 - Hacktivists
// 4 - Insider
// 99 - Other: The threat actor type is not mapped.
type ThreatActorTypeId = int

// The Time Span object represents different time period durations. If a timespan is fractional, i.e. crosses one period, e.g. a week and 3 days, more than one may be populated since each member is of integral type. In that case <code>type_id</code> if present should be set to <code>Other.</code><P>A timespan may also be defined by its time interval boundaries, <code>start_time</code> and <code>end_time</code>.
type Timespan struct {
	// The duration of the time span in milliseconds.
	Duration *int `json:"duration,omitempty" url:"duration,omitempty"`
	// The duration of the time span in days.
	DurationDays *int `json:"duration_days,omitempty" url:"duration_days,omitempty"`
	// The duration of the time span in hours.
	DurationHours *int `json:"duration_hours,omitempty" url:"duration_hours,omitempty"`
	// The duration of the time span in minutes.
	DurationMins *int `json:"duration_mins,omitempty" url:"duration_mins,omitempty"`
	// The duration of the time span in months.
	DurationMonths *int `json:"duration_months,omitempty" url:"duration_months,omitempty"`
	// The duration of the time span in seconds.
	DurationSecs *int `json:"duration_secs,omitempty" url:"duration_secs,omitempty"`
	// The duration of the time span in weeks.
	DurationWeeks *int `json:"duration_weeks,omitempty" url:"duration_weeks,omitempty"`
	// The duration of the time span in years.
	DurationYears *int `json:"duration_years,omitempty" url:"duration_years,omitempty"`
	// The end time or conclusion of the timespan's interval.
	EndTime *Timestamp `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The end time or conclusion of the timespan's interval.
	EndTimeDt *time.Time `json:"end_time_dt,omitempty" url:"end_time_dt,omitempty"`
	// The start time or beginning of the timespan's interval.
	StartTime *Timestamp `json:"start_time,omitempty" url:"start_time,omitempty"`
	// The start time or beginning of the timespan's interval.
	StartTimeDt *time.Time `json:"start_time_dt,omitempty" url:"start_time_dt,omitempty"`
	// The type of time span duration the object represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The normalized identifier for the time span duration type.
	TypeId *TimespanTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Timespan) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Timespan) UnmarshalJSON(data []byte) error {
	type embed Timespan
	var unmarshaler = struct {
		embed
		EndTimeDt   *core.DateTime `json:"end_time_dt,omitempty"`
		StartTimeDt *core.DateTime `json:"start_time_dt,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Timespan(unmarshaler.embed)
	t.EndTimeDt = unmarshaler.EndTimeDt.TimePtr()
	t.StartTimeDt = unmarshaler.StartTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Timespan) MarshalJSON() ([]byte, error) {
	type embed Timespan
	var marshaler = struct {
		embed
		EndTimeDt   *core.DateTime `json:"end_time_dt,omitempty"`
		StartTimeDt *core.DateTime `json:"start_time_dt,omitempty"`
	}{
		embed:       embed(*t),
		EndTimeDt:   core.NewOptionalDateTime(t.EndTimeDt),
		StartTimeDt: core.NewOptionalDateTime(t.StartTimeDt),
	}
	return json.Marshal(marshaler)
}

func (t *Timespan) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// TimespanTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Milliseconds
// 2 - Seconds
// 3 - Minutes
// 4 - Hours
// 5 - Days
// 6 - Weeks
// 7 - Months
// 8 - Years
// 9 - TimeInterval: The <code>start_time</code> and <code>end_time</code> should be set.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type TimespanTypeId = int

// The transformation_info object represents the mapping or transformation used.
type TransformationInfo struct {
	// The transformation language used to transform the data.
	Lang *string `json:"lang,omitempty" url:"lang,omitempty"`
	// The name of the transformation or mapping.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The product or instance used to make the transformation
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// Time of the transformation.
	Time *Timestamp `json:"time,omitempty" url:"time,omitempty"`
	// Time of the transformation.
	TimeDt *time.Time `json:"time_dt,omitempty" url:"time_dt,omitempty"`
	// The unique identifier of the mapping or transformation.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The Uniform Resource Locator String where the mapping or transformation exists.
	UrlString *UrlString `json:"url_string,omitempty" url:"url_string,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TransformationInfo) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransformationInfo) UnmarshalJSON(data []byte) error {
	type embed TransformationInfo
	var unmarshaler = struct {
		embed
		TimeDt *core.DateTime `json:"time_dt,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransformationInfo(unmarshaler.embed)
	t.TimeDt = unmarshaler.TimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TransformationInfo) MarshalJSON() ([]byte, error) {
	type embed TransformationInfo
	var marshaler = struct {
		embed
		TimeDt *core.DateTime `json:"time_dt,omitempty"`
	}{
		embed:  embed(*t),
		TimeDt: core.NewOptionalDateTime(t.TimeDt),
	}
	return json.Marshal(marshaler)
}

func (t *TransformationInfo) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The Uniform Resource Locator (URL) object describes the characteristics of a URL.
type Url struct {
	// The Website categorization names, as defined by <code>category_ids</code> enum values.
	Categories []string `json:"categories,omitempty" url:"categories,omitempty"`
	// The Website categorization identifiers.
	CategoryIds []UrlCategoryIds `json:"category_ids,omitempty" url:"category_ids,omitempty"`
	// The domain portion of the URL. For example: <code>example.com</code> in <code>https://sub.example.com</code>.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The URL host as extracted from the URL. For example: <code>www.example.com</code> from <code>www.example.com/download/trouble</code>.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The URL path as extracted from the URL. For example: <code>/download/trouble</code> from <code>www.example.com/download/trouble</code>.
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// The URL port. For example: <code>80</code>.
	Port *Port `json:"port,omitempty" url:"port,omitempty"`
	// The query portion of the URL. For example: the query portion of the URL <code>http://www.example.com/search?q=bad&sort=date</code> is <code>q=bad&sort=date</code>.
	QueryString *string `json:"query_string,omitempty" url:"query_string,omitempty"`
	// The context in which a resource was retrieved in a web request.
	ResourceType *string `json:"resource_type,omitempty" url:"resource_type,omitempty"`
	// The scheme portion of the URL. For example: <code>http</code>, <code>https</code>, <code>ftp</code>, or <code>sftp</code>.
	Scheme *string `json:"scheme,omitempty" url:"scheme,omitempty"`
	// The subdomain portion of the URL. For example: <code>sub</code> in <code>https://sub.example.com</code> or <code>sub2.sub1</code> in <code>https://sub2.sub1.example.com</code>.
	Subdomain *string `json:"subdomain,omitempty" url:"subdomain,omitempty"`
	// The URL string. See RFC 1738. For example: <code>http://www.example.com/download/trouble.exe</code>. Note: The URL path should not populate the URL string.
	UrlString *UrlString `json:"url_string,omitempty" url:"url_string,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *Url) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Url) UnmarshalJSON(data []byte) error {
	type unmarshaler Url
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Url(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = nil
	return nil
}

func (u *Url) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// UrlCategoryIds is an enum, and the following values are allowed.
// 0 - Unknown: The Domain/URL category is unknown.
// 1 - MatureContent
// 3 - Pornography
// 4 - SexEducation
// 5 - Swimsuit
// 6 - Nudity
// 7 - Extreme
// 9 - Questionable*Illegal
// 11 - Gambling
// 14 - Hate_Racism
// 15 - Weapons
// 16 - Abortion
// 17 - Hacking
// 18 - Phishing
// 20 - Entertainment
// 21 - Economy
// 22 - Belief
// 23 - Alcohol
// 24 - Tobacco
// 25 - ControlledSubstances
// 26 - ChildPornography
// 27 - Education
// 29 - CharitableOrganizations
// 30 - Culture
// 31 - FinancialServices
// 32 - Trading
// 33 - Games
// 34 - Legal
// 35 - Military
// 36 - SocialAdvocacy
// 37 - Health
// 38 - Internet
// 40 - Portals
// 43 - Malnets
// 44 - Botnets
// 45 - Careers
// 46 - Media
// 47 - Dating
// 49 - Reference
// 50 - PotentiallyAdult
// 51 - IM_SMS
// 52 - Email
// 53 - Forums
// 54 - Religion
// 55 - SocialNetworking
// 56 - Sharing
// 57 - RemoteAccessTools
// 58 - Shopping
// 59 - Auctions
// 60 - RealEstate
// 61 - DailyLiving
// 63 - PersonalSites
// 64 - Dining_Food
// 65 - Recreation
// 66 - Travel
// 67 - Vehicles
// 68 - Jokes
// 71 - SoftwareDownloads
// 83 - to_Peer_P2P*
// 84 - VideoClips
// 85 - BusinessApplications
// 86 - ProxyAvoidance
// 87 - ForKids
// 88 - Analytics
// 89 - WebHosting
// 90 - Uncategorized
// 92 - Suspicious
// 93 - SexualExpression
// 95 - Translation
// 96 - Viewable_Infrastructure
// 97 - ContentServers
// 98 - Placeholders
// 99 - Other: The Domain/URL category is not mapped. See the <code>categories</code> attribute, which contains a data source specific value.
// 101 - Spam
// 102 - PotentiallyUnwantedSoftware
// 103 - DynamicDNSHost
// 106 - Card_Invitations
// 107 - Informational
// 108 - InformationSecurity
// 109 - InternetConnectedDevices
// 110 - InternetTelephony
// 111 - OnlineMeetings
// 112 - MediaSharing
// 113 - AudioStreams
// 114 - VideoStreams
// 118 - CopyrightConcerns
// 121 - Marijuana
type UrlCategoryIds = int

// The User object describes the characteristics of a user/person or a security principal.
type User struct {
	// The user's account or the account associated with the user.
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// The unique identifier of the user's credential. For example, AWS Access Key ID.
	CredentialUid *string `json:"credential_uid,omitempty" url:"credential_uid,omitempty"`
	// The display name of the user, as reported by the product.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The domain where the user is defined. For example: the LDAP or Active Directory domain.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The user's primary email address.
	EmailAddr *EmailAddress `json:"email_addr,omitempty" url:"email_addr,omitempty"`
	// The user's forwarding email address.
	ForwardAddr *EmailAddress `json:"forward_addr,omitempty" url:"forward_addr,omitempty"`
	// The full name of the user, as reported by the product.
	FullName *string `json:"full_name,omitempty" url:"full_name,omitempty"`
	// The administrative groups to which the user belongs.
	Groups []*Group `json:"groups,omitempty" url:"groups,omitempty"`
	// The user has a multi-factor or secondary-factor device assigned.
	HasMfa *bool `json:"has_mfa,omitempty" url:"has_mfa,omitempty"`
	// The additional LDAP attributes that describe a person.
	LdapPerson *LdapPerson `json:"ldap_person,omitempty" url:"ldap_person,omitempty"`
	// The multi-factor authentication status, normalized to the caption of the mfa_status_id value. In the case of 'Other', it is defined by the data source.
	MfaStatus *string `json:"mfa_status,omitempty" url:"mfa_status,omitempty"`
	// The normalized identifier of the user's multi-factor authentication status.
	MfaStatusId *UserMfaStatusId `json:"mfa_status_id,omitempty" url:"mfa_status_id,omitempty"`
	// The username. For example, <code>janedoe1</code>.
	Name *UserName `json:"name,omitempty" url:"name,omitempty"`
	// Organization and org unit related to the user.
	Org *Organization `json:"org,omitempty" url:"org,omitempty"`
	// The telephone number of the user.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The user's privileges.
	Privileges []string `json:"privileges,omitempty" url:"privileges,omitempty"`
	// Details about the programmatic credential (API keys, access tokens, certificates, etc) associated to the user.
	ProgrammaticCredentials []*ProgrammaticCredential `json:"programmatic_credentials,omitempty" url:"programmatic_credentials,omitempty"`
	// The risk level, normalized to the caption of the risk_level_id value.
	RiskLevel *string `json:"risk_level,omitempty" url:"risk_level,omitempty"`
	// The normalized risk level id.
	RiskLevelId *UserRiskLevelId `json:"risk_level_id,omitempty" url:"risk_level_id,omitempty"`
	// The risk score as reported by the event source.
	RiskScore *int `json:"risk_score,omitempty" url:"risk_score,omitempty"`
	// The type of the user. For example, System, AWS IAM User, etc.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The account type identifier.
	TypeId *UserTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique user identifier. For example, the Windows user SID, ActiveDirectory DN or AWS user ARN.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The alternate user identifier. For example, the Active Directory user GUID or AWS user Principal ID.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The user status, normalized to the caption of the user_status_id value. In the case of 'Other', it is defined by the data source.
	UserStatus *string `json:"user_status,omitempty" url:"user_status,omitempty"`
	// The normalized identifier of the user's status.
	UserStatusId *UserUserStatusId `json:"user_status_id,omitempty" url:"user_status_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = nil
	return nil
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// UserMfaStatusId is an enum, and the following values are allowed.
// 0 - Unknown: The status is unknown.
// 1 - Enabled: Multi-factor authentication is enabled for this user.
// 2 - NotEnabled: TMulti-factor authentication is off for this user.
// 3 - Enforced: Multi-factor authentication is enabled and there is a policy that requires it for this user.
// 99 - Other: The event status is not mapped. See the <code>user_status</code> attribute, which contains a data source specific value.
type UserMfaStatusId = int

// UserRiskLevelId is an enum, and the following values are allowed.
// 0 - Info
// 1 - Low
// 2 - Medium
// 3 - High
// 4 - Critical
// 99 - Other: The risk level is not mapped. See the <code>risk_level</code> attribute, which contains a data source specific value.
type UserRiskLevelId = int

// UserTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - User: Regular user account.
// 2 - Admin: Admin/root user account.
// 3 - System: System account. For example, Windows computer accounts with a trailing dollar sign ($).
// 4 - Service: Service account. For example, Windows service account.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
type UserTypeId = int

// UserUserStatusId is an enum, and the following values are allowed.
// 0 - Unknown: The status is unknown.
// 1 - Active: The user is active.
// 2 - Pending: The user is not active, pending either user or admin action.
// 3 - Locked: The user account is locked requiring either time or intervention to unlock.
// 4 - Suspended: The user account is suspended.
// 5 - Deprovisioned: The user account has been deprovisioned and is pending removal.
// 99 - Other: The event status is not mapped. See the <code>user_status</code> attribute, which contains a data source specific value.
type UserUserStatusId = int

// The vulnerability is an unintended characteristic of a computing component or system configuration that multiplies the risk of an adverse event or a loss occurring either due to accidental exposure, deliberate attack, or conflict with new system components.
type Vulnerability struct {
	// Detail about the security advisory, that is used to publicly disclose cybersecurity vulnerabilities by a vendor.
	Advisory *Advisory `json:"advisory,omitempty" url:"advisory,omitempty"`
	// List of Affected Code objects that describe details about code blocks identified as vulnerable.
	AffectedCode []*AffectedCode `json:"affected_code,omitempty" url:"affected_code,omitempty"`
	// List of software packages identified as affected by a vulnerability/vulnerabilities.
	AffectedPackages []*AffectedPackage `json:"affected_packages,omitempty" url:"affected_packages,omitempty"`
	// The category of a vulnerability or weakness, as reported by the source tool, such as <code>Container Security</code> or <code>Open Source Security</code>.
	Category *string `json:"category,omitempty" url:"category,omitempty"`
	// Describes the Common Vulnerabilities and Exposures <a target='_blank' href='https://cve.mitre.org/'>(CVE)</a> details related to the vulnerability.
	Cve *Cve `json:"cve,omitempty" url:"cve,omitempty"`
	// Describes the Common Weakness Enumeration <a target='_blank' href='https://cwe.mitre.org/'>(CWE)</a> details related to the vulnerability.
	Cwe *Cwe `json:"cwe,omitempty" url:"cwe,omitempty"`
	// Information about the chain of dependencies related to the issue as reported by an Application Security or Vulnerability Management tool. E.g., <code>serverless-offline -> @serverless/utils -> memoizee -> es5-ext</code>.
	DependencyChain *string `json:"dependency_chain,omitempty" url:"dependency_chain,omitempty"`
	// The description of the vulnerability.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The time when the exploit was most recently observed.
	ExploitLastSeenTime *Timestamp `json:"exploit_last_seen_time,omitempty" url:"exploit_last_seen_time,omitempty"`
	// The time when the exploit was most recently observed.
	ExploitLastSeenTimeDt *time.Time `json:"exploit_last_seen_time_dt,omitempty" url:"exploit_last_seen_time_dt,omitempty"`
	// The URL of the exploit code or Proof-of-Concept (PoC).
	ExploitRefUrl *UrlString `json:"exploit_ref_url,omitempty" url:"exploit_ref_url,omitempty"`
	// The requirement description related to any constraints around exploit execution.
	ExploitRequirement *string `json:"exploit_requirement,omitempty" url:"exploit_requirement,omitempty"`
	// The categorization or type of Exploit. E.g., <code>Network</code> or <code>Physical</code>.
	ExploitType *string `json:"exploit_type,omitempty" url:"exploit_type,omitempty"`
	// The time when the vulnerability was first observed.
	FirstSeenTime *Timestamp `json:"first_seen_time,omitempty" url:"first_seen_time,omitempty"`
	// The time when the vulnerability was first observed.
	FirstSeenTimeDt *time.Time `json:"first_seen_time_dt,omitempty" url:"first_seen_time_dt,omitempty"`
	// Indicates if a fix is available for the reported vulnerability.
	FixAvailable *bool `json:"fix_available,omitempty" url:"fix_available,omitempty"`
	// The fix coverage, normalized to the caption of the <code>fix_coverage_id</code> value.
	FixCoverage *string `json:"fix_coverage,omitempty" url:"fix_coverage,omitempty"`
	// The normalized identifier for fix coverage, applicable to this vulnerability. Typically useful, when there are multiple affected packages but only a subset have available fixes.
	FixCoverageId *VulnerabilityFixCoverageId `json:"fix_coverage_id,omitempty" url:"fix_coverage_id,omitempty"`
	// Indicates if an exploit or a PoC (proof-of-concept) is available for the reported vulnerability.
	IsExploitAvailable *bool `json:"is_exploit_available,omitempty" url:"is_exploit_available,omitempty"`
	// Indicates if a fix is available for the reported vulnerability.
	IsFixAvailable *bool `json:"is_fix_available,omitempty" url:"is_fix_available,omitempty"`
	// A list of KB articles or patches related to an endpoint. A KB Article contains metadata that describes the patch or an update.
	KbArticleList []*KbArticle `json:"kb_article_list,omitempty" url:"kb_article_list,omitempty"`
	// The KB article/s related to the entity. A KB Article contains metadata that describes the patch or an update.
	KbArticles []string `json:"kb_articles,omitempty" url:"kb_articles,omitempty"`
	// The time when the vulnerability was most recently observed.
	LastSeenTime *Timestamp `json:"last_seen_time,omitempty" url:"last_seen_time,omitempty"`
	// The time when the vulnerability was most recently observed.
	LastSeenTimeDt *time.Time `json:"last_seen_time_dt,omitempty" url:"last_seen_time_dt,omitempty"`
	// List of vulnerable packages as identified by the security product
	Packages []*Package `json:"packages,omitempty" url:"packages,omitempty"`
	// A list of reference URLs with additional information about the vulnerability.
	References []string `json:"references,omitempty" url:"references,omitempty"`
	// List of vulnerability IDs (e.g. CVE ID) that are related to this vulnerability.
	RelatedVulnerabilities []string `json:"related_vulnerabilities,omitempty" url:"related_vulnerabilities,omitempty"`
	// The remediation recommendations on how to mitigate the identified vulnerability.
	Remediation *Remediation `json:"remediation,omitempty" url:"remediation,omitempty"`
	// The vendor assigned severity of the vulnerability.
	Severity *string `json:"severity,omitempty" url:"severity,omitempty"`
	// A title or a brief phrase summarizing the discovered vulnerability.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// The name of the vendor that identified the vulnerability.
	VendorName *string `json:"vendor_name,omitempty" url:"vendor_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *Vulnerability) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *Vulnerability) UnmarshalJSON(data []byte) error {
	type embed Vulnerability
	var unmarshaler = struct {
		embed
		ExploitLastSeenTimeDt *core.DateTime `json:"exploit_last_seen_time_dt,omitempty"`
		FirstSeenTimeDt       *core.DateTime `json:"first_seen_time_dt,omitempty"`
		LastSeenTimeDt        *core.DateTime `json:"last_seen_time_dt,omitempty"`
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = Vulnerability(unmarshaler.embed)
	v.ExploitLastSeenTimeDt = unmarshaler.ExploitLastSeenTimeDt.TimePtr()
	v.FirstSeenTimeDt = unmarshaler.FirstSeenTimeDt.TimePtr()
	v.LastSeenTimeDt = unmarshaler.LastSeenTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = nil
	return nil
}

func (v *Vulnerability) MarshalJSON() ([]byte, error) {
	type embed Vulnerability
	var marshaler = struct {
		embed
		ExploitLastSeenTimeDt *core.DateTime `json:"exploit_last_seen_time_dt,omitempty"`
		FirstSeenTimeDt       *core.DateTime `json:"first_seen_time_dt,omitempty"`
		LastSeenTimeDt        *core.DateTime `json:"last_seen_time_dt,omitempty"`
	}{
		embed:                 embed(*v),
		ExploitLastSeenTimeDt: core.NewOptionalDateTime(v.ExploitLastSeenTimeDt),
		FirstSeenTimeDt:       core.NewOptionalDateTime(v.FirstSeenTimeDt),
		LastSeenTimeDt:        core.NewOptionalDateTime(v.LastSeenTimeDt),
	}
	return json.Marshal(marshaler)
}

func (v *Vulnerability) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// VulnerabilityFixCoverageId is an enum, and the following values are allowed.
// 0 - Unknown: The fix coverage is unknown.
// 1 - Complete: All affected packages and components have available fixes or patches to remediate the vulnerability.
// 2 - Partial: Only some of the affected packages and components have available fixes or patches, while others remain vulnerable.
// 3 - None: No fixes or patches are currently available for any of the affected packages and components.
// 99 - Other: The fix coverage is not mapped. See the <code>fix_coverage</code> attribute, which contains a data source specific value.
type VulnerabilityFixCoverageId = int

// The resources of a WHOIS record for a given domain. This can include domain names, IP address blocks, autonomous system information, and/or contact and registration information for a domain.
type Whois struct {
	// The autonomous system information associated with a domain.
	AutonomousSystem *AutonomousSystem `json:"autonomous_system,omitempty" url:"autonomous_system,omitempty"`
	// When the domain was registered or WHOIS entry was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// When the domain was registered or WHOIS entry was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The normalized value of dnssec_status_id.
	DnssecStatus *string `json:"dnssec_status,omitempty" url:"dnssec_status,omitempty"`
	// Describes the normalized status of DNS Security Extensions (DNSSEC) for a domain.
	DnssecStatusId *WhoisDnssecStatusId `json:"dnssec_status_id,omitempty" url:"dnssec_status_id,omitempty"`
	// The domain name corresponding to the WHOIS record.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// An array of <code>Domain Contact</code> objects.
	DomainContacts []*DomainContact `json:"domain_contacts,omitempty" url:"domain_contacts,omitempty"`
	// The email address for the registrar's abuse contact
	EmailAddr *EmailAddress `json:"email_addr,omitempty" url:"email_addr,omitempty"`
	// The name of the Internet Service Provider (ISP).
	Isp *string `json:"isp,omitempty" url:"isp,omitempty"`
	// The organization name of the Internet Service Provider (ISP). This represents the parent organization or company that owns/operates the ISP. For example, Comcast Corporation would be the ISP org for Xfinity internet service. This attribute helps identify the ultimate provider when ISPs operate under different brand names.
	IspOrg *string `json:"isp_org,omitempty" url:"isp_org,omitempty"`
	// When the WHOIS record was last updated or seen at.
	LastSeenTime *Timestamp `json:"last_seen_time,omitempty" url:"last_seen_time,omitempty"`
	// When the WHOIS record was last updated or seen at.
	LastSeenTimeDt *time.Time `json:"last_seen_time_dt,omitempty" url:"last_seen_time_dt,omitempty"`
	// A collection of name servers related to a domain registration or other record.
	NameServers []string `json:"name_servers,omitempty" url:"name_servers,omitempty"`
	// The phone number for the registrar's abuse contact
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The domain registrar.
	Registrar *string `json:"registrar,omitempty" url:"registrar,omitempty"`
	// The status of a domain and its ability to be transferred, e.g., <code>clientTransferProhibited</code>.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// An array of subdomain strings. Can be used to collect several subdomains such as those from Domain Generation Algorithms (DGAs).
	Subdomains []string `json:"subdomains,omitempty" url:"subdomains,omitempty"`
	// The IP address block (CIDR) associated with a domain.
	Subnet *Subnet `json:"subnet,omitempty" url:"subnet,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *Whois) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *Whois) UnmarshalJSON(data []byte) error {
	type embed Whois
	var unmarshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		LastSeenTimeDt *core.DateTime `json:"last_seen_time_dt,omitempty"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = Whois(unmarshaler.embed)
	w.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	w.LastSeenTimeDt = unmarshaler.LastSeenTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *Whois) MarshalJSON() ([]byte, error) {
	type embed Whois
	var marshaler = struct {
		embed
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		LastSeenTimeDt *core.DateTime `json:"last_seen_time_dt,omitempty"`
	}{
		embed:          embed(*w),
		CreatedTimeDt:  core.NewOptionalDateTime(w.CreatedTimeDt),
		LastSeenTimeDt: core.NewOptionalDateTime(w.LastSeenTimeDt),
	}
	return json.Marshal(marshaler)
}

func (w *Whois) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// WhoisDnssecStatusId is an enum, and the following values are allowed.
// 0 - Unknown: The disposition is unknown.
// 1 - Signed: The related domain enables the signing of DNS records using DNSSEC.
// 2 - Unsigned: The related domain does not enable the signing of DNS records using DNSSEC.
// 99 - Other: The DNSSEC status is not mapped. See the <code>dnssec_status</code> attribute, which contains a data source specific value.
type WhoisDnssecStatusId = int
