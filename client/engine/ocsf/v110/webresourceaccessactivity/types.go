// This file was auto-generated by Fern from our API Definition.

package webresourceaccessactivity

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/synqly/go-sdk/client/engine/core"
	time "time"
)

// Email address. For example: <code>john_doe@example.com</code>.
// Deprecated: Use OCSF v130 package instead.
type EmailAddress = string

// File name. For example: <code>text-file.txt</code>.
// Deprecated: Use OCSF v130 package instead.
type FileName = string

// Hash. A unique value that corresponds to the content of the file, image, ja3_hash or hassh found in the schema. For example MD5: <code>3172ac7e2b55cbb81f04a6e65855a628</code>.
// Deprecated: Use OCSF v130 package instead.
type Hash = string

// Unique name assigned to a device connected to a computer network. A domain name in general is an Internet address that can be resolved through the Domain Name System (DNS). For example: <code>r2-d2.example.com</code>.
// Deprecated: Use OCSF v130 package instead.
type Hostname = string

// Internet Protocol address (IP address), in either IPv4 or IPv6 format. For example, <code>192.168.200.24</code> or <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>.
// Deprecated: Use OCSF v130 package instead.
type IpAddress = string

// Media Access Control (MAC) address. For example: <code>18:36:F3:98:4F:9A</code>.
// Deprecated: Use OCSF v130 package instead.
type MacAddress = string

// The TCP/UDP port number. For example: <code>80</code> or <code>22</code>.
// Deprecated: Use OCSF v130 package instead.
type Port = int

// Process name. For example: <code>Notepad</code>.
// Deprecated: Use OCSF v130 package instead.
type ProcessName = string

// Resource unique identifier. For example, S3 Bucket name or EC2 Instance ID.
// Deprecated: Use OCSF v130 package instead.
type ResourceUid = string

// The subnet represented in a CIDR notation, using the format network_address/prefix_length. The network_address can be in either IPv4 or IPv6 format. The prefix length indicates the number of bits used for the network portion, and the remaining bits are available for host addresses within that subnet. <div>For example:<ul><li>192.168.1.0/24</li><li>2001:0db8:85a3:0000::/64</li></ul></div>
// Deprecated: Use OCSF v130 package instead.
type Subnet = string

// The timestamp format is the number of milliseconds since the Epoch 01/01/1970 00:00:00 UTC. For example <code>1618524549901</code>.
// Deprecated: Use OCSF v130 package instead.
type Timestamp = int

// Uniform Resource Locator (URL) string. For example: <code>http://www.example.com/download/trouble.exe</code>.
// Deprecated: Use OCSF v130 package instead.
type UrlString = string

// User name. For example: <code>john_doe</code>.
// Deprecated: Use OCSF v130 package instead.
type UserName = string

// ActivityId is an enum, and the following values are allowed.
// 0 - Unknown: The event activity is unknown.
// 1 - AccessGrant: The incoming request has permission to the web resource.
// 2 - AccessDeny: The incoming request does not have permission to the web resource.
// 3 - AccessRevoke: The incoming request's access has been revoked due to security policy enforcements.
// 4 - AccessError: An error occurred during processing the request.
// 99 - Other: The event activity is not mapped. See the <code>activity_name</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type ActivityId = int

// CategoryUid is an enum, and the following values are allowed.
// 6 - ApplicationActivity: Application Activity events report detailed information about the behavior of applications and services.
// Deprecated: Use OCSF v130 package instead.
type CategoryUid = int

// ClassUid is an enum, and the following values are allowed.
// 6004 - WebResourceAccessActivity: Web Resource Access Activity events describe successful/failed attempts to access a web resource over HTTP.
// Deprecated: Use OCSF v130 package instead.
type ClassUid = int

// SeverityId is an enum, and the following values are allowed.
// 0 - Unknown: The event/finding severity is unknown.
// 1 - Informational: Informational message. No action required.
// 2 - Low: The user decides if action is needed.
// 3 - Medium: Action is required but the situation is not serious at this time.
// 4 - High: Action is required immediately.
// 5 - Critical: Action is required immediately and the scope is broad.
// 6 - Fatal: An error occurred but it is too late to take remedial action.
// 99 - Other: The event/finding severity is not mapped. See the <code>severity</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type SeverityId = int

// StatusId is an enum, and the following values are allowed.
// 0 - Unknown: The status is unknown.
// 1 - Success
// 2 - Failure
// 99 - Other: The event status is not mapped. See the <code>status</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type StatusId = int

// TypeUid is an enum, and the following values are allowed.
// 600400 - Unknown
// 600401 - AccessGrant: The incoming request has permission to the web resource.
// 600402 - AccessDeny: The incoming request does not have permission to the web resource.
// 600403 - AccessRevoke: The incoming request's access has been revoked due to security policy enforcements.
// 600404 - AccessError: An error occurred during processing the request.
// 600499 - Other
// Deprecated: Use OCSF v130 package instead.
type TypeUid = int

// Web Resource Access Activity events describe successful/failed attempts to access a web resource over HTTP.
// Deprecated: Use OCSF v130 package instead.
type WebResourceAccessActivity struct {
	// The normalized identifier of the activity that triggered the event.
	ActivityId ActivityId `json:"activity_id" url:"activity_id"`
	// The event activity name, as defined by the activity_id.
	ActivityName *string `json:"activity_name,omitempty" url:"activity_name,omitempty"`
	// The actor object describes details about the user/role/process that was the source of the activity.
	Actor *Actor `json:"actor,omitempty" url:"actor,omitempty"`
	// Describes details about a typical API (Application Programming Interface) call.
	Api *Api `json:"api,omitempty" url:"api,omitempty"`
	// The event category name, as defined by category_uid value: <code>Application Activity</code>.
	CategoryName *string `json:"category_name,omitempty" url:"category_name,omitempty"`
	// The category unique identifier of the event.
	CategoryUid CategoryUid `json:"category_uid" url:"category_uid"`
	// The unique identifier of a class. A Class describes the attributes available in an event.
	ClassUid ClassUid `json:"class_uid" url:"class_uid"`
	// Describes details about the Cloud environment where the event was originally created or logged.
	Cloud *Cloud `json:"cloud,omitempty" url:"cloud,omitempty"`
	// The number of times that events in the same logical group occurred during the event <strong>Start Time</strong> to <strong>End Time</strong> period.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// A list of custom fields
	CustomFields *Object `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// An addressable device, computer system or host.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// The event duration or aggregate time, the amount of time the event covers from <code>start_time</code> to <code>end_time</code> in milliseconds.
	Duration *int `json:"duration,omitempty" url:"duration,omitempty"`
	// The end time of a time period, or the time of the most recent event included in the aggregate event.
	EndTime *Timestamp `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The end time of a time period, or the time of the most recent event included in the aggregate event.
	EndTimeDt *time.Time `json:"end_time_dt,omitempty" url:"end_time_dt,omitempty"`
	// The additional information from an external data source, which is associated with the event or a finding. For example add location information for the IP address in the DNS answers:</p><code>[{"name": "answers.ip", "value": "92.24.47.250", "type": "location", "data": {"city": "Socotra", "continent": "Asia", "coordinates": [-25.4153, 17.0743], "country": "YE", "desc": "Yemen"}}]</code>
	Enrichments []*Enrichment `json:"enrichments,omitempty" url:"enrichments,omitempty"`
	// Details about the underlying HTTP request.
	HttpRequest *HttpRequest `json:"http_request" url:"http_request"`
	// Details about the HTTP response, if available.
	HttpResponse *HttpResponse `json:"http_response,omitempty" url:"http_response,omitempty"`
	// The description of the event/finding, as defined by the source.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// The metadata associated with the event or a finding.
	Metadata *Metadata `json:"metadata" url:"metadata"`
	// The observables associated with the event or a finding.
	Observables []*Observable `json:"observables,omitempty" url:"observables,omitempty"`
	// Details about the proxy service, if available.
	Proxy *NetworkProxy `json:"proxy,omitempty" url:"proxy,omitempty"`
	// The connection information from the proxy server to the remote server.
	ProxyConnectionInfo *NetworkConnectionInfo `json:"proxy_connection_info,omitempty" url:"proxy_connection_info,omitempty"`
	// The proxy (server) in a network connection.
	ProxyEndpoint *NetworkProxy `json:"proxy_endpoint,omitempty" url:"proxy_endpoint,omitempty"`
	// The HTTP Request from the proxy server to the remote server.
	ProxyHttpRequest *HttpRequest `json:"proxy_http_request,omitempty" url:"proxy_http_request,omitempty"`
	// The HTTP Response from the remote server to the proxy server.
	ProxyHttpResponse *HttpResponse `json:"proxy_http_response,omitempty" url:"proxy_http_response,omitempty"`
	// The TLS protocol negotiated between the proxy server and the remote server.
	ProxyTls *Tls `json:"proxy_tls,omitempty" url:"proxy_tls,omitempty"`
	// The network traffic refers to the amount of data moving across a network, from proxy to remote server at a given point of time.
	ProxyTraffic *NetworkTraffic `json:"proxy_traffic,omitempty" url:"proxy_traffic,omitempty"`
	// The raw event/finding data as received from the source.
	RawData *string `json:"raw_data,omitempty" url:"raw_data,omitempty"`
	// The event/finding severity, normalized to the caption of the severity_id value. In the case of 'Other', it is defined by the source.
	Severity *string `json:"severity,omitempty" url:"severity,omitempty"`
	// <p>The normalized identifier of the event/finding severity.</p>The normalized severity is a measurement the effort and expense required to manage and resolve an event or incident. Smaller numerical values represent lower impact events, and larger numerical values represent higher impact events.
	SeverityId SeverityId `json:"severity_id" url:"severity_id"`
	// Details about the source endpoint of the request.
	SrcEndpoint *NetworkEndpoint `json:"src_endpoint,omitempty" url:"src_endpoint,omitempty"`
	// The start time of a time period, or the time of the least recent event included in the aggregate event.
	StartTime *Timestamp `json:"start_time,omitempty" url:"start_time,omitempty"`
	// The start time of a time period, or the time of the least recent event included in the aggregate event.
	StartTimeDt *time.Time `json:"start_time_dt,omitempty" url:"start_time_dt,omitempty"`
	// The event status, normalized to the caption of the status_id value. In the case of 'Other', it is defined by the event source.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The event status code, as reported by the event source.<br /><br />For example, in a Windows Failed Authentication event, this would be the value of 'Failure Code', e.g. 0x18.
	StatusCode *string `json:"status_code,omitempty" url:"status_code,omitempty"`
	// The status details contains additional information about the event/finding outcome.
	StatusDetail *string `json:"status_detail,omitempty" url:"status_detail,omitempty"`
	// The normalized identifier of the event status.
	StatusId *StatusId `json:"status_id,omitempty" url:"status_id,omitempty"`
	// The normalized event occurrence time or the finding creation time.
	Time Timestamp `json:"time" url:"time"`
	// The normalized event occurrence time or the finding creation time.
	TimeDt *time.Time `json:"time_dt,omitempty" url:"time_dt,omitempty"`
	// The number of minutes that the reported event <code>time</code> is ahead or behind UTC, in the range -1,080 to +1,080.
	TimezoneOffset *int `json:"timezone_offset,omitempty" url:"timezone_offset,omitempty"`
	// The Transport Layer Security (TLS) attributes, if available.
	Tls *Tls `json:"tls,omitempty" url:"tls,omitempty"`
	// The event/finding type name, as defined by the type_uid.
	TypeName *string `json:"type_name,omitempty" url:"type_name,omitempty"`
	// The event/finding type ID. It identifies the event's semantics and structure. The value is calculated by the logging system as: <code>class_uid \* 100 + activity_id</code>.
	TypeUid TypeUid `json:"type_uid" url:"type_uid"`
	// The attributes that are not mapped to the event schema. The names and values of those attributes are specific to the event source.
	Unmapped *Object `json:"unmapped,omitempty" url:"unmapped,omitempty"`
	// Details about the resource that is the target of the activity.
	WebResources []*WebResource `json:"web_resources" url:"web_resources"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebResourceAccessActivity) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebResourceAccessActivity) UnmarshalJSON(data []byte) error {
	type embed WebResourceAccessActivity
	var unmarshaler = struct {
		embed
		EndTimeDt   *core.DateTime `json:"end_time_dt,omitempty"`
		StartTimeDt *core.DateTime `json:"start_time_dt,omitempty"`
		TimeDt      *core.DateTime `json:"time_dt,omitempty"`
	}{
		embed: embed(*w),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*w = WebResourceAccessActivity(unmarshaler.embed)
	w.EndTimeDt = unmarshaler.EndTimeDt.TimePtr()
	w.StartTimeDt = unmarshaler.StartTimeDt.TimePtr()
	w.TimeDt = unmarshaler.TimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *WebResourceAccessActivity) MarshalJSON() ([]byte, error) {
	type embed WebResourceAccessActivity
	var marshaler = struct {
		embed
		EndTimeDt   *core.DateTime `json:"end_time_dt,omitempty"`
		StartTimeDt *core.DateTime `json:"start_time_dt,omitempty"`
		TimeDt      *core.DateTime `json:"time_dt,omitempty"`
	}{
		embed:       embed(*w),
		EndTimeDt:   core.NewOptionalDateTime(w.EndTimeDt),
		StartTimeDt: core.NewOptionalDateTime(w.StartTimeDt),
		TimeDt:      core.NewOptionalDateTime(w.TimeDt),
	}
	return json.Marshal(marshaler)
}

func (w *WebResourceAccessActivity) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// The Account object contains details about the account that initiated or performed a specific activity within a system or application.
// Deprecated: Use OCSF v130 package instead.
type Account struct {
	// The name of the account (e.g. GCP Account Name).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The account type, normalized to the caption of 'account_type_id'. In the case of 'Other', it is defined by the event source.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The normalized account type identifier.
	TypeId *AccountTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique identifier of the account (e.g. AWS Account ID).
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Account) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Account) UnmarshalJSON(data []byte) error {
	type unmarshaler Account
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Account(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Account) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// AccountTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The account type is unknown.
// 1 - LDAPAccount
// 2 - WindowsAccount
// 3 - AWSIAMUser
// 4 - AWSIAMRole
// 5 - GCPAccount
// 6 - AzureADAccount
// 7 - MacOSAccount
// 8 - AppleAccount
// 9 - LinuxAccount
// 10 - AWSAccount
// 99 - Other: The account type is not mapped.
// Deprecated: Use OCSF v130 package instead.
type AccountTypeId = int

// The Actor object contains details about the user, role, or process that initiated or performed a specific activity.
// Deprecated: Use OCSF v130 package instead.
type Actor struct {
	// Provides details about an authorization, such as authorization outcome, and any associated policies related to the activity/event.
	Authorizations []*Authorization `json:"authorizations,omitempty" url:"authorizations,omitempty"`
	// This object describes details about the Identity Provider used.
	Idp *Idp `json:"idp,omitempty" url:"idp,omitempty"`
	// The name of the service that invoked the activity as described in the event.
	InvokedBy *string `json:"invoked_by,omitempty" url:"invoked_by,omitempty"`
	// The process that initiated the activity.
	Process *Process `json:"process,omitempty" url:"process,omitempty"`
	// The user session from which the activity was initiated.
	Session *Session `json:"session,omitempty" url:"session,omitempty"`
	// The user that initiated the activity or the user context from which the activity was initiated.
	User *User `json:"user,omitempty" url:"user,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Actor) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Actor) UnmarshalJSON(data []byte) error {
	type unmarshaler Actor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Actor(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Actor) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The API, or Application Programming Interface, object represents information pertaining to an API request and response.
// Deprecated: Use OCSF v130 package instead.
type Api struct {
	// The information pertaining to the API group.
	Group *Group `json:"group,omitempty" url:"group,omitempty"`
	// Verb/Operation associated with the request
	Operation string `json:"operation" url:"operation"`
	// Details pertaining to the API request.
	Request *Request `json:"request,omitempty" url:"request,omitempty"`
	// Details pertaining to the API response.
	Response *Response `json:"response,omitempty" url:"response,omitempty"`
	// The information pertaining to the API service.
	Service *Service `json:"service,omitempty" url:"service,omitempty"`
	// The version of the API service.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Api) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Api) UnmarshalJSON(data []byte) error {
	type unmarshaler Api
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Api(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Api) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The Authorization Result object provides details about the authorization outcome and associated policies related to activity.
// Deprecated: Use OCSF v130 package instead.
type Authorization struct {
	// Authorization Result/outcome, e.g. allowed, denied.
	Decision *string `json:"decision,omitempty" url:"decision,omitempty"`
	// Details about the Identity/Access management policies that are applicable.
	Policy *Policy `json:"policy,omitempty" url:"policy,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Authorization) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Authorization) UnmarshalJSON(data []byte) error {
	type unmarshaler Authorization
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Authorization(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = nil
	return nil
}

func (a *Authorization) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The Digital Certificate, also known as a Public Key Certificate, object contains information about the ownership and usage of a public key. It serves as a means to establish trust in the authenticity and integrity of the public key and the associated entity. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Certificate/'>d3f:Certificate</a>.
// Deprecated: Use OCSF v130 package instead.
type Certificate struct {
	// The time when the certificate was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the certificate was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The expiration time of the certificate.
	ExpirationTime *Timestamp `json:"expiration_time,omitempty" url:"expiration_time,omitempty"`
	// The expiration time of the certificate.
	ExpirationTimeDt *time.Time `json:"expiration_time_dt,omitempty" url:"expiration_time_dt,omitempty"`
	// The fingerprint list of the certificate.
	Fingerprints []*Fingerprint `json:"fingerprints" url:"fingerprints"`
	// The certificate issuer distinguished name.
	Issuer string `json:"issuer" url:"issuer"`
	// The serial number of the certificate used to create the digital signature.
	SerialNumber string `json:"serial_number" url:"serial_number"`
	// The certificate subject distinguished name.
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The unique identifier of the certificate.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The certificate version.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Certificate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Certificate) UnmarshalJSON(data []byte) error {
	type embed Certificate
	var unmarshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Certificate(unmarshaler.embed)
	c.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	c.ExpirationTimeDt = unmarshaler.ExpirationTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Certificate) MarshalJSON() ([]byte, error) {
	type embed Certificate
	var marshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
	}{
		embed:            embed(*c),
		CreatedTimeDt:    core.NewOptionalDateTime(c.CreatedTimeDt),
		ExpirationTimeDt: core.NewOptionalDateTime(c.ExpirationTimeDt),
	}
	return json.Marshal(marshaler)
}

func (c *Certificate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Cloud object contains information about a cloud account such as AWS Account ID, regions, etc.
// Deprecated: Use OCSF v130 package instead.
type Cloud struct {
	// The account object describes details about the account that was the source or target of the activity.
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// Organization and org unit relevant to the event or object.
	Org *Organization `json:"org,omitempty" url:"org,omitempty"`
	// The unique identifier of a Cloud project.
	ProjectUid *string `json:"project_uid,omitempty" url:"project_uid,omitempty"`
	// The unique name of the Cloud services provider, such as AWS, MS Azure, GCP, etc.
	Provider string `json:"provider" url:"provider"`
	// The name of the cloud region, as defined by the cloud provider.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// The availability zone in the cloud region, as defined by the cloud provider.
	Zone *string `json:"zone,omitempty" url:"zone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Cloud) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Cloud) UnmarshalJSON(data []byte) error {
	type unmarshaler Cloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Cloud(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Cloud) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Container object describes an instance of a specific container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
// Deprecated: Use OCSF v130 package instead.
type Container struct {
	// Commit hash of image created for docker or the SHA256 hash of the container. For example: <code>13550340a8681c84c861aac2e5b440161c2b33a3e4f302ac680ca5b686de48de</code>.
	Hash *Fingerprint `json:"hash,omitempty" url:"hash,omitempty"`
	// The container image used as a template to run the container.
	Image *Image `json:"image,omitempty" url:"image,omitempty"`
	// The container name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The network driver used by the container. For example, bridge, overlay, host, none, etc.
	NetworkDriver *string `json:"network_driver,omitempty" url:"network_driver,omitempty"`
	// The orchestrator managing the container, such as ECS, EKS, K8s, or OpenShift.
	Orchestrator *string `json:"orchestrator,omitempty" url:"orchestrator,omitempty"`
	// The unique identifier of the pod (or equivalent) that the container is executing on.
	PodUuid *string `json:"pod_uuid,omitempty" url:"pod_uuid,omitempty"`
	// The backend running the container, such as containerd or cri-o.
	Runtime *string `json:"runtime,omitempty" url:"runtime,omitempty"`
	// The size of the container image.
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// The tag used by the container. It can indicate version, format, OS.
	Tag *string `json:"tag,omitempty" url:"tag,omitempty"`
	// The full container unique identifier for this instantiation of the container. For example: <code>ac2ea168264a08f9aaca0dfc82ff3551418dfd22d02b713142a6843caa2f61bf</code>.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Container) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Container) UnmarshalJSON(data []byte) error {
	type unmarshaler Container
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Container(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = nil
	return nil
}

func (c *Container) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The Device object represents an addressable computer system or host, which is typically connected to a computer network and participates in the transmission or processing of data within the computer network. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Host/'>d3f:Host</a>.
// Deprecated: Use OCSF v130 package instead.
type Device struct {
	// The unique identifier of the cloud autoscale configuration.
	AutoscaleUid *string `json:"autoscale_uid,omitempty" url:"autoscale_uid,omitempty"`
	// The information describing an instance of a container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
	Container *Container `json:"container,omitempty" url:"container,omitempty"`
	// The time when the device was known to have been created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the device was known to have been created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The description of the device, ordinarily as reported by the operating system.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The network domain where the device resides. For example: <code>work.example.com</code>.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The initial discovery time of the device.
	FirstSeenTime *Timestamp `json:"first_seen_time,omitempty" url:"first_seen_time,omitempty"`
	// The initial discovery time of the device.
	FirstSeenTimeDt *time.Time `json:"first_seen_time_dt,omitempty" url:"first_seen_time_dt,omitempty"`
	// The group names to which the device belongs. For example: <code>["Windows Laptops", "Engineering"]</code>.
	Groups []*Group `json:"groups,omitempty" url:"groups,omitempty"`
	// The device hostname.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The endpoint hardware information.
	HwInfo *DeviceHwInfo `json:"hw_info,omitempty" url:"hw_info,omitempty"`
	// The name of the hypervisor running on the device. For example, <code>Xen</code>, <code>VMware</code>, <code>Hyper-V</code>, <code>VirtualBox</code>, etc.
	Hypervisor *string `json:"hypervisor,omitempty" url:"hypervisor,omitempty"`
	// The image used as a template to run the virtual machine.
	Image *Image `json:"image,omitempty" url:"image,omitempty"`
	// The International Mobile Station Equipment Identifier that is associated with the device.
	Imei *string `json:"imei,omitempty" url:"imei,omitempty"`
	// The unique identifier of a VM instance.
	InstanceUid *string `json:"instance_uid,omitempty" url:"instance_uid,omitempty"`
	// The name of the network interface (e.g. eth2).
	InterfaceName *string `json:"interface_name,omitempty" url:"interface_name,omitempty"`
	// The unique identifier of the network interface.
	InterfaceUid *string `json:"interface_uid,omitempty" url:"interface_uid,omitempty"`
	// The device IP address, in either IPv4 or IPv6 format.
	Ip *IpAddress `json:"ip,omitempty" url:"ip,omitempty"`
	// A list of IP addresses available on the device
	IpAddresses []string `json:"ip_addresses,omitempty" url:"ip_addresses,omitempty"`
	// The event occurred on a compliant device.
	IsCompliant *bool `json:"is_compliant,omitempty" url:"is_compliant,omitempty"`
	// The event occurred on a managed device.
	IsManaged *bool `json:"is_managed,omitempty" url:"is_managed,omitempty"`
	// The event occurred on a personal device.
	IsPersonal *bool `json:"is_personal,omitempty" url:"is_personal,omitempty"`
	// The event occurred on a trusted device.
	IsTrusted *bool `json:"is_trusted,omitempty" url:"is_trusted,omitempty"`
	// The most recent discovery time of the device.
	LastSeenTime *Timestamp `json:"last_seen_time,omitempty" url:"last_seen_time,omitempty"`
	// The most recent discovery time of the device.
	LastSeenTimeDt *time.Time `json:"last_seen_time_dt,omitempty" url:"last_seen_time_dt,omitempty"`
	// The geographical location of the device.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The Media Access Control (MAC) address of the endpoint.
	Mac *MacAddress `json:"mac,omitempty" url:"mac,omitempty"`
	// A list of MAC addresses available on the device
	MacAddresses []string `json:"mac_addresses,omitempty" url:"mac_addresses,omitempty"`
	// The time when the device was last known to have been modified.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The time when the device was last known to have been modified.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The alternate device name, ordinarily as assigned by an administrator. <p><b>Note:</b> The <b>Name</b> could be any other string that helps to identify the device, such as a phone number; for example <code>310-555-1234</code>.</p>
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// If running under a process namespace (such as in a container), the process identifier within that process namespace.
	NamespacePid *int `json:"namespace_pid,omitempty" url:"namespace_pid,omitempty"`
	// A list of NetBIOS names available on the device
	NetbiosNames []string `json:"netbios_names,omitempty" url:"netbios_names,omitempty"`
	// The network interfaces that are associated with the device, one for each unique MAC address/IP address/hostname/name combination.<p><b>Note:</b> The first element of the array is the network information that pertains to the event.</p>
	NetworkInterfaces []*NetworkInterface `json:"network_interfaces,omitempty" url:"network_interfaces,omitempty"`
	// The network isolation status of the endpoiint
	NetworkStatus *string `json:"network_status,omitempty" url:"network_status,omitempty"`
	// The network isolation status ID.
	NetworkStatusId *DeviceNetworkStatusId `json:"network_status_id,omitempty" url:"network_status_id,omitempty"`
	// Organization and org unit related to the device.
	Org *Organization `json:"org,omitempty" url:"org,omitempty"`
	// The endpoint operating system.
	Os *Os `json:"os,omitempty" url:"os,omitempty"`
	// The region where the virtual machine is located. For example, an AWS Region.
	Region *string `json:"region,omitempty" url:"region,omitempty"`
	// The risk level, normalized to the caption of the risk_level_id value. In the case of 'Other', it is defined by the event source.
	RiskLevel *string `json:"risk_level,omitempty" url:"risk_level,omitempty"`
	// The normalized risk level id.
	RiskLevelId *DeviceRiskLevelId `json:"risk_level_id,omitempty" url:"risk_level_id,omitempty"`
	// The risk score as reported by the event source.
	RiskScore *int `json:"risk_score,omitempty" url:"risk_score,omitempty"`
	// The subnet mask.
	Subnet *Subnet `json:"subnet,omitempty" url:"subnet,omitempty"`
	// The unique identifier of a virtual subnet.
	SubnetUid *string `json:"subnet_uid,omitempty" url:"subnet_uid,omitempty"`
	// The list of software contained on a device
	SwInfo []*Product `json:"sw_info,omitempty" url:"sw_info,omitempty"`
	// The device type. For example: <code>unknown</code>, <code>server</code>, <code>desktop</code>, <code>laptop</code>, <code>tablet</code>, <code>mobile</code>, <code>virtual</code>, <code>browser</code>, <code>plc</code>, <code>scada</code>, <code>dcs</code>, <code>cnc</code>, <code>scientific</code>, <code>medical</code>, <code>lighting</code>, <code>energy</code>, <code>transportation</code> <code>other</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The device type ID.
	TypeId DeviceTypeId `json:"type_id" url:"type_id"`
	// The unique identifier of the device. For example the Windows TargetSID or AWS EC2 ARN.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An alternate unique identifier of the device if any. For example the ActiveDirectory DN.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The product vendor that created the device.
	Vendor *Organization `json:"vendor,omitempty" url:"vendor,omitempty"`
	// The Virtual LAN identifier.
	VlanUid *string `json:"vlan_uid,omitempty" url:"vlan_uid,omitempty"`
	// The unique identifier of the Virtual Private Cloud (VPC).
	VpcUid *string `json:"vpc_uid,omitempty" url:"vpc_uid,omitempty"`
	// The network zone or LAN segment.
	Zone *string `json:"zone,omitempty" url:"zone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Device) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Device) UnmarshalJSON(data []byte) error {
	type embed Device
	var unmarshaler = struct {
		embed
		CreatedTimeDt   *core.DateTime `json:"created_time_dt,omitempty"`
		FirstSeenTimeDt *core.DateTime `json:"first_seen_time_dt,omitempty"`
		LastSeenTimeDt  *core.DateTime `json:"last_seen_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Device(unmarshaler.embed)
	d.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	d.FirstSeenTimeDt = unmarshaler.FirstSeenTimeDt.TimePtr()
	d.LastSeenTimeDt = unmarshaler.LastSeenTimeDt.TimePtr()
	d.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *Device) MarshalJSON() ([]byte, error) {
	type embed Device
	var marshaler = struct {
		embed
		CreatedTimeDt   *core.DateTime `json:"created_time_dt,omitempty"`
		FirstSeenTimeDt *core.DateTime `json:"first_seen_time_dt,omitempty"`
		LastSeenTimeDt  *core.DateTime `json:"last_seen_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:           embed(*d),
		CreatedTimeDt:   core.NewOptionalDateTime(d.CreatedTimeDt),
		FirstSeenTimeDt: core.NewOptionalDateTime(d.FirstSeenTimeDt),
		LastSeenTimeDt:  core.NewOptionalDateTime(d.LastSeenTimeDt),
		ModifiedTimeDt:  core.NewOptionalDateTime(d.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (d *Device) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The Device Hardware Information object contains details and specifications of the physical components that make up a device. This information provides an overview of the hardware capabilities, configuration, and characteristics of the device.
// Deprecated: Use OCSF v130 package instead.
type DeviceHwInfo struct {
	// The BIOS date. For example: <code>03/31/16</code>.
	BiosDate *string `json:"bios_date,omitempty" url:"bios_date,omitempty"`
	// The BIOS manufacturer. For example: <code>LENOVO</code>.
	BiosManufacturer *string `json:"bios_manufacturer,omitempty" url:"bios_manufacturer,omitempty"`
	// The BIOS UUID.
	BiosUid *string `json:"bios_uid,omitempty" url:"bios_uid,omitempty"`
	// The BIOS version. For example: <code>LENOVO G5ETA2WW (2.62)</code>.
	BiosVer *string `json:"bios_ver,omitempty" url:"bios_ver,omitempty"`
	// The chassis type describes the system enclosure or physical form factor. Such as the following examples for Windows <a target='_blank' href='https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-systemenclosure'>Windows Chassis Types</a>
	Chassis *string `json:"chassis,omitempty" url:"chassis,omitempty"`
	// The cpu architecture, the number of bits used for addressing in memory. For example: <code>32</code> or <code>64</code>.
	CpuBits *int `json:"cpu_bits,omitempty" url:"cpu_bits,omitempty"`
	// The number of processor cores in all installed processors. For Example: <code>42</code>.
	CpuCores *int `json:"cpu_cores,omitempty" url:"cpu_cores,omitempty"`
	// The number of physical processors on a system. For example: <code>1</code>.
	CpuCount *int `json:"cpu_count,omitempty" url:"cpu_count,omitempty"`
	// The speed of the processor in Mhz. For Example: <code>4200</code>.
	CpuSpeed *int `json:"cpu_speed,omitempty" url:"cpu_speed,omitempty"`
	// The processor type. For example: <code>x86 Family 6 Model 37 Stepping 5</code>.
	CpuType *string `json:"cpu_type,omitempty" url:"cpu_type,omitempty"`
	// The desktop display affiliated with the event
	DesktopDisplay *Display `json:"desktop_display,omitempty" url:"desktop_display,omitempty"`
	// The keyboard detailed information.
	KeyboardInfo *KeyboardInfo `json:"keyboard_info,omitempty" url:"keyboard_info,omitempty"`
	// The total amount of installed RAM, in Megabytes. For example: <code>2048</code>.
	RamSize *int `json:"ram_size,omitempty" url:"ram_size,omitempty"`
	// The device manufacturer serial number.
	SerialNumber *string `json:"serial_number,omitempty" url:"serial_number,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceHwInfo) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceHwInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceHwInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceHwInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *DeviceHwInfo) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DeviceNetworkStatusId is an enum, and the following values are allowed.
// 1 - NotIsolated: Device is not isolated from the network.
// 2 - Isolated: Device is isolated from the network.
// 99 - Unknown: The network isolation status is unknown.
// Deprecated: Use OCSF v130 package instead.
type DeviceNetworkStatusId = int

// DeviceRiskLevelId is an enum, and the following values are allowed.
// 0 - Info
// 1 - Low
// 2 - Medium
// 3 - High
// 4 - Critical
// Deprecated: Use OCSF v130 package instead.
type DeviceRiskLevelId = int

// DeviceTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Server: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Server/'>server</a>.
// 2 - Desktop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:DesktopComputer/'>desktop computer</a>.
// 3 - Laptop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:LaptopComputer/'>laptop computer</a>.
// 4 - Tablet: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:TabletComputer/'>tablet computer</a>.
// 5 - Mobile: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:MobilePhone/'>mobile phone</a>.
// 6 - Virtual: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:VirtualizationSoftware/'>virtual machine</a>.
// 7 - IOT: A <a target='_blank' href='https://www.techtarget.com/iotagenda/definition/IoT-device'>IOT (Internet of Things) device</a>.
// 8 - Browser: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Browser/'>web browser</a>.
// 9 - Firewall: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Firewall/'>networking firewall</a>.
// 10 - Switch: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Switch/'>networking switch</a>.
// 11 - Hub: A <a target='_blank' href='https://en.wikipedia.org/wiki/Ethernet_hub'>networking hub</a>.
// 89 - ImagingEquipment: Equipment for processing optical data, such as a camera.
// 90 - PLC: A Programmable logic controller.
// 91 - SCADA: A supervisory control and data acquisition system.
// 92 - DCS: A distributed control system.
// 93 - CNC: A computer numerical control system, including computerized machine tools.
// 94 - ScientificEquipment: A piece of scientific equipment such as an oscilloscope or spectrometer.
// 95 - MedicalDevice: A medical device such as an MRI machine or infusion pump.
// 96 - LightingControls: A lighting control for internal or external applications.
// 97 - EnergyMonitoringSystem: An energy monitoring, security or safety system.
// 98 - TransportationDevice: A transportation device or transportation supporting device.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type DeviceTypeId = int

// The Digital Signature object contains information about the cryptographic mechanism used to verify the authenticity, integrity, and origin of the file or application.
// Deprecated: Use OCSF v130 package instead.
type DigitalSignature struct {
	// The digital signature algorithm used to create the signature, normalized to the caption of 'algorithm_id'. In the case of 'Other', it is defined by the event source.
	Algorithm *string `json:"algorithm,omitempty" url:"algorithm,omitempty"`
	// The identifier of the normalized digital signature algorithm.
	AlgorithmId DigitalSignatureAlgorithmId `json:"algorithm_id" url:"algorithm_id"`
	// The certificate object containing information about the digital certificate.
	Certificate *Certificate `json:"certificate,omitempty" url:"certificate,omitempty"`
	// The time when the digital signature was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the digital signature was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The developer ID on the certificate that signed the file.
	DeveloperUid *string `json:"developer_uid,omitempty" url:"developer_uid,omitempty"`
	// The message digest attribute contains the fixed length message hash representation and the corresponding hashing algorithm information.
	Digest *Fingerprint `json:"digest,omitempty" url:"digest,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DigitalSignature) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DigitalSignature) UnmarshalJSON(data []byte) error {
	type embed DigitalSignature
	var unmarshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DigitalSignature(unmarshaler.embed)
	d.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *DigitalSignature) MarshalJSON() ([]byte, error) {
	type embed DigitalSignature
	var marshaler = struct {
		embed
		CreatedTimeDt *core.DateTime `json:"created_time_dt,omitempty"`
	}{
		embed:         embed(*d),
		CreatedTimeDt: core.NewOptionalDateTime(d.CreatedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (d *DigitalSignature) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DigitalSignatureAlgorithmId is an enum, and the following values are allowed.
// 0 - Unknown: The algorithm is unknown.
// 1 - DSA: Digital Signature Algorithm (DSA).
// 2 - RSA: Rivest-Shamir-Adleman (RSA) Algorithm.
// 3 - ECDSA: Elliptic Curve Digital Signature Algorithm.
// 4 - Authenticode: Microsoft Authenticode Digital Signature Algorithm.
// 99 - Other: The algorithm is not mapped. See the <code>algorithm</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type DigitalSignatureAlgorithmId = int

// The Display object contains information about the physical or virtual display connected to a computer system.
// Deprecated: Use OCSF v130 package instead.
type Display struct {
	// The numeric color depth.
	ColorDepth *int `json:"color_depth,omitempty" url:"color_depth,omitempty"`
	// The numeric physical height of display.
	PhysicalHeight *int `json:"physical_height,omitempty" url:"physical_height,omitempty"`
	// The numeric physical orientation of display.
	PhysicalOrientation *int `json:"physical_orientation,omitempty" url:"physical_orientation,omitempty"`
	// The numeric physical width of display.
	PhysicalWidth *int `json:"physical_width,omitempty" url:"physical_width,omitempty"`
	// The numeric scale factor of display.
	ScaleFactor *int `json:"scale_factor,omitempty" url:"scale_factor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Display) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Display) UnmarshalJSON(data []byte) error {
	type unmarshaler Display
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Display(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = nil
	return nil
}

func (d *Display) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The Enrichment object provides inline enrichment data for specific attributes of interest within an event. It serves as a mechanism to enhance or supplement the information associated with the event by adding additional relevant details or context.
// Deprecated: Use OCSF v130 package instead.
type Enrichment struct {
	// The enrichment data associated with the attribute and value. The meaning of this data depends on the type the enrichment record.
	Data interface{} `json:"data" url:"data"`
	// The name of the attribute to which the enriched data pertains.
	Name string `json:"name" url:"name"`
	// The enrichment data provider name.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// The enrichment type. For example: <code>location</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The value of the attribute to which the enriched data pertains.
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Enrichment) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Enrichment) UnmarshalJSON(data []byte) error {
	type unmarshaler Enrichment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Enrichment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *Enrichment) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The OCSF Schema Extension object provides detailed information about the schema extension used to construct the event. The schema extensions are registered in the <a target='_blank' href='https://github.com/ocsf/ocsf-schema/blob/main/extensions.md'>extensions.md</a> file.
// Deprecated: Use OCSF v130 package instead.
type Extension struct {
	// The schema extension name. For example: <code>dev</code>.
	Name string `json:"name" url:"name"`
	// The schema extension unique identifier. For example: <code>999</code>.
	Uid string `json:"uid" url:"uid"`
	// The schema extension version. For example: <code>1.0.0-alpha.2</code>.
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Extension) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Extension) UnmarshalJSON(data []byte) error {
	type unmarshaler Extension
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Extension(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = nil
	return nil
}

func (e *Extension) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The Feature object provides information about the software product feature that generated a specific event. It encompasses details related to the capabilities, components, user interface (UI) design, and performance upgrades associated with the feature.
// Deprecated: Use OCSF v130 package instead.
type Feature struct {
	// The name of the feature.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique identifier of the feature.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The version of the feature.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *Feature) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Feature) UnmarshalJSON(data []byte) error {
	type unmarshaler Feature
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Feature(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = nil
	return nil
}

func (f *Feature) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The File object represents the metadata associated with a file stored in a computer system. It encompasses information about the file itself, including its attributes, properties, and organizational details. Defined by D3FEND <a target='_blank' href='https://next.d3fend.mitre.org/dao/artifact/d3f:File/'>d3f:File</a>.
// Deprecated: Use OCSF v130 package instead.
type File struct {
	// The time when the file was last accessed.
	AccessedTime *Timestamp `json:"accessed_time,omitempty" url:"accessed_time,omitempty"`
	// The time when the file was last accessed.
	AccessedTimeDt *time.Time `json:"accessed_time_dt,omitempty" url:"accessed_time_dt,omitempty"`
	// The name of the user who last accessed the object.
	Accessor *User `json:"accessor,omitempty" url:"accessor,omitempty"`
	// The bitmask value that represents the file attributes.
	Attributes *int `json:"attributes,omitempty" url:"attributes,omitempty"`
	// The name of the company that published the file. For example: <code>Microsoft Corporation</code>.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// The file content confidentiality, normalized to the confidentiality_id value. In the case of 'Other', it is defined by the event source.
	Confidentiality *string `json:"confidentiality,omitempty" url:"confidentiality,omitempty"`
	// The normalized identifier of the file content confidentiality indicator.
	ConfidentialityId *FileConfidentialityId `json:"confidentiality_id,omitempty" url:"confidentiality_id,omitempty"`
	// The time when the file was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the file was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The user that created the file.
	Creator *User `json:"creator,omitempty" url:"creator,omitempty"`
	// The description of the file, as returned by file system. For example: the description as returned by the Unix file command or the Windows file type.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// An array of hash attributes.
	Hashes []*Fingerprint `json:"hashes,omitempty" url:"hashes,omitempty"`
	// The indication of whether the object is part of the operating system.
	IsSystem *bool `json:"is_system,omitempty" url:"is_system,omitempty"`
	// The Multipurpose Internet Mail Extensions (MIME) type of the file, if applicable.
	MimeType *string `json:"mime_type,omitempty" url:"mime_type,omitempty"`
	// The time when the file was last modified.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The time when the file was last modified.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The user that last modified the file.
	Modifier *User `json:"modifier,omitempty" url:"modifier,omitempty"`
	// The name of the file. For example: <code>svchost.exe</code>
	Name FileName `json:"name" url:"name"`
	// The user that owns the file/object.
	Owner *User `json:"owner,omitempty" url:"owner,omitempty"`
	// The parent folder in which the file resides. For example: <code>c:\windows\system32</code>
	ParentFolder *string `json:"parent_folder,omitempty" url:"parent_folder,omitempty"`
	// The full path to the file. For example: <code>c:\windows\system32\svchost.exe</code>.
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// The product that created or installed the file.
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// The object security descriptor.
	SecurityDescriptor *string `json:"security_descriptor,omitempty" url:"security_descriptor,omitempty"`
	// The digital signature of the file.
	Signature *DigitalSignature `json:"signature,omitempty" url:"signature,omitempty"`
	// The size of data, in bytes.
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// The file type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The file type ID.
	TypeId FileTypeId `json:"type_id" url:"type_id"`
	// The unique identifier of the file as defined by the storage system, such the file system file ID.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The file version. For example: <code>8.0.7601.17514</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// An unordered collection of zero or more name/value pairs where each pair represents a file or folder extended attribute.</p>For example: Windows alternate data stream attributes (ADS stream name, ADS size, etc.), user-defined or application-defined attributes, ACL, owner, primary group, etc. Examples from DCS: </p><ul><li><strong>ads_name</strong></li><li><strong>ads_size</strong></li><li><strong>dacl</strong></li><li><strong>owner</strong></li><li><strong>primary_group</strong></li><li><strong>link_name</strong> - name of the link associated to the file.</li><li><strong>hard_link_count</strong> - the number of links that are associated to the file.</li></ul>
	Xattributes *Object `json:"xattributes,omitempty" url:"xattributes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *File) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *File) UnmarshalJSON(data []byte) error {
	type embed File
	var unmarshaler = struct {
		embed
		AccessedTimeDt *core.DateTime `json:"accessed_time_dt,omitempty"`
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = File(unmarshaler.embed)
	f.AccessedTimeDt = unmarshaler.AccessedTimeDt.TimePtr()
	f.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	f.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = nil
	return nil
}

func (f *File) MarshalJSON() ([]byte, error) {
	type embed File
	var marshaler = struct {
		embed
		AccessedTimeDt *core.DateTime `json:"accessed_time_dt,omitempty"`
		CreatedTimeDt  *core.DateTime `json:"created_time_dt,omitempty"`
		ModifiedTimeDt *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:          embed(*f),
		AccessedTimeDt: core.NewOptionalDateTime(f.AccessedTimeDt),
		CreatedTimeDt:  core.NewOptionalDateTime(f.CreatedTimeDt),
		ModifiedTimeDt: core.NewOptionalDateTime(f.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (f *File) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// FileConfidentialityId is an enum, and the following values are allowed.
// 0 - Unknown: The confidentiality is unknown.
// 1 - NotConfidential
// 2 - Confidential
// 3 - Secret
// 4 - TopSecret
// 99 - Other: The confidentiality is not mapped. See the <code>confidentiality</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type FileConfidentialityId = int

// FileTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - RegularFile
// 2 - Folder
// 3 - CharacterDevice
// 4 - BlockDevice
// 5 - LocalSocket
// 6 - NamedPipe
// 7 - SymbolicLink
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type FileTypeId = int

// The Fingerprint object provides detailed information about a digital fingerprint, which is a compact representation of data used to identify a longer piece of information, such as a public key or file content. It contains the algorithm and value of the fingerprint, enabling efficient and reliable identification of the associated data.
// Deprecated: Use OCSF v130 package instead.
type Fingerprint struct {
	// The hash algorithm used to create the digital fingerprint, normalized to the caption of 'algorithm_id'. In the case of 'Other', it is defined by the event source.
	Algorithm *string `json:"algorithm,omitempty" url:"algorithm,omitempty"`
	// The identifier of the normalized hash algorithm, which was used to create the digital fingerprint.
	AlgorithmId FingerprintAlgorithmId `json:"algorithm_id" url:"algorithm_id"`
	// The digital fingerprint value.
	Value Hash `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *Fingerprint) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fingerprint) UnmarshalJSON(data []byte) error {
	type unmarshaler Fingerprint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fingerprint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = nil
	return nil
}

func (f *Fingerprint) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// FingerprintAlgorithmId is an enum, and the following values are allowed.
// 0 - Unknown: The algorithm is unknown.
// 1 - MD5: MD5 message-digest algorithm producing a 128-bit (16-byte) hash value.
// 2 - 1: Secure Hash Algorithm 1 producing a 160-bit (20-byte) hash value.
// 3 - 256: Secure Hash Algorithm 2 producing a 256-bit (32-byte) hash value.
// 4 - 512: Secure Hash Algorithm 2 producing a 512-bit (64-byte) hash value.
// 5 - CTPH: The ssdeep generated fuzzy checksum. Also known as Context Triggered Piecewise Hash (CTPH).
// 6 - TLSH: The TLSH fuzzy hashing algorithm.
// 7 - quickXorHash: Microsoft simple non-cryptographic hash algorithm that works by XORing the bytes in a circular-shifting fashion.
// 99 - Other: The algorithm is not mapped. See the <code>algorithm</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type FingerprintAlgorithmId = int

// The Group object represents a collection or association of entities, such as users, policies, or devices. It serves as a logical grouping mechanism to organize and manage entities with similar characteristics or permissions within a system or organization.
// Deprecated: Use OCSF v130 package instead.
type Group struct {
	// The group description.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The domain where the group is defined. For example: the LDAP or Active Directory domain.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The group name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The group privileges.
	Privileges []string `json:"privileges,omitempty" url:"privileges,omitempty"`
	// The type of the group or account.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique identifier of the group. For example, for Windows events this is the security identifier (SID) of the group.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Group) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Group) UnmarshalJSON(data []byte) error {
	type unmarshaler Group
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Group(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = nil
	return nil
}

func (g *Group) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// TThe HTTP Header object represents the headers sent in an HTTP request or response. HTTP headers are key-value pairs that convey additional information about the HTTP message, including details about the content, caching, authentication, encoding, and other aspects of the communication.
// Deprecated: Use OCSF v130 package instead.
type HttpHeader struct {
	// The name of the header
	Name string `json:"name" url:"name"`
	// The value of the header
	Value string `json:"value" url:"value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpHeader) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpHeader) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpHeader
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpHeader(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = nil
	return nil
}

func (h *HttpHeader) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The HTTP Request object represents the attributes of a request made to a web server. It encapsulates the details and metadata associated with an HTTP request, including the request method, headers, URL, query parameters, body content, and other relevant information.
// Deprecated: Use OCSF v130 package instead.
type HttpRequest struct {
	// The arguments sent along with the HTTP request.
	Args *string `json:"args,omitempty" url:"args,omitempty"`
	// Additional HTTP headers of an HTTP request or response.
	HttpHeaders []*HttpHeader `json:"http_headers,omitempty" url:"http_headers,omitempty"`
	// The <a target='_blank' href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods'>HTTP request method</a> indicates the desired action to be performed for a given resource.
	HttpMethod *HttpRequestHttpMethod `json:"http_method,omitempty" url:"http_method,omitempty"`
	// The HTTP request length, in number of bytes.
	Length *int `json:"length,omitempty" url:"length,omitempty"`
	// The request header that identifies the address of the previous web page, which is linked to the current web page or resource being requested.
	Referrer *string `json:"referrer,omitempty" url:"referrer,omitempty"`
	// The unique identifier of the http request.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The URL object that pertains to the request.
	Url *Url `json:"url,omitempty" url:"url,omitempty"`
	// The request header that identifies the operating system and web browser.
	UserAgent *string `json:"user_agent,omitempty" url:"user_agent,omitempty"`
	// The Hypertext Transfer Protocol (HTTP) version.
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// The X-Forwarded-For header identifying the originating IP address(es) of a client connecting to a web server through an HTTP proxy or a load balancer.
	XForwardedFor []IpAddress `json:"x_forwarded_for,omitempty" url:"x_forwarded_for,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpRequest) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = nil
	return nil
}

func (h *HttpRequest) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// HttpRequestHttpMethod is an enum, and the following values are allowed.
// CONNECT - Connect: The CONNECT method establishes a tunnel to the server identified by the target resource.
// DELETE - Delete: The DELETE method deletes the specified resource.
// GET - Get: The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
// HEAD - Head: The HEAD method asks for a response identical to a GET request, but without the response body.
// OPTIONS - Options: The OPTIONS method describes the communication options for the target resource.
// POST - Post: The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.
// PUT - Put: The PUT method replaces all current representations of the target resource with the request payload.
// TRACE - Trace: The TRACE method performs a message loop-back test along the path to the target resource.
// Deprecated: Use OCSF v130 package instead.
type HttpRequestHttpMethod = string

// The HTTP Response object contains detailed information about the response sent from a web server to the requester. It encompasses attributes and metadata that describe the response status, headers, body content, and other relevant information.
// Deprecated: Use OCSF v130 package instead.
type HttpResponse struct {
	// The Hypertext Transfer Protocol (HTTP) status code returned from the web server to the client. For example, 200.
	Code int `json:"code" url:"code"`
	// The request header that identifies the original <a target='_blank' href='https://www.iana.org/assignments/media-types/media-types.xhtml'>media type </a> of the resource (prior to any content encoding applied for sending).
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`
	// Additional HTTP headers of an HTTP request or response.
	HttpHeaders []*HttpHeader `json:"http_headers,omitempty" url:"http_headers,omitempty"`
	// The HTTP response latency measured in milliseconds.
	Latency *int `json:"latency,omitempty" url:"latency,omitempty"`
	// The HTTP response length, in number of bytes.
	Length *int `json:"length,omitempty" url:"length,omitempty"`
	// The description of the event/finding, as defined by the source.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// The response status. For example: A successful HTTP status of 'OK' which corresponds to a code of 200.
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HttpResponse) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HttpResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler HttpResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HttpResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = nil
	return nil
}

func (h *HttpResponse) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// The Identity Provider object contains detailed information about a provider responsible for creating, maintaining, and managing identity information while offering authentication services to applications. An Identity Provider (IdP) serves as a trusted authority that verifies the identity of users and issues authentication tokens or assertions to enable secure access to applications or services.
// Deprecated: Use OCSF v130 package instead.
type Idp struct {
	// The name of the identity provider.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique identifier of the identity provider.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Idp) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Idp) UnmarshalJSON(data []byte) error {
	type unmarshaler Idp
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Idp(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *Idp) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The Image object provides a description of a specific Virtual Machine (VM) or Container image. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:ContainerImage/'>d3f:ContainerImage</a>.
// Deprecated: Use OCSF v130 package instead.
type Image struct {
	// The image labels.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The image name. For example: <code>elixir</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The full path to the image file.
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// The image tag. For example: <code>1.11-alpine</code>.
	Tag *string `json:"tag,omitempty" url:"tag,omitempty"`
	// The unique image ID. For example: <code>77af4d6b9913</code>.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Image) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Image) UnmarshalJSON(data []byte) error {
	type unmarshaler Image
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Image(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = nil
	return nil
}

func (i *Image) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The Keyboard Information object contains details and attributes related to a computer or device keyboard. It encompasses information that describes the characteristics, capabilities, and configuration of the keyboard.
// Deprecated: Use OCSF v130 package instead.
type KeyboardInfo struct {
	// The number of function keys on client keyboard.
	FunctionKeys *int `json:"function_keys,omitempty" url:"function_keys,omitempty"`
	// The Input Method Editor (IME) file name.
	Ime *string `json:"ime,omitempty" url:"ime,omitempty"`
	// The keyboard locale identifier name (e.g., en-US).
	KeyboardLayout *string `json:"keyboard_layout,omitempty" url:"keyboard_layout,omitempty"`
	// The keyboard numeric code.
	KeyboardSubtype *int `json:"keyboard_subtype,omitempty" url:"keyboard_subtype,omitempty"`
	// The keyboard type (e.g., xt, ico).
	KeyboardType *string `json:"keyboard_type,omitempty" url:"keyboard_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (k *KeyboardInfo) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyboardInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyboardInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyboardInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties

	k._rawJSON = nil
	return nil
}

func (k *KeyboardInfo) String() string {
	if len(k._rawJSON) > 0 {
		if value, err := core.StringifyJSON(k._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// The additional LDAP attributes that describe a person.
// Deprecated: Use OCSF v130 package instead.
type LdapPerson struct {
	// The cost center associated with the user.
	CostCenter *string `json:"cost_center,omitempty" url:"cost_center,omitempty"`
	// The timestamp when the user was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The timestamp when the user was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The timestamp when the user was deleted. In Active Directory (AD), when a user is deleted they are moved to a temporary container and then removed after 30 days. So, this field can be populated even after a user is deleted for the next 30 days.
	DeletedTime *Timestamp `json:"deleted_time,omitempty" url:"deleted_time,omitempty"`
	// The timestamp when the user was deleted. In Active Directory (AD), when a user is deleted they are moved to a temporary container and then removed after 30 days. So, this field can be populated even after a user is deleted for the next 30 days.
	DeletedTimeDt *time.Time `json:"deleted_time_dt,omitempty" url:"deleted_time_dt,omitempty"`
	// A list of additional email addresses for the user.
	EmailAddrs []EmailAddress `json:"email_addrs,omitempty" url:"email_addrs,omitempty"`
	// The employee identifier assigned to the user by the organization.
	EmployeeUid *string `json:"employee_uid,omitempty" url:"employee_uid,omitempty"`
	// The given or first name of the user.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The timestamp when the user was or will be hired by the organization.
	HireTime *Timestamp `json:"hire_time,omitempty" url:"hire_time,omitempty"`
	// The timestamp when the user was or will be hired by the organization.
	HireTimeDt *time.Time `json:"hire_time_dt,omitempty" url:"hire_time_dt,omitempty"`
	// The user's job title.
	JobTitle *string `json:"job_title,omitempty" url:"job_title,omitempty"`
	// The labels associated with the user. For example in AD this could be the <code>userType</code>, <code>employeeType</code>. For example: <code>Member, Employee</code>.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The last time when the user logged in.
	LastLoginTime *Timestamp `json:"last_login_time,omitempty" url:"last_login_time,omitempty"`
	// The last time when the user logged in.
	LastLoginTimeDt *time.Time `json:"last_login_time_dt,omitempty" url:"last_login_time_dt,omitempty"`
	// The LDAP and X.500 <code>commonName</code> attribute, typically the full name of the person. For example, <code>John Doe</code>.
	LdapCn *string `json:"ldap_cn,omitempty" url:"ldap_cn,omitempty"`
	// The X.500 Distinguished Name (DN) is a structured string that uniquely identifies an entry, such as a user, in an X.500 directory service For example, <code>cn=John Doe,ou=People,dc=example,dc=com</code>.
	LdapDn *string `json:"ldap_dn,omitempty" url:"ldap_dn,omitempty"`
	// The timestamp when the user left or will be leaving the organization.
	LeaveTime *Timestamp `json:"leave_time,omitempty" url:"leave_time,omitempty"`
	// The timestamp when the user left or will be leaving the organization.
	LeaveTimeDt *time.Time `json:"leave_time_dt,omitempty" url:"leave_time_dt,omitempty"`
	// The geographical location associated with a user. This is typically the user's usual work location.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The user's manager. This helps in understanding an org hierarchy. This should only ever be populated once in an event. I.e. there should not be a manager's manager in an event.
	Manager *Object `json:"manager,omitempty" url:"manager,omitempty"`
	// The timestamp when the user entry was last modified.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The timestamp when the user entry was last modified.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The primary office location associated with the user. This could be any string and isn't a specific address. For example, <code>South East Virtual</code>.
	OfficeLocation *string `json:"office_location,omitempty" url:"office_location,omitempty"`
	// The last or family name for the user.
	Surname *string `json:"surname,omitempty" url:"surname,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LdapPerson) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LdapPerson) UnmarshalJSON(data []byte) error {
	type embed LdapPerson
	var unmarshaler = struct {
		embed
		CreatedTimeDt   *core.DateTime `json:"created_time_dt,omitempty"`
		DeletedTimeDt   *core.DateTime `json:"deleted_time_dt,omitempty"`
		HireTimeDt      *core.DateTime `json:"hire_time_dt,omitempty"`
		LastLoginTimeDt *core.DateTime `json:"last_login_time_dt,omitempty"`
		LeaveTimeDt     *core.DateTime `json:"leave_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LdapPerson(unmarshaler.embed)
	l.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	l.DeletedTimeDt = unmarshaler.DeletedTimeDt.TimePtr()
	l.HireTimeDt = unmarshaler.HireTimeDt.TimePtr()
	l.LastLoginTimeDt = unmarshaler.LastLoginTimeDt.TimePtr()
	l.LeaveTimeDt = unmarshaler.LeaveTimeDt.TimePtr()
	l.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *LdapPerson) MarshalJSON() ([]byte, error) {
	type embed LdapPerson
	var marshaler = struct {
		embed
		CreatedTimeDt   *core.DateTime `json:"created_time_dt,omitempty"`
		DeletedTimeDt   *core.DateTime `json:"deleted_time_dt,omitempty"`
		HireTimeDt      *core.DateTime `json:"hire_time_dt,omitempty"`
		LastLoginTimeDt *core.DateTime `json:"last_login_time_dt,omitempty"`
		LeaveTimeDt     *core.DateTime `json:"leave_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
	}{
		embed:           embed(*l),
		CreatedTimeDt:   core.NewOptionalDateTime(l.CreatedTimeDt),
		DeletedTimeDt:   core.NewOptionalDateTime(l.DeletedTimeDt),
		HireTimeDt:      core.NewOptionalDateTime(l.HireTimeDt),
		LastLoginTimeDt: core.NewOptionalDateTime(l.LastLoginTimeDt),
		LeaveTimeDt:     core.NewOptionalDateTime(l.LeaveTimeDt),
		ModifiedTimeDt:  core.NewOptionalDateTime(l.ModifiedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (l *LdapPerson) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The Geo Location object describes a geographical location, usually associated with an IP address. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:PhysicalLocation/'>d3f:PhysicalLocation</a>.
// Deprecated: Use OCSF v130 package instead.
type Location struct {
	// The name of the city.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// The name of the continent.
	Continent *string `json:"continent,omitempty" url:"continent,omitempty"`
	// A two-element array, containing a longitude/latitude pair. The format conforms with <a target='_blank' href='https://geojson.org'>GeoJSON</a>. For example: <code>[-73.983, 40.719]</code>.
	Coordinates []float64 `json:"coordinates,omitempty" url:"coordinates,omitempty"`
	// The ISO 3166-1 Alpha-2 country code. For the complete list of country codes see <a target='_blank' href='https://www.iso.org/obp/ui/#iso:pub:PUB500001:en' >ISO 3166-1 alpha-2 codes</a>.<p><b>Note:</b> The two letter country code should be capitalized. For example: <code>US</code> or <code>CA</code>.</p>
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// The description of the geographical location.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The indication of whether the location is on premises.
	IsOnPremises *bool `json:"is_on_premises,omitempty" url:"is_on_premises,omitempty"`
	// The name of the Internet Service Provider (ISP).
	Isp *string `json:"isp,omitempty" url:"isp,omitempty"`
	// The postal code of the location.
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// The provider of the geographical location data.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// The alphanumeric code that identifies the principal subdivision (e.g. province or state) of the country. Region codes are defined at <a target='_blank' href='https://www.iso.org/iso-3166-country-codes.html'>ISO 3166-2</a> and have a limit of three characters. For example, see <a target='_blank' href='https://www.iso.org/obp/ui/#iso:code:3166:US'>the region codes for the US</a>.
	Region *string `json:"region,omitempty" url:"region,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Location) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Location) UnmarshalJSON(data []byte) error {
	type unmarshaler Location
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Location(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *Location) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The Logger object represents the device and product where events are stored with times for receipt and transmission. This may be at the source device where the event occurred, a remote scanning device, intermediate hops, or the ultimate destination.
// Deprecated: Use OCSF v130 package instead.
type Logger struct {
	// The device where the events are logged.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// The audit level at which an event was generated.
	LogLevel *string `json:"log_level,omitempty" url:"log_level,omitempty"`
	// The event log name. For example, syslog file name or Windows logging subsystem: Security.
	LogName *string `json:"log_name,omitempty" url:"log_name,omitempty"`
	// The logging provider or logging service that logged the event. For example, Microsoft-Windows-Security-Auditing.
	LogProvider *string `json:"log_provider,omitempty" url:"log_provider,omitempty"`
	// The event log schema version that specifies the format of the original event. For example syslog version or Cisco Log Schema Version.
	LogVersion *string `json:"log_version,omitempty" url:"log_version,omitempty"`
	// <p>The time when the logging system collected and logged the event.</p>This attribute is distinct from the event time in that event time typically contain the time extracted from the original event. Most of the time, these two times will be different.
	LoggedTime *Timestamp `json:"logged_time,omitempty" url:"logged_time,omitempty"`
	// <p>The time when the logging system collected and logged the event.</p>This attribute is distinct from the event time in that event time typically contain the time extracted from the original event. Most of the time, these two times will be different.
	LoggedTimeDt *time.Time `json:"logged_time_dt,omitempty" url:"logged_time_dt,omitempty"`
	// The name of the logging product instance.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The product logging the event. This may be the event source product, a management server product, a scanning product, a SIEM, etc.
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// The time when the event was transmitted from the logging device to it's next destination
	TransmitTime *Timestamp `json:"transmit_time,omitempty" url:"transmit_time,omitempty"`
	// The time when the event was transmitted from the logging device to it's next destination
	TransmitTimeDt *time.Time `json:"transmit_time_dt,omitempty" url:"transmit_time_dt,omitempty"`
	// The unique identifier of the logging product instance.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The version of the logging product.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Logger) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Logger) UnmarshalJSON(data []byte) error {
	type embed Logger
	var unmarshaler = struct {
		embed
		LoggedTimeDt   *core.DateTime `json:"logged_time_dt,omitempty"`
		TransmitTimeDt *core.DateTime `json:"transmit_time_dt,omitempty"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = Logger(unmarshaler.embed)
	l.LoggedTimeDt = unmarshaler.LoggedTimeDt.TimePtr()
	l.TransmitTimeDt = unmarshaler.TransmitTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = nil
	return nil
}

func (l *Logger) MarshalJSON() ([]byte, error) {
	type embed Logger
	var marshaler = struct {
		embed
		LoggedTimeDt   *core.DateTime `json:"logged_time_dt,omitempty"`
		TransmitTimeDt *core.DateTime `json:"transmit_time_dt,omitempty"`
	}{
		embed:          embed(*l),
		LoggedTimeDt:   core.NewOptionalDateTime(l.LoggedTimeDt),
		TransmitTimeDt: core.NewOptionalDateTime(l.TransmitTimeDt),
	}
	return json.Marshal(marshaler)
}

func (l *Logger) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The Metadata object describes the metadata associated with the event. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Metadata/'>d3f:Metadata</a>.
// Deprecated: Use OCSF v130 package instead.
type Metadata struct {
	// The unique identifier used to correlate events.
	CorrelationUid *string `json:"correlation_uid,omitempty" url:"correlation_uid,omitempty"`
	// The Event ID or Code that the product uses to describe the event.
	EventCode *string `json:"event_code,omitempty" url:"event_code,omitempty"`
	// The schema extension used to create the event.
	Extension *Extension `json:"extension,omitempty" url:"extension,omitempty"`
	// The schema extensions used to create the event.
	Extensions []*Extension `json:"extensions,omitempty" url:"extensions,omitempty"`
	// <p>The list of category labels attached to the event or specific attributes. Labels are user defined tags or aliases added at normalization time.</p>For example: <code>["network", "connection.ip:destination", "device.ip:source"]</code>
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The audit level at which an event was generated.
	LogLevel *string `json:"log_level,omitempty" url:"log_level,omitempty"`
	// The event log name. For example, syslog file name or Windows logging subsystem: Security.
	LogName *string `json:"log_name,omitempty" url:"log_name,omitempty"`
	// The logging provider or logging service that logged the event. For example, Microsoft-Windows-Security-Auditing.
	LogProvider *string `json:"log_provider,omitempty" url:"log_provider,omitempty"`
	// The event log schema version that specifies the format of the original event. For example syslog version or Cisco Log Schema Version.
	LogVersion *string `json:"log_version,omitempty" url:"log_version,omitempty"`
	// <p>The time when the logging system collected and logged the event.</p>This attribute is distinct from the event time in that event time typically contain the time extracted from the original event. Most of the time, these two times will be different.
	LoggedTime *Timestamp `json:"logged_time,omitempty" url:"logged_time,omitempty"`
	// <p>The time when the logging system collected and logged the event.</p>This attribute is distinct from the event time in that event time typically contain the time extracted from the original event. Most of the time, these two times will be different.
	LoggedTimeDt *time.Time `json:"logged_time_dt,omitempty" url:"logged_time_dt,omitempty"`
	// An array of Logger objects that describe the devices and logging products between the event source and its eventual destination. Note, this attribute can be used when there is a complex end-to-end path of event flow.
	Loggers []*Logger `json:"loggers,omitempty" url:"loggers,omitempty"`
	// The time when the event was last modified or enriched.
	ModifiedTime *Timestamp `json:"modified_time,omitempty" url:"modified_time,omitempty"`
	// The time when the event was last modified or enriched.
	ModifiedTimeDt *time.Time `json:"modified_time_dt,omitempty" url:"modified_time_dt,omitempty"`
	// The original event time as reported by the event source. For example, the time in the original format from system event log such as Syslog on Unix/Linux and the System event file on Windows. Omit if event is generated instead of collected via logs.
	OriginalTime *string `json:"original_time,omitempty" url:"original_time,omitempty"`
	// The event processed time, such as an ETL operation.
	ProcessedTime *Timestamp `json:"processed_time,omitempty" url:"processed_time,omitempty"`
	// The event processed time, such as an ETL operation.
	ProcessedTimeDt *time.Time `json:"processed_time_dt,omitempty" url:"processed_time_dt,omitempty"`
	// The product that reported the event.
	Product *Product `json:"product" url:"product"`
	// The list of profiles used to create the event.
	Profiles []string `json:"profiles,omitempty" url:"profiles,omitempty"`
	// Sequence number of the event. The sequence number is a value available in some events, to make the exact ordering of events unambiguous, regardless of the event time precision.
	Sequence *int `json:"sequence,omitempty" url:"sequence,omitempty"`
	// The unique tenant identifier.
	TenantUid *string `json:"tenant_uid,omitempty" url:"tenant_uid,omitempty"`
	// The logging system-assigned unique identifier of an event instance.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The version of the OCSF schema, using Semantic Versioning Specification (<a target='_blank' href='https://semver.org'>SemVer</a>). For example: 1.0.0. Event consumers use the version to determine the available event attributes.
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Metadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type embed Metadata
	var unmarshaler = struct {
		embed
		LoggedTimeDt    *core.DateTime `json:"logged_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
		ProcessedTimeDt *core.DateTime `json:"processed_time_dt,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Metadata(unmarshaler.embed)
	m.LoggedTimeDt = unmarshaler.LoggedTimeDt.TimePtr()
	m.ModifiedTimeDt = unmarshaler.ModifiedTimeDt.TimePtr()
	m.ProcessedTimeDt = unmarshaler.ProcessedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = nil
	return nil
}

func (m *Metadata) MarshalJSON() ([]byte, error) {
	type embed Metadata
	var marshaler = struct {
		embed
		LoggedTimeDt    *core.DateTime `json:"logged_time_dt,omitempty"`
		ModifiedTimeDt  *core.DateTime `json:"modified_time_dt,omitempty"`
		ProcessedTimeDt *core.DateTime `json:"processed_time_dt,omitempty"`
	}{
		embed:           embed(*m),
		LoggedTimeDt:    core.NewOptionalDateTime(m.LoggedTimeDt),
		ModifiedTimeDt:  core.NewOptionalDateTime(m.ModifiedTimeDt),
		ProcessedTimeDt: core.NewOptionalDateTime(m.ProcessedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (m *Metadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The Network Connection Information object describes characteristics of a network connection. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:NetworkSession/'>d3f:NetworkSession</a>.
// Deprecated: Use OCSF v130 package instead.
type NetworkConnectionInfo struct {
	// The boundary of the connection, normalized to the caption of 'boundary_id'. In the case of 'Other', it is defined by the event source. <p> For cloud connections, this translates to the traffic-boundary(same VPC, through IGW, etc.). For traditional networks, this is described as Local, Internal, or External.</p>
	Boundary *string `json:"boundary,omitempty" url:"boundary,omitempty"`
	// <p>The normalized identifier of the boundary of the connection. </p><p> For cloud connections, this translates to the traffic-boundary (same VPC, through IGW, etc.). For traditional networks, this is described as Local, Internal, or External.</p>
	BoundaryId *NetworkConnectionInfoBoundaryId `json:"boundary_id,omitempty" url:"boundary_id,omitempty"`
	// The direction of the initiated connection, traffic, or email, normalized to the caption of the direction_id value. In the case of 'Other', it is defined by the event source.
	Direction *string `json:"direction,omitempty" url:"direction,omitempty"`
	// The normalized identifier of the direction of the initiated connection, traffic, or email.
	DirectionId NetworkConnectionInfoDirectionId `json:"direction_id" url:"direction_id"`
	// The TCP/IP protocol name in lowercase, as defined by the Internet Assigned Numbers Authority (IANA). See <a target='_blank' href='https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml'>Protocol Numbers</a>. For example: <code>tcp</code> or <code>udp</code>.
	ProtocolName *string `json:"protocol_name,omitempty" url:"protocol_name,omitempty"`
	// The TCP/IP protocol number, as defined by the Internet Assigned Numbers Authority (IANA). Use -1 if the protocol is not defined by IANA. See <a target='_blank' href='https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml'>Protocol Numbers</a>. For example: <code>6</code> for TCP and <code>17</code> for UDP.
	ProtocolNum *int `json:"protocol_num,omitempty" url:"protocol_num,omitempty"`
	// The Internet Protocol version.
	ProtocolVer *string `json:"protocol_ver,omitempty" url:"protocol_ver,omitempty"`
	// The Internet Protocol version identifier.
	ProtocolVerId *NetworkConnectionInfoProtocolVerId `json:"protocol_ver_id,omitempty" url:"protocol_ver_id,omitempty"`
	// The authenticated user or service session.
	Session *Session `json:"session,omitempty" url:"session,omitempty"`
	// The network connection TCP header flags (i.e., control bits).
	TcpFlags *int `json:"tcp_flags,omitempty" url:"tcp_flags,omitempty"`
	// The unique identifier of the connection.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkConnectionInfo) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkConnectionInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkConnectionInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkConnectionInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkConnectionInfo) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NetworkConnectionInfoBoundaryId is an enum, and the following values are allowed.
// 0 - Unknown: The connection boundary is unknown.
// 1 - Localhost: Local network traffic on the same endpoint.
// 2 - Internal: Internal network traffic between two endpoints inside network.
// 3 - External: External network traffic between two endpoints on the Internet or outside the network.
// 4 - SameVPC: Through another resource in the same VPC
// 5 - VPCGateway: Through an Internet gateway or a gateway VPC endpoint
// 6 - VirtualPrivateGateway: Through a virtual private gateway
// 7 - regionVPC: Through an intra-region VPC peering connection
// 8 - regionVPC: Through an inter-region VPC peering connection
// 9 - LocalGateway: Through a local gateway
// 10 - GatewayVPC: Through a gateway VPC endpoint (Nitro-based instances only)
// 11 - InternetGateway: Through an Internet gateway (Nitro-based instances only)
// 99 - Other: The boundary is not mapped. See the <code>boundary</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type NetworkConnectionInfoBoundaryId = int

// NetworkConnectionInfoDirectionId is an enum, and the following values are allowed.
// 0 - Unknown: The connection direction is unknown.
// 1 - Inbound: Inbound network connection. The connection was originated from the Internet or outside network, destined for services on the inside network.
// 2 - Outbound: Outbound network connection. The connection was originated from inside the network, destined for services on the Internet or outside network.
// 3 - Lateral: Lateral network connection. The connection was originated from inside the network, destined for services on the inside network.
// 99 - Other: The direction is not mapped. See the <code>direction</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type NetworkConnectionInfoDirectionId = int

// NetworkConnectionInfoProtocolVerId is an enum, and the following values are allowed.
// 0 - Unknown
// 4 - IPv4*
// 6 - IPv6*
// 99 - Other
// Deprecated: Use OCSF v130 package instead.
type NetworkConnectionInfoProtocolVerId = int

// The Network Endpoint object describes characteristics of a network endpoint. These can be a source or destination of a network connection.
// Deprecated: Use OCSF v130 package instead.
type NetworkEndpoint struct {
	// The information describing an instance of a container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
	Container *Container `json:"container,omitempty" url:"container,omitempty"`
	// The name of the domain.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The fully qualified name of the endpoint.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The endpoint hardware information.
	HwInfo *DeviceHwInfo `json:"hw_info,omitempty" url:"hw_info,omitempty"`
	// The unique identifier of a VM instance.
	InstanceUid *string `json:"instance_uid,omitempty" url:"instance_uid,omitempty"`
	// The name of the network interface (e.g. eth2).
	InterfaceName *string `json:"interface_name,omitempty" url:"interface_name,omitempty"`
	// The unique identifier of the network interface.
	InterfaceUid *string `json:"interface_uid,omitempty" url:"interface_uid,omitempty"`
	// The intermediate IP Addresses. For example, the IP addresses in the HTTP X-Forwarded-For header.
	IntermediateIps []IpAddress `json:"intermediate_ips,omitempty" url:"intermediate_ips,omitempty"`
	// The IP address of the endpoint, in either IPv4 or IPv6 format.
	Ip *IpAddress `json:"ip,omitempty" url:"ip,omitempty"`
	// The geographical location of the endpoint.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The Media Access Control (MAC) address of the endpoint.
	Mac *MacAddress `json:"mac,omitempty" url:"mac,omitempty"`
	// The short name of the endpoint.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// If running under a process namespace (such as in a container), the process identifier within that process namespace.
	NamespacePid *int `json:"namespace_pid,omitempty" url:"namespace_pid,omitempty"`
	// The endpoint operating system.
	Os *Os `json:"os,omitempty" url:"os,omitempty"`
	// The port used for communication within the network connection.
	Port *Port `json:"port,omitempty" url:"port,omitempty"`
	// The network proxy information pertaining to a specific endpoint. This can be used to describe information pertaining to network address translation (NAT).
	ProxyEndpoint *NetworkProxy `json:"proxy_endpoint,omitempty" url:"proxy_endpoint,omitempty"`
	// The unique identifier of a virtual subnet.
	SubnetUid *string `json:"subnet_uid,omitempty" url:"subnet_uid,omitempty"`
	// The service name in service-to-service connections. For example, AWS VPC logs the pkt-src-aws-service and pkt-dst-aws-service fields identify the connection is coming from or going to an AWS service.
	SvcName *string `json:"svc_name,omitempty" url:"svc_name,omitempty"`
	// The network endpoint type. For example: <code>unknown</code>, <code>server</code>, <code>desktop</code>, <code>laptop</code>, <code>tablet</code>, <code>mobile</code>, <code>virtual</code>, <code>browser</code>, or <code>other</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The network endpoint type ID.
	TypeId *NetworkEndpointTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique identifier of the endpoint.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The Virtual LAN identifier.
	VlanUid *string `json:"vlan_uid,omitempty" url:"vlan_uid,omitempty"`
	// The unique identifier of the Virtual Private Cloud (VPC).
	VpcUid *string `json:"vpc_uid,omitempty" url:"vpc_uid,omitempty"`
	// The network zone or LAN segment.
	Zone *string `json:"zone,omitempty" url:"zone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkEndpoint) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkEndpoint) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkEndpoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkEndpoint(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkEndpoint) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NetworkEndpointTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Server: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Server/'>server</a>.
// 2 - Desktop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:DesktopComputer/'>desktop computer</a>.
// 3 - Laptop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:LaptopComputer/'>laptop computer</a>.
// 4 - Tablet: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:TabletComputer/'>tablet computer</a>.
// 5 - Mobile: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:MobilePhone/'>mobile phone</a>.
// 6 - Virtual: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:VirtualizationSoftware/'>virtual machine</a>.
// 7 - IOT: A <a target='_blank' href='https://www.techtarget.com/iotagenda/definition/IoT-device'>IOT (Internet of Things) device</a>.
// 8 - Browser: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Browser/'>web browser</a>.
// 9 - Firewall: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Firewall/'>networking firewall</a>.
// 10 - Switch: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Switch/'>networking switch</a>.
// 11 - Hub: A <a target='_blank' href='https://en.wikipedia.org/wiki/Ethernet_hub'>networking hub</a>.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type NetworkEndpointTypeId = int

// The Network Interface object describes the type and associated attributes of a network interface.
// Deprecated: Use OCSF v130 package instead.
type NetworkInterface struct {
	// The hostname associated with the network interface.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The IP address associated with the network interface.
	Ip *IpAddress `json:"ip,omitempty" url:"ip,omitempty"`
	// A list of IP addresses available on the network interface.
	IpAddresses []string `json:"ip_addresses,omitempty" url:"ip_addresses,omitempty"`
	// The MAC address of the network interface.
	Mac *MacAddress `json:"mac,omitempty" url:"mac,omitempty"`
	// A list of MAC addresses available on the network interface.
	MacAddresses []string `json:"mac_addresses,omitempty" url:"mac_addresses,omitempty"`
	// The name of the network interface.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The namespace is useful in merger or acquisition situations. For example, when similar entities exist that you need to keep separate.
	Namespace *string `json:"namespace,omitempty" url:"namespace,omitempty"`
	// The subnet prefix length determines the number of bits used to represent the network part of the IP address. The remaining bits are reserved for identifying individual hosts within that subnet.
	SubnetPrefix *int `json:"subnet_prefix,omitempty" url:"subnet_prefix,omitempty"`
	// The type of network interface.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The network interface type identifier.
	TypeId NetworkInterfaceTypeId `json:"type_id" url:"type_id"`
	// The unique identifier for the network interface.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkInterface) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkInterface) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkInterface
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkInterface(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkInterface) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NetworkInterfaceTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Wired
// 2 - Wireless
// 3 - Mobile
// 4 - Tunnel
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type NetworkInterfaceTypeId = int

// The network proxy endpoint object describes a proxy server, which acts as an intermediary between a client requesting a resource and the server providing that resource. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:ProxyServer/'>d3f:ProxyServer</a>.
// Deprecated: Use OCSF v130 package instead.
type NetworkProxy struct {
	// The information describing an instance of a container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
	Container *Container `json:"container,omitempty" url:"container,omitempty"`
	// The name of the domain.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The fully qualified name of the endpoint.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The endpoint hardware information.
	HwInfo *DeviceHwInfo `json:"hw_info,omitempty" url:"hw_info,omitempty"`
	// The unique identifier of a VM instance.
	InstanceUid *string `json:"instance_uid,omitempty" url:"instance_uid,omitempty"`
	// The name of the network interface (e.g. eth2).
	InterfaceName *string `json:"interface_name,omitempty" url:"interface_name,omitempty"`
	// The unique identifier of the network interface.
	InterfaceUid *string `json:"interface_uid,omitempty" url:"interface_uid,omitempty"`
	// The intermediate IP Addresses. For example, the IP addresses in the HTTP X-Forwarded-For header.
	IntermediateIps []IpAddress `json:"intermediate_ips,omitempty" url:"intermediate_ips,omitempty"`
	// The IP address of the endpoint, in either IPv4 or IPv6 format.
	Ip *IpAddress `json:"ip,omitempty" url:"ip,omitempty"`
	// The geographical location of the endpoint.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`
	// The Media Access Control (MAC) address of the endpoint.
	Mac *MacAddress `json:"mac,omitempty" url:"mac,omitempty"`
	// The short name of the endpoint.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// If running under a process namespace (such as in a container), the process identifier within that process namespace.
	NamespacePid *int `json:"namespace_pid,omitempty" url:"namespace_pid,omitempty"`
	// The endpoint operating system.
	Os *Os `json:"os,omitempty" url:"os,omitempty"`
	// The port used for communication within the network connection.
	Port *Port `json:"port,omitempty" url:"port,omitempty"`
	// The network proxy information pertaining to a specific endpoint. This can be used to describe information pertaining to network address translation (NAT).
	ProxyEndpoint *Object `json:"proxy_endpoint,omitempty" url:"proxy_endpoint,omitempty"`
	// The unique identifier of a virtual subnet.
	SubnetUid *string `json:"subnet_uid,omitempty" url:"subnet_uid,omitempty"`
	// The service name in service-to-service connections. For example, AWS VPC logs the pkt-src-aws-service and pkt-dst-aws-service fields identify the connection is coming from or going to an AWS service.
	SvcName *string `json:"svc_name,omitempty" url:"svc_name,omitempty"`
	// The network endpoint type. For example: <code>unknown</code>, <code>server</code>, <code>desktop</code>, <code>laptop</code>, <code>tablet</code>, <code>mobile</code>, <code>virtual</code>, <code>browser</code>, or <code>other</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The network endpoint type ID.
	TypeId *NetworkProxyTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique identifier of the endpoint.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The Virtual LAN identifier.
	VlanUid *string `json:"vlan_uid,omitempty" url:"vlan_uid,omitempty"`
	// The unique identifier of the Virtual Private Cloud (VPC).
	VpcUid *string `json:"vpc_uid,omitempty" url:"vpc_uid,omitempty"`
	// The network zone or LAN segment.
	Zone *string `json:"zone,omitempty" url:"zone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkProxy) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkProxy) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkProxy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkProxy(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkProxy) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// NetworkProxyTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - Server: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Server/'>server</a>.
// 2 - Desktop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:DesktopComputer/'>desktop computer</a>.
// 3 - Laptop: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:LaptopComputer/'>laptop computer</a>.
// 4 - Tablet: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:TabletComputer/'>tablet computer</a>.
// 5 - Mobile: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:MobilePhone/'>mobile phone</a>.
// 6 - Virtual: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:VirtualizationSoftware/'>virtual machine</a>.
// 7 - IOT: A <a target='_blank' href='https://www.techtarget.com/iotagenda/definition/IoT-device'>IOT (Internet of Things) device</a>.
// 8 - Browser: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Browser/'>web browser</a>.
// 9 - Firewall: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Firewall/'>networking firewall</a>.
// 10 - Switch: A <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Switch/'>networking switch</a>.
// 11 - Hub: A <a target='_blank' href='https://en.wikipedia.org/wiki/Ethernet_hub'>networking hub</a>.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type NetworkProxyTypeId = int

// The Network Traffic object describes characteristics of network traffic. Network traffic refers to data moving across a network at a given point of time. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:NetworkTraffic/'>d3f:NetworkTraffic</a>.
// Deprecated: Use OCSF v130 package instead.
type NetworkTraffic struct {
	// The total number of bytes (in and out).
	Bytes *int `json:"bytes,omitempty" url:"bytes,omitempty"`
	// The number of bytes sent from the destination to the source.
	BytesIn *int `json:"bytes_in,omitempty" url:"bytes_in,omitempty"`
	// The number of bytes sent from the source to the destination.
	BytesOut *int `json:"bytes_out,omitempty" url:"bytes_out,omitempty"`
	// The total number of chunks (in and out).
	Chunks *int `json:"chunks,omitempty" url:"chunks,omitempty"`
	// The number of chunks sent from the destination to the source.
	ChunksIn *int `json:"chunks_in,omitempty" url:"chunks_in,omitempty"`
	// The number of chunks sent from the source to the destination.
	ChunksOut *int `json:"chunks_out,omitempty" url:"chunks_out,omitempty"`
	// The total number of packets (in and out).
	Packets *int `json:"packets,omitempty" url:"packets,omitempty"`
	// The number of packets sent from the destination to the source.
	PacketsIn *int `json:"packets_in,omitempty" url:"packets_in,omitempty"`
	// The number of packets sent from the source to the destination.
	PacketsOut *int `json:"packets_out,omitempty" url:"packets_out,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NetworkTraffic) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NetworkTraffic) UnmarshalJSON(data []byte) error {
	type unmarshaler NetworkTraffic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NetworkTraffic(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = nil
	return nil
}

func (n *NetworkTraffic) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// An unordered collection of attributes. It defines a set of attributes available in all objects. It can be also used as a generic object to log objects that are not otherwise defined by the schema.
// Deprecated: Use OCSF v130 package instead.
type Object = map[string]interface{}

// The observable object is a pivot element that contains related information found in many places in the event.
// Deprecated: Use OCSF v130 package instead.
type Observable struct {
	// The full name of the observable attribute. The <code>name</code> is a pointer/reference to an attribute within the event data. For example: <code>file.name</code>.
	Name string `json:"name" url:"name"`
	// Contains the original and normalized reputation scores.
	Reputation *Reputation `json:"reputation,omitempty" url:"reputation,omitempty"`
	// The observable value type name.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The observable value type identifier.
	TypeId ObservableTypeId `json:"type_id" url:"type_id"`
	// The value associated with the observable attribute. The meaning of the value depends on the observable type.<br/>If the <code>name</code> refers to a scalar attribute, then the <code>value</code> is the value of the attribute.<br/>If the <code>name</code> refers to an object attribute, then the <code>value</code> is not populated.
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Observable) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Observable) UnmarshalJSON(data []byte) error {
	type unmarshaler Observable
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Observable(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Observable) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// ObservableTypeId is an enum, and the following values are allowed.
// 0 - Unknown: Unknown observable data type.
// 1 - Hostname: Unique name assigned to a device connected to a computer network. A domain name in general is an Internet address that can be resolved through the Domain Name System (DNS). For example: <code>r2-d2.example.com</code>.
// 2 - IPAddress: Internet Protocol address (IP address), in either IPv4 or IPv6 format. For example, <code>192.168.200.24</code> or <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>.
// 3 - MACAddress: Media Access Control (MAC) address. For example: <code>18:36:F3:98:4F:9A</code>.
// 4 - UserName: User name. For example: <code>john_doe</code>.
// 5 - EmailAddress: Email address. For example: <code>john_doe@example.com</code>.
// 6 - URLString: Uniform Resource Locator (URL) string. For example: <code>http://www.example.com/download/trouble.exe</code>.
// 7 - FileName: File name. For example: <code>text-file.txt</code>.
// 8 - Hash: Hash. A unique value that corresponds to the content of the file, image, ja3_hash or hassh found in the schema. For example MD5: <code>3172ac7e2b55cbb81f04a6e65855a628</code>.
// 9 - ProcessName: Process name. For example: <code>Notepad</code>.
// 10 - ResourceUID: Resource unique identifier. For example, S3 Bucket name or EC2 Instance ID.
// 20 - Endpoint: The Endpoint object describes a physical or virtual device that connects to and exchanges information with a computer network. Some examples of endpoints are mobile devices, desktop computers, virtual machines, embedded devices, and servers. Internet-of-Things devices—like cameras, lighting, refrigerators, security systems, smart speakers, and thermostats—are also endpoints.
// 21 - User: The User object describes the characteristics of a user/person or a security principal. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:UserAccount/'>d3f:UserAccount</a>.
// 22 - Email: The Email object describes the email metadata such as sender, recipients, and direction. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Email/'>d3f:Email</a>.
// 23 - UniformResourceLocator: The Uniform Resource Locator(URL) object describes the characteristics of a URL. Defined in <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc1738'>RFC 1738</a> and by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:URL/'>d3f:URL</a>.
// 24 - File: The File object represents the metadata associated with a file stored in a computer system. It encompasses information about the file itself, including its attributes, properties, and organizational details. Defined by D3FEND <a target='_blank' href='https://next.d3fend.mitre.org/dao/artifact/d3f:File/'>d3f:File</a>.
// 25 - Process: The Process object describes a running instance of a launched program. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Process/'>d3f:Process</a>.
// 26 - GeoLocation: The Geo Location object describes a geographical location, usually associated with an IP address. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:PhysicalLocation/'>d3f:PhysicalLocation</a>.
// 27 - Container: The Container object describes an instance of a specific container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
// 30 - Fingerprint: The Fingerprint object provides detailed information about a digital fingerprint, which is a compact representation of data used to identify a longer piece of information, such as a public key or file content. It contains the algorithm and value of the fingerprint, enabling efficient and reliable identification of the associated data.
// 99 - Other: The observable data type is not mapped. See the <code>type</code> attribute, which may contain data source specific value.
// Deprecated: Use OCSF v130 package instead.
type ObservableTypeId = int

// The Organization object describes characteristics of an organization or company and its division if any.
// Deprecated: Use OCSF v130 package instead.
type Organization struct {
	// The name of the organization. For example, Widget, Inc.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The name of the organizational unit, within an organization. For example, Finance, IT, R&D
	OuName *string `json:"ou_name,omitempty" url:"ou_name,omitempty"`
	// The alternate identifier for an entity's unique identifier. For example, its Active Directory OU DN or AWS OU ID.
	OuUid *string `json:"ou_uid,omitempty" url:"ou_uid,omitempty"`
	// The unique identifier of the organization. For example, its Active Directory or AWS Org ID.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Organization) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Organization) UnmarshalJSON(data []byte) error {
	type unmarshaler Organization
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Organization(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Organization) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The Operating System (OS) object describes characteristics of an OS, such as Linux or Windows. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:OperatingSystem/'>d3f:OperatingSystem</a>.
// Deprecated: Use OCSF v130 package instead.
type Os struct {
	// The operating system build number.
	Build *string `json:"build,omitempty" url:"build,omitempty"`
	// The operating system country code, as defined by the ISO 3166-1 standard (Alpha-2 code). For the complete list of country codes, see <a target='_blank' href='https://www.iso.org/obp/ui/#iso:pub:PUB500001:en'>ISO 3166-1 alpha-2 codes</a>.
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// The Common Platform Enumeration (CPE) name as described by (<a target='_blank' href='https://nvd.nist.gov/products/cpe'>NIST</a>) For example: <code>cpe:/a:apple:safari:16.2</code>.
	CpeName *string `json:"cpe_name,omitempty" url:"cpe_name,omitempty"`
	// The cpu architecture, the number of bits used for addressing in memory. For example: <code>32</code> or <code>64</code>.
	CpuBits *int `json:"cpu_bits,omitempty" url:"cpu_bits,omitempty"`
	// The operating system edition. For example: <code>Professional</code>.
	Edition *string `json:"edition,omitempty" url:"edition,omitempty"`
	// The two letter lower case language codes, as defined by <a target='_blank' href='https://en.wikipedia.org/wiki/ISO_639-1'>ISO 639-1</a>. For example: <code>en</code> (English), <code>de</code> (German), or <code>fr</code> (French).
	Lang *string `json:"lang,omitempty" url:"lang,omitempty"`
	// The operating system name.
	Name string `json:"name" url:"name"`
	// The name of the latest Service Pack.
	SpName *string `json:"sp_name,omitempty" url:"sp_name,omitempty"`
	// The version number of the latest Service Pack.
	SpVer *int `json:"sp_ver,omitempty" url:"sp_ver,omitempty"`
	// The type of the operating system.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The type identifier of the operating system.
	TypeId OsTypeId `json:"type_id" url:"type_id"`
	// The version of the OS running on the device that originated the event. For example: "Windows 10", "OS X 10.7", or "iOS 9".
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Os) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Os) UnmarshalJSON(data []byte) error {
	type unmarshaler Os
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Os(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = nil
	return nil
}

func (o *Os) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// OsTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// 100 - Windows
// 101 - WindowsMobile
// 200 - Linux
// 201 - Android
// 300 - macOS
// 301 - iOS
// 302 - iPadOS
// 400 - Solaris
// 401 - AIX
// 402 - UX
// Deprecated: Use OCSF v130 package instead.
type OsTypeId = int

// The Policy object describes the policies that are applicable. <p>Policy attributes provide traceability to the operational state of the security product at the time that the event was captured, facilitating forensics, troubleshooting, and policy tuning/adjustments.</p>
// Deprecated: Use OCSF v130 package instead.
type Policy struct {
	// The description of the policy.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The policy group.
	Group *Group `json:"group,omitempty" url:"group,omitempty"`
	// The policy name. For example: <code>IAM Policy</code>.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A unique identifier of the policy instance.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The policy version number.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Policy) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Policy) UnmarshalJSON(data []byte) error {
	type unmarshaler Policy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Policy(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Policy) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The Process object describes a running instance of a launched program. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Process/'>d3f:Process</a>.
// Deprecated: Use OCSF v130 package instead.
type Process struct {
	// The audit user assigned at login by the audit subsystem.
	Auid *int `json:"auid,omitempty" url:"auid,omitempty"`
	// The full command line used to launch an application, service, process, or job. For example: <code>ssh user@10.0.0.10</code>. If the command line is unavailable or missing, the empty string <code>”</code> is to be used
	CmdLine *string `json:"cmd_line,omitempty" url:"cmd_line,omitempty"`
	// The information describing an instance of a container. A container is a prepackaged, portable system image that runs isolated on an existing system using a container runtime like containerd.
	Container *Container `json:"container,omitempty" url:"container,omitempty"`
	// The time when the process was created/started.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the process was created/started.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The effective group under which this process is running.
	Egid *int `json:"egid,omitempty" url:"egid,omitempty"`
	// The effective user under which this process is running.
	Euid *int `json:"euid,omitempty" url:"euid,omitempty"`
	// The process file object.
	File *File `json:"file,omitempty" url:"file,omitempty"`
	// The group under which this process is running.
	Group *Group `json:"group,omitempty" url:"group,omitempty"`
	// The process integrity level, normalized to the caption of the direction_id value. In the case of 'Other', it is defined by the event source (Windows only).
	Integrity *string `json:"integrity,omitempty" url:"integrity,omitempty"`
	// The normalized identifier of the process integrity level (Windows only).
	IntegrityId *ProcessIntegrityId `json:"integrity_id,omitempty" url:"integrity_id,omitempty"`
	// The lineage of the process, represented by a list of paths for each ancestor process. For example: <code>['/usr/sbin/sshd', '/usr/bin/bash', '/usr/bin/whoami']</code>.
	Lineage []string `json:"lineage,omitempty" url:"lineage,omitempty"`
	// The list of loaded module names.
	LoadedModules []string `json:"loaded_modules,omitempty" url:"loaded_modules,omitempty"`
	// The friendly name of the process, for example: <code>Notepad++</code>.
	Name *ProcessName `json:"name,omitempty" url:"name,omitempty"`
	// If running under a process namespace (such as in a container), the process identifier within that process namespace.
	NamespacePid *int `json:"namespace_pid,omitempty" url:"namespace_pid,omitempty"`
	// The parent process of this process object. It is recommended to only populate this field for the first process object, to prevent deep nesting.
	ParentProcess *Object `json:"parent_process,omitempty" url:"parent_process,omitempty"`
	// The process identifier, as reported by the operating system. Process ID (PID) is a number used by the operating system to uniquely identify an active process.
	Pid *int `json:"pid,omitempty" url:"pid,omitempty"`
	// The name of the containment jail (i.e., sandbox). For example, hardened_ps, high_security_ps, oracle_ps, netsvcs_ps, or default_ps.
	Sandbox *string `json:"sandbox,omitempty" url:"sandbox,omitempty"`
	// The user session under which this process is running.
	Session *Session `json:"session,omitempty" url:"session,omitempty"`
	// The time when the process was terminated.
	TerminatedTime *Timestamp `json:"terminated_time,omitempty" url:"terminated_time,omitempty"`
	// The time when the process was terminated.
	TerminatedTimeDt *time.Time `json:"terminated_time_dt,omitempty" url:"terminated_time_dt,omitempty"`
	// The Identifier of the thread associated with the event, as returned by the operating system.
	Tid *int `json:"tid,omitempty" url:"tid,omitempty"`
	// A unique identifier for this process assigned by the producer (tool). Facilitates correlation of a process event with other events for that process.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The user under which this process is running.
	User *User `json:"user,omitempty" url:"user,omitempty"`
	// An unordered collection of zero or more name/value pairs that represent a process extended attribute.
	Xattributes *Object `json:"xattributes,omitempty" url:"xattributes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Process) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Process) UnmarshalJSON(data []byte) error {
	type embed Process
	var unmarshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		TerminatedTimeDt *core.DateTime `json:"terminated_time_dt,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Process(unmarshaler.embed)
	p.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	p.TerminatedTimeDt = unmarshaler.TerminatedTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Process) MarshalJSON() ([]byte, error) {
	type embed Process
	var marshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		TerminatedTimeDt *core.DateTime `json:"terminated_time_dt,omitempty"`
	}{
		embed:            embed(*p),
		CreatedTimeDt:    core.NewOptionalDateTime(p.CreatedTimeDt),
		TerminatedTimeDt: core.NewOptionalDateTime(p.TerminatedTimeDt),
	}
	return json.Marshal(marshaler)
}

func (p *Process) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// ProcessIntegrityId is an enum, and the following values are allowed.
// 0 - Unknown
// 1 - Untrusted
// 2 - Low
// 3 - Medium
// 4 - High
// 5 - System
// 6 - Protected
// 99 - Other
// Deprecated: Use OCSF v130 package instead.
type ProcessIntegrityId = int

// The Product object describes characteristics of a software product.
// Deprecated: Use OCSF v130 package instead.
type Product struct {
	// The Common Platform Enumeration (CPE) name as described by (<a target='_blank' href='https://nvd.nist.gov/products/cpe'>NIST</a>) For example: <code>cpe:/a:apple:safari:16.2</code>.
	CpeName *string `json:"cpe_name,omitempty" url:"cpe_name,omitempty"`
	// The feature that reported the event.
	Feature *Feature `json:"feature,omitempty" url:"feature,omitempty"`
	// The two letter lower case language codes, as defined by <a target='_blank' href='https://en.wikipedia.org/wiki/ISO_639-1'>ISO 639-1</a>. For example: <code>en</code> (English), <code>de</code> (German), or <code>fr</code> (French).
	Lang *string `json:"lang,omitempty" url:"lang,omitempty"`
	// The name of the product.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The installation path of the product.
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// The unique identifier of the product.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The URL pointing towards the product.
	UrlString *UrlString `json:"url_string,omitempty" url:"url_string,omitempty"`
	// The name of the vendor of the product.
	VendorName string `json:"vendor_name" url:"vendor_name"`
	// The version of the product, as defined by the event source. For example: <code>2013.1.3-beta</code>.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Product) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Product) UnmarshalJSON(data []byte) error {
	type unmarshaler Product
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Product(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = nil
	return nil
}

func (p *Product) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// The Reputation object describes the reputation/risk score of an entity (e.g. device, user, domain).
// Deprecated: Use OCSF v130 package instead.
type Reputation struct {
	// The reputation score as reported by the event source.
	BaseScore float64 `json:"base_score" url:"base_score"`
	// The provider of the reputation information.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// The reputation score, normalized to the caption of the score_id value. In the case of 'Other', it is defined by the event source.
	Score *string `json:"score,omitempty" url:"score,omitempty"`
	// The normalized reputation score identifier.
	ScoreId ReputationScoreId `json:"score_id" url:"score_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Reputation) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Reputation) UnmarshalJSON(data []byte) error {
	type unmarshaler Reputation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Reputation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Reputation) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// ReputationScoreId is an enum, and the following values are allowed.
// 0 - Unknown: The reputation score is unknown.
// 1 - VerySafe: Long history of good behavior.
// 2 - Safe: Consistently good behavior.
// 3 - ProbablySafe: Reasonable history of good behavior.
// 4 - LeansSafe: Starting to establish a history of normal behavior.
// 5 - MaynotbeSafe: No established history of normal behavior.
// 6 - ExerciseCaution: Starting to establish a history of suspicious or risky behavior.
// 7 - Risky: A site with a history of suspicious or risky behavior. (spam, scam, potentially unwanted software, potentially malicious).
// 8 - PossiblyMalicious: Strong possibility of maliciousness.
// 9 - ProbablyMalicious: Indicators of maliciousness.
// 10 - Malicious: Proven evidence of maliciousness.
// 99 - Other: The reputation score is not mapped. See the <code>rep_score</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type ReputationScoreId = int

// The Request Elements object describes characteristics of an API request.
// Deprecated: Use OCSF v130 package instead.
type Request struct {
	// When working with containerized applications, the set of containers which write to the standard the output of a particular logging driver. For example, this may be the set of containers involved in handling api requests and responses for a containerized application.
	Containers []*Container `json:"containers,omitempty" url:"containers,omitempty"`
	// The additional data that is associated with the api request.
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`
	// The list of communication flags, normalized to the captions of the flag_ids values. In the case of 'Other', they are defined by the event source.
	Flags []string `json:"flags,omitempty" url:"flags,omitempty"`
	// The unique request identifier.
	Uid string `json:"uid" url:"uid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Request) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Request) UnmarshalJSON(data []byte) error {
	type unmarshaler Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Request) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The Response Elements object describes characteristics of an API response.
// Deprecated: Use OCSF v130 package instead.
type Response struct {
	// The numeric response sent to a request.
	Code *int `json:"code,omitempty" url:"code,omitempty"`
	// When working with containerized applications, the set of containers which write to the standard the output of a particular logging driver. For example, this may be the set of containers involved in handling api requests and responses for a containerized application.
	Containers []*Container `json:"containers,omitempty" url:"containers,omitempty"`
	// The additional data that is associated with the api response.
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Error Code
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Error Message
	ErrorMessage *string `json:"error_message,omitempty" url:"error_message,omitempty"`
	// The list of communication flags, normalized to the captions of the flag_ids values. In the case of 'Other', they are defined by the event source.
	Flags []string `json:"flags,omitempty" url:"flags,omitempty"`
	// The description of the event/finding, as defined by the source.
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Response) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Response) UnmarshalJSON(data []byte) error {
	type unmarshaler Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Response(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = nil
	return nil
}

func (r *Response) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The Subject Alternative name (SAN) object describes a SAN secured by a digital certificate
// Deprecated: Use OCSF v130 package instead.
type San struct {
	// Name of SAN (e.g. The actual IP Address or domain.)
	Name string `json:"name" url:"name"`
	// Type descriptor of SAN (e.g. IP Address/domain/etc.)
	Type string `json:"type" url:"type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *San) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *San) UnmarshalJSON(data []byte) error {
	type unmarshaler San
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = San(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *San) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The Service object describes characteristics of a service, <code> e.g. AWS EC2. </code>
// Deprecated: Use OCSF v130 package instead.
type Service struct {
	// The list of labels associated with the service.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The name of the service.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique identifier of the service.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The version of the service.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Service) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Service) UnmarshalJSON(data []byte) error {
	type unmarshaler Service
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Service(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Service) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The Session object describes details about an authenticated session. e.g. Session Creation Time, Session Issuer. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:Session/'>d3f:Session</a>.
// Deprecated: Use OCSF v130 package instead.
type Session struct {
	// The number of identical sessions spawned from the same source IP, destination IP, application, and content/threat type seen over a period of time.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// The time when the session was created.
	CreatedTime *Timestamp `json:"created_time,omitempty" url:"created_time,omitempty"`
	// The time when the session was created.
	CreatedTimeDt *time.Time `json:"created_time_dt,omitempty" url:"created_time_dt,omitempty"`
	// The unique identifier of the user's credential. For example, AWS Access Key ID.
	CredentialUid *string `json:"credential_uid,omitempty" url:"credential_uid,omitempty"`
	// The reason which triggered the session expiration.
	ExpirationReason *string `json:"expiration_reason,omitempty" url:"expiration_reason,omitempty"`
	// The session expiration time.
	ExpirationTime *Timestamp `json:"expiration_time,omitempty" url:"expiration_time,omitempty"`
	// The session expiration time.
	ExpirationTimeDt *time.Time `json:"expiration_time_dt,omitempty" url:"expiration_time_dt,omitempty"`
	// Indicates whether Multi Factor Authentication was used during authentication.
	IsMfa *bool `json:"is_mfa,omitempty" url:"is_mfa,omitempty"`
	// The indication of whether the session is remote.
	IsRemote *bool `json:"is_remote,omitempty" url:"is_remote,omitempty"`
	// The indication of whether the session is a VPN session.
	IsVpn *bool `json:"is_vpn,omitempty" url:"is_vpn,omitempty"`
	// The identifier of the session issuer.
	Issuer *string `json:"issuer,omitempty" url:"issuer,omitempty"`
	// The Pseudo Terminal associated with the session. Ex: the tty or pts value.
	Terminal *string `json:"terminal,omitempty" url:"terminal,omitempty"`
	// The unique identifier of the session.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The alternate unique identifier of the session. e.g. AWS ARN - <code>arn:aws:sts::123344444444:assumed-role/Admin/example-session</code>.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The universally unique identifier of the session.
	Uuid *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Session) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Session) UnmarshalJSON(data []byte) error {
	type embed Session
	var unmarshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Session(unmarshaler.embed)
	s.CreatedTimeDt = unmarshaler.CreatedTimeDt.TimePtr()
	s.ExpirationTimeDt = unmarshaler.ExpirationTimeDt.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = nil
	return nil
}

func (s *Session) MarshalJSON() ([]byte, error) {
	type embed Session
	var marshaler = struct {
		embed
		CreatedTimeDt    *core.DateTime `json:"created_time_dt,omitempty"`
		ExpirationTimeDt *core.DateTime `json:"expiration_time_dt,omitempty"`
	}{
		embed:            embed(*s),
		CreatedTimeDt:    core.NewOptionalDateTime(s.CreatedTimeDt),
		ExpirationTimeDt: core.NewOptionalDateTime(s.ExpirationTimeDt),
	}
	return json.Marshal(marshaler)
}

func (s *Session) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The Transport Layer Security (TLS) object describes the negotiated TLS protocol used for secure communications over an establish network connection.
// Deprecated: Use OCSF v130 package instead.
type Tls struct {
	// The integer value of TLS alert if present. The alerts are defined in the TLS specification in <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc2246'>RFC-2246</a>.
	Alert *int `json:"alert,omitempty" url:"alert,omitempty"`
	// The certificate object containing information about the digital certificate.
	Certificate *Certificate `json:"certificate,omitempty" url:"certificate,omitempty"`
	// The Chain of Certificate Serial Numbers field provides a chain of Certificate Issuer Serial Numbers leading to the Root Certificate Issuer.
	CertificateChain []string `json:"certificate_chain,omitempty" url:"certificate_chain,omitempty"`
	// The negotiated cipher suite.
	Cipher *string `json:"cipher,omitempty" url:"cipher,omitempty"`
	// The client cipher suites that were exchanged during the TLS handshake negotiation.
	ClientCiphers []string `json:"client_ciphers,omitempty" url:"client_ciphers,omitempty"`
	// The list of TLS extensions.
	ExtensionList []*TlsExtension `json:"extension_list,omitempty" url:"extension_list,omitempty"`
	// The amount of total time for the TLS handshake to complete after the TCP connection is established, including client-side delays, in milliseconds.
	HandshakeDur *int `json:"handshake_dur,omitempty" url:"handshake_dur,omitempty"`
	// The MD5 hash of a JA3 string.
	Ja3Hash *Fingerprint `json:"ja3_hash,omitempty" url:"ja3_hash,omitempty"`
	// The MD5 hash of a JA3S string.
	Ja3SHash *Fingerprint `json:"ja3s_hash,omitempty" url:"ja3s_hash,omitempty"`
	// The length of the encryption key.
	KeyLength *int `json:"key_length,omitempty" url:"key_length,omitempty"`
	// The list of subject alternative names that are secured by a specific certificate.
	Sans []*San `json:"sans,omitempty" url:"sans,omitempty"`
	// The server cipher suites that were exchanged during the TLS handshake negotiation.
	ServerCiphers []string `json:"server_ciphers,omitempty" url:"server_ciphers,omitempty"`
	// The Server Name Indication (SNI) extension sent by the client.
	Sni *string `json:"sni,omitempty" url:"sni,omitempty"`
	// The list of TLS extensions.
	TlsExtensionList []*TlsExtension `json:"tls_extension_list,omitempty" url:"tls_extension_list,omitempty"`
	// The TLS protocol version.
	Version string `json:"version" url:"version"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Tls) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tls) UnmarshalJSON(data []byte) error {
	type unmarshaler Tls
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tls(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *Tls) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The TLS Extension object describes additional attributes that extend the base Transport Layer Security (TLS) object.
// Deprecated: Use OCSF v130 package instead.
type TlsExtension struct {
	// The data contains information specific to the particular extension type.
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`
	// The TLS extension type. For example: <code>Server Name</code>.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The TLS extension type identifier. See <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc8446#page-35'>The Transport Layer Security (TLS) extension page</a>.
	TypeId TlsExtensionTypeId `json:"type_id" url:"type_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TlsExtension) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TlsExtension) UnmarshalJSON(data []byte) error {
	type unmarshaler TlsExtension
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TlsExtension(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = nil
	return nil
}

func (t *TlsExtension) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// TlsExtensionTypeId is an enum, and the following values are allowed.
// 0 - name: The Server Name Indication extension.
// 1 - fragment_length: The Maximum Fragment Length Negotiation extension.
// 5 - request: The Certificate Status Request extension.
// 10 - groups: The Supported Groups extension.
// 13 - algorithms: The Signature Algorithms extension.
// 14 - srtp: The Use SRTP data protection extension.
// 15 - heartbeat: The Heartbeat extension.
// 16 - layer_protocol_negotiation: The Application-Layer Protocol Negotiation extension.
// 18 - certificate_timestamp: The Signed Certificate Timestamp extension.
// 19 - certificate_type: The Client Certificate Type extension.
// 20 - certificate_type: The Server Certificate Type extension.
// 21 - padding: The Padding extension.
// 41 - shared_key: The Pre Shared Key extension.
// 42 - data: The Early Data extension.
// 43 - versions: The Supported Versions extension.
// 44 - cookie: The Cookie extension.
// 45 - key_exchange_modes: The Pre-Shared Key Exchange Modes extension.
// 47 - authorities: The Certificate Authorities extension.
// 48 - filters: The OID Filters extension.
// 49 - handshake_auth: The Post-Handshake Client Authentication extension.
// 50 - algorithms_cert: The Signature Algorithms extension.
// 51 - share: The Key Share extension.
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type TlsExtensionTypeId = int

// The Uniform Resource Locator(URL) object describes the characteristics of a URL. Defined in <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc1738'>RFC 1738</a> and by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:URL/'>d3f:URL</a>.
// Deprecated: Use OCSF v130 package instead.
type Url struct {
	// The Website categorization names, as defined by <code>category_ids</code> enum values.
	Categories []string `json:"categories,omitempty" url:"categories,omitempty"`
	// The Website categorization identifies.
	CategoryIds []UrlCategoryIds `json:"category_ids,omitempty" url:"category_ids,omitempty"`
	// The URL host as extracted from the URL. For example: <code>www.example.com</code> from <code>www.example.com/download/trouble</code>.
	Hostname *Hostname `json:"hostname,omitempty" url:"hostname,omitempty"`
	// The URL path as extracted from the URL. For example: <code>/download/trouble</code> from <code>www.example.com/download/trouble</code>.
	Path *string `json:"path,omitempty" url:"path,omitempty"`
	// The URL port. For example: <code>80</code>.
	Port *Port `json:"port,omitempty" url:"port,omitempty"`
	// The query portion of the URL. For example: the query portion of the URL <code>http://www.example.com/search?q=bad&sort=date</code> is <code>q=bad&sort=date</code>.
	QueryString *string `json:"query_string,omitempty" url:"query_string,omitempty"`
	// The context in which a resource was retrieved in a web request.
	ResourceType *string `json:"resource_type,omitempty" url:"resource_type,omitempty"`
	// The scheme portion of the URL. For example: <code>http</code>, <code>https</code>, <code>ftp</code>, or <code>sftp</code>.
	Scheme *string `json:"scheme,omitempty" url:"scheme,omitempty"`
	// The subdomain portion of the URL. For example: <code>sub</code> in <code>https://sub.example.com</code> or <code>sub2.sub1</code> in <code>https://sub2.sub1.example.com</code>.
	Subdomain *string `json:"subdomain,omitempty" url:"subdomain,omitempty"`
	// The URL string. See RFC 1738. For example: <code>http://www.example.com/download/trouble.exe</code>. Note: The URL path should not populate the URL string.
	UrlString *UrlString `json:"url_string,omitempty" url:"url_string,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *Url) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *Url) UnmarshalJSON(data []byte) error {
	type unmarshaler Url
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = Url(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = nil
	return nil
}

func (u *Url) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// UrlCategoryIds is an enum, and the following values are allowed.
// 0 - Unknown: The Domain/URL category is unknown.
// 1 - MatureContent
// 3 - Pornography
// 4 - SexEducation
// 5 - Swimsuit
// 6 - Nudity
// 7 - Extreme
// 9 - Questionable*Illegal
// 11 - Gambling
// 14 - Hate_Racism
// 15 - Weapons
// 16 - Abortion
// 17 - Hacking
// 18 - Phishing
// 20 - Entertainment
// 21 - Economy
// 22 - Belief
// 23 - Alcohol
// 24 - Tobacco
// 25 - ControlledSubstances
// 26 - ChildPornography
// 27 - Education
// 29 - CharitableOrganizations
// 30 - Culture
// 31 - FinancialServices
// 32 - Trading
// 33 - Games
// 34 - Legal
// 35 - Military
// 36 - SocialAdvocacy
// 37 - Health
// 38 - Internet
// 40 - Portals
// 43 - Malnets
// 44 - Botnets
// 45 - Careers
// 46 - Media
// 47 - Dating
// 49 - Reference
// 50 - PotentiallyAdult
// 51 - IM_SMS
// 52 - Email
// 53 - Forums
// 54 - Religion
// 55 - SocialNetworking
// 56 - Sharing
// 57 - RemoteAccessTools
// 58 - Shopping
// 59 - Auctions
// 60 - RealEstate
// 61 - DailyLiving
// 63 - PersonalSites
// 64 - Dining_Food
// 65 - Recreation
// 66 - Travel
// 67 - Vehicles
// 68 - Jokes
// 71 - SoftwareDownloads
// 83 - to_Peer_P2P*
// 84 - VideoClips
// 85 - BusinessApplications
// 86 - ProxyAvoidance
// 87 - ForKids
// 88 - Analytics
// 89 - WebHosting
// 90 - Uncategorized
// 92 - Suspicious
// 93 - SexualExpression
// 95 - Translation
// 96 - Viewable_Infrastructure
// 97 - ContentServers
// 98 - Placeholders
// 99 - Other: The Domain/URL category is not mapped. See the <code>categories</code> attribute, which contains a data source specific value.
// 101 - Spam
// 102 - PotentiallyUnwantedSoftware
// 103 - DynamicDNSHost
// 106 - Card_Invitations
// 107 - Informational
// 108 - InformationSecurity
// 109 - InternetConnectedDevices
// 110 - InternetTelephony
// 111 - OnlineMeetings
// 112 - MediaSharing
// 113 - AudioStreams
// 114 - VideoStreams
// 118 - CopyrightConcerns
// 121 - Marijuana
// Deprecated: Use OCSF v130 package instead.
type UrlCategoryIds = int

// The User object describes the characteristics of a user/person or a security principal. Defined by D3FEND <a target='_blank' href='https://d3fend.mitre.org/dao/artifact/d3f:UserAccount/'>d3f:UserAccount</a>.
// Deprecated: Use OCSF v130 package instead.
type User struct {
	// The user's account or the account associated with the user.
	Account *Account `json:"account,omitempty" url:"account,omitempty"`
	// The unique identifier of the user's credential. For example, AWS Access Key ID.
	CredentialUid *string `json:"credential_uid,omitempty" url:"credential_uid,omitempty"`
	// The domain where the user is defined. For example: the LDAP or Active Directory domain.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// The user's primary email address.
	EmailAddr *EmailAddress `json:"email_addr,omitempty" url:"email_addr,omitempty"`
	// The full name of the person, as per the LDAP Common Name attribute (cn).
	FullName *string `json:"full_name,omitempty" url:"full_name,omitempty"`
	// The administrative groups to which the user belongs.
	Groups []*Group `json:"groups,omitempty" url:"groups,omitempty"`
	// The additional LDAP attributes that describe a person.
	LdapPerson *LdapPerson `json:"ldap_person,omitempty" url:"ldap_person,omitempty"`
	// The multi-factor authentication status, normalized to the caption of the mfa_status_id value. In the case of 'Other', it is defined by the data source.
	MfaStatus *string `json:"mfa_status,omitempty" url:"mfa_status,omitempty"`
	// The normalized identifier of the user's multi-factor authentication status.
	MfaStatusId *UserMfaStatusId `json:"mfa_status_id,omitempty" url:"mfa_status_id,omitempty"`
	// The username. For example, <code>janedoe1</code>.
	Name *UserName `json:"name,omitempty" url:"name,omitempty"`
	// Organization and org unit related to the user.
	Org *Organization `json:"org,omitempty" url:"org,omitempty"`
	// The user's privileges.
	Privileges []string `json:"privileges,omitempty" url:"privileges,omitempty"`
	// The type of the user. For example, System, AWS IAM User, etc.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The account type identifier.
	TypeId *UserTypeId `json:"type_id,omitempty" url:"type_id,omitempty"`
	// The unique user identifier. For example, the Windows user SID, ActiveDirectory DN or AWS user ARN.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The alternate user identifier. For example, the Active Directory user GUID or AWS user Principal ID.
	UidAlt *string `json:"uid_alt,omitempty" url:"uid_alt,omitempty"`
	// The user status, normalized to the caption of the user_status_id value. In the case of 'Other', it is defined by the data source.
	UserStatus *string `json:"user_status,omitempty" url:"user_status,omitempty"`
	// The normalized identifier of the user's status.
	UserStatusId *UserUserStatusId `json:"user_status_id,omitempty" url:"user_status_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *User) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *User) UnmarshalJSON(data []byte) error {
	type unmarshaler User
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = User(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = nil
	return nil
}

func (u *User) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// UserMfaStatusId is an enum, and the following values are allowed.
// 0 - Unknown: The status is unknown.
// 1 - Enabled: Multi-factor authentication is on for this user.
// 2 - NotEnabled: TMulti-factor authentication is off for this user.
// 99 - Other: The event status is not mapped. See the <code>user_status</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type UserMfaStatusId = int

// UserTypeId is an enum, and the following values are allowed.
// 0 - Unknown: The type is unknown.
// 1 - User: Regular user account.
// 2 - Admin: Admin/root user account.
// 3 - System: System account. For example, Windows computer accounts with a trailing dollar sign ($).
// 99 - Other: The type is not mapped. See the <code>type</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type UserTypeId = int

// UserUserStatusId is an enum, and the following values are allowed.
// 0 - Unknown: The status is unknown.
// 1 - Active: The user is active.
// 2 - Pending: The user is not active, pending either user or admin action.
// 3 - Locked: The user account is locked requiring either time or intervention to unlock.
// 4 - Suspended: The user account is suspended.
// 5 - Deprovisioned: The user account has been deprovisioned and is pending removal.
// 99 - Other: The event status is not mapped. See the <code>user_status</code> attribute, which contains a data source specific value.
// Deprecated: Use OCSF v130 package instead.
type UserUserStatusId = int

// The Web Resource object describes characteristics of a web resource that was affected by the activity/event.
// Deprecated: Use OCSF v130 package instead.
type WebResource struct {
	// Details of the web resource, e.g, <code>file</code> details, <code>search</code> results or application-defined resource.
	Data interface{} `json:"data,omitempty" url:"data,omitempty"`
	// Description of the web resource.
	Desc *string `json:"desc,omitempty" url:"desc,omitempty"`
	// The list of labels/tags associated to a resource.
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// The name of the web resource.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The web resource type as defined by the event source.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique identifier of the web resource.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The URL pointing towards the source of the web resource.
	UrlString *UrlString `json:"url_string,omitempty" url:"url_string,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebResource) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebResource) UnmarshalJSON(data []byte) error {
	type unmarshaler WebResource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebResource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = nil
	return nil
}

func (w *WebResource) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
